 /************************************************************************
 * Copyright Â© 2007-2010 - General Electric Company, All Rights Reserved
 *
 * Project: SADL
 *
 * Description: The Semantic Application Design Language (SADL) is a
 * language for building semantic models and expressing rules that
 * capture additional domain knowledge. The SADL-IDE (integrated
 * development environment) is a set of Eclipse plug-ins that
 * support the editing and testing of semantic models using the
 * SADL language.
 *
 * This software is distributed "AS-IS" without ANY WARRANTIES
 * and licensed under the Eclipse Public License - v 1.0
 * which is available at http://www.eclipse.org/org/documents/epl-v10.php
 *
 ***********************************************************************/

 package com.ge.research.sadl.jena;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.CompositeNodeWithSemanticElement;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ge.research.sadl.model.ConceptName;
import com.ge.research.sadl.model.ConceptName.ConceptType;
import com.ge.research.sadl.model.gp.BuiltinElement;
import com.ge.research.sadl.model.gp.BuiltinElement.BuiltinType;
import com.ge.research.sadl.model.gp.GraphPatternElement;
import com.ge.research.sadl.model.gp.Junction;
import com.ge.research.sadl.model.gp.Junction.JunctionType;
import com.ge.research.sadl.model.gp.KnownNode;
import com.ge.research.sadl.model.gp.Literal;
import com.ge.research.sadl.model.gp.NegatedExistentialQuantifier;
import com.ge.research.sadl.model.gp.ProxyNode;
import com.ge.research.sadl.model.gp.Query;
import com.ge.research.sadl.model.gp.Query.Order;
import com.ge.research.sadl.model.gp.Query.OrderingPair;
import com.ge.research.sadl.model.gp.TripleElement.TripleModifierType;
import com.ge.research.sadl.model.gp.NamedNode;
import com.ge.research.sadl.model.gp.Node;
import com.ge.research.sadl.model.gp.RDFTypeNode;
import com.ge.research.sadl.model.gp.Rule;
import com.ge.research.sadl.model.gp.Test;
import com.ge.research.sadl.model.gp.TripleElement;
import com.ge.research.sadl.model.gp.TripleElement.TripleSourceType;
import com.ge.research.sadl.model.gp.ValueTableNode;
import com.ge.research.sadl.model.gp.VariableNode;
import com.ge.research.sadl.model.gp.NamedNode.NodeType;
import com.ge.research.sadl.model.gp.Test.ComparisonType;
import com.ge.research.sadl.reasoner.InvalidNameException;
import com.ge.research.sadl.reasoner.InvalidTypeException;
import com.ge.research.sadl.reasoner.TranslationException;
import com.ge.research.sadl.sADL.Expression;
import com.ge.research.sadl.sADL.TestStatement;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * This class translates the output generated by parsing SADL queries, 
 * rules, and tests into what is called the SADL Intermediate Form (IF).  
 * The parser output is in the form of parse trees whose nodes are 
 * instances of the class Expression or of one of its subclasses.
 * The IF uses the Java classes in the Graph Patterns package 
 * (com.ge.research.sadl.model.gp). In the IF, each query or 
 * rule part (given, if, or then) or test phrase consists of 
 * a list of graph pattern elements.  The graph pattern element 
 * can be a triple pattern or it can be a built-in.  This 
 * Intermediate Form is passed to the reasoner-specific translator 
 * to generate rules and queries in an optimized form and format 
 * for the target reasoner.
 * 
 * One of the primary contributions of SADL to the modeling process is
 * its English-like syntax. The translation accomplished by this class
 * goes from this English-like syntax to the IF. Among other things, this
 * involves the generation of "missing" variables to provide the 
 * connectives between the individual graph pattern elements in a list.
 * 
 * The translation process "walks" the Expression parse tree. At the 
 * leaves of this parse tree are ExplicitValues, IntervalValues, 
 * ValueTables, or built-ins. At each node higher in the parse tree, 
 * if returning to the node represents the completion of a graph pattern 
 * element then that element is placed in the list at the appropriate 
 * location and if necessary a variable (Node) is identified to connect 
 * this new graph pattern element to other graph pattern elements 
 * in the list.
 * 
 * 10/2011:
 * The approach of adding variables as the translation proceeds, bottom-up,
 * has issues as looking bottom up one can't always tell the context and
 * therefore make the right decision. Therefore the strategy is changed to 
 * use a ProxyNode to encapsulate the lower-level constructs to replicate
 * the parse tree but in the IF structures. Then the expansion of ProxyNodes
 * can occur with a knowledge of context for proper decisioning. For example,
 * no information is available to know whether a rule built-in has zero, one,
 * or more output variables. However, usage will show that either the built-in
 * is used within a higher-level built-in or triple, in which case it must 
 * generate an output other than boolean so in expand ProxyNodes it will be
 * property handled by adding a generated variable if a specified variable
 * was not given, which variable is also placed in
 * the higher-level construct. In the future built-ins might be allowed to 
 * return multiple values but that would require a construct such as
 * 
 * 	x,y,z is someBuiltin(input1, input2, ..)
 * 
 * This extension of the grammar would provide the necessary information 
 * about the number of output variables to add, but only with the contextual
 * knowledge of the whole statement.
 * 
 * 
 * @author crapo
 *
 */
public class IntermediateFormTranslator {
    private static final Logger logger = LoggerFactory.getLogger(IntermediateFormTranslator.class);
    private int vNum = 0;	// used to create unique variables
    private List<IFTranslationError> errors = null;
    private Object target = null;	// the instance of Rule, Query, or Test into which we are trying to put the translation
    private Object encapsulatingTarget = null;	// when a query is in a test
    private GraphPatternElement firstOfPhrase = null;
    
    private List<ConceptName> namedNodes = null;
    private boolean collectNamedNodes = false;
    private List<String> userDefinedVariables = new ArrayList<String>();
    private OntModel theJenaModel = null;
    
	private List<VariableNode> cruleVariablesTypeOutput = null;		// list of crule variables that have had type statements output (only do so once)

	/**
     * The constructor takes a ModelManager argument
     * @param ontModel 
     * @param modmgr
     */
    public IntermediateFormTranslator(OntModel ontModel) {
    	theJenaModel = ontModel;
    }
    
    // the target can be a Test, a Query, or a Rule instance
    public void setTarget(Object _target) {
    	target = _target;
    }
    
	/**
	 * Reset the translator for a new translation task
	 */
	protected void resetIFTranslator() {
		vNum = 0;
		if (errors != null) {
			errors.clear();
		}
		target = null;
		encapsulatingTarget = null;
		setFirstOfPhrase(null);
	}
	
	/**
	 * Returns the bottom triple whose subject was replaced.
	 * @param pattern
	 * @param proxyFor
	 * @param assignedNode
	 * @return
	 */
	private TripleElement assignNullSubjectInProxies(TripleElement pattern,
			TripleElement proxyFor, Node assignedNode) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
//				((ProxyNode)pattern.getSubject()).setReplacementNode(assignedNode);
				if (((TripleElement)proxy).getSubject() == null) {
					// this is the bottom of the recursion
					((TripleElement)proxy).setSubject(assignedNode);
					return (TripleElement) proxy;
				}
				else {
					// recurse down
					TripleElement bottom = assignNullSubjectInProxies(((TripleElement)proxy), proxyFor, assignedNode);
					// make the proxy next and reassign this subject as assignedNode
					((ProxyNode)((TripleElement)proxy).getSubject()).setReplacementNode(assignedNode);
					((TripleElement)proxy).setSubject(assignedNode);
					if (bottom.getNext() == null) {
						bottom.setNext(pattern);
					}
					return bottom;
				}
			}
		}
		return null;
	}

	private TripleElement getProxyWithNullSubject(TripleElement pattern) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
				if (((TripleElement)proxy).getSubject() == null) {
					return (TripleElement)proxy;
				}
				else {
					return getProxyWithNullSubject(((TripleElement)proxy));
				}
			}
		}
		return null;
	}

	private boolean isComparisonViaBuiltin(Object robj, Object lobj) {
		if (robj instanceof TripleElement && lobj instanceof Node &&
				((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (isComparisonBuiltin(be.getFuncName()) && be.getArguments().size() == 1) {
				return true;
			}
		}
		return false;
	}

	private boolean isModifiedTripleViaBuitin(Object robj) {
		if (robj instanceof TripleElement && ((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (((TripleElement)robj).getPredicate() instanceof RDFTypeNode) {
				if (isModifiedTriple(be.getFuncType())) {
					Node subj = ((TripleElement)robj).getSubject();
					Node arg = (be.getArguments() != null && be.getArguments().size() > 0) ? be.getArguments().get(0) : null;
					if (subj == null && arg == null) {
						return true;
					}
					if (subj != null && arg != null && subj.equals(arg)) {
						return true;
					}
				}
			}
			else {
				if (isModifiedTriple(be.getFuncType()) && ((TripleElement)robj).getObject().equals(be.getArguments().get(0))) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasCommonVariableSubject(Object robj) {
		if (robj instanceof TripleElement && 
				(((TripleElement)robj).getSubject() instanceof VariableNode && 
						(((TripleElement)robj).getSourceType().equals(TripleSourceType.SPV)) ||
						((TripleElement)robj).getSourceType().equals(TripleSourceType.ITC))) {
			VariableNode subjvar = (VariableNode) ((TripleElement)robj).getSubject();
			Object trel = robj;
			while (trel != null && trel instanceof TripleElement) {
				if (!(trel instanceof TripleElement) || 
						(((TripleElement)trel).getSubject() != null &&!(((TripleElement)trel).getSubject().equals(subjvar)))) {
					return false;
				}
				trel = ((TripleElement)trel).getNext();
			}
			if (trel == null) {
				return true;
			}
		}
		return false;
	}

	public static boolean isModifiedTriple(BuiltinType type) {
		if (type.equals(BuiltinType.Not) || type.equals(BuiltinType.NotEqual) || type.equals(BuiltinType.Only)||  type.equals(BuiltinType.NotOnly)) {
			return true;
		}
		return false;
	}
	
	private TripleModifierType getTripleModifierType(BuiltinType btype) {
		if (btype.equals(BuiltinType.Not) || btype.equals(BuiltinType.NotEqual)) {
			return TripleModifierType.Not;
		}
		else if (btype.equals(BuiltinType.Only)) {
			return TripleModifierType.Only;
		}
		else if (btype.equals(BuiltinType.NotOnly)) {
			return TripleModifierType.NotOnly;
		}
		return null;
	}
	
	public String getSourceGrammarText(EObject po) {
		Object r = po.eResource();
		if (r instanceof XtextResource) {
			INode root = ((XtextResource) r).getParseResult().getRootNode();
	        for(INode node : root.getAsTreeIterable()) {   
	        	if (node instanceof CompositeNodeWithSemanticElement) {
	        		EObject semElt = ((CompositeNodeWithSemanticElement)node).getSemanticElement();
	        		if (semElt.equals(po)) {
	        			// this is the one!
	        			String txt = NodeModelUtils.getTokenText(node);
	   					return txt.trim();
	        		}
	        	}
	        }
			org.eclipse.emf.common.util.TreeIterator<EObject> titr = po.eAllContents();
			while (titr.hasNext()) {
				EObject el = titr.next();
// TODO what's supposed to happen here?
				int i = 0;
			}
		}
		return null;
	}

	/**
	 * This method fills in missing information in a NamedNode: 
	 * the prefix, the namespace, the type
	 * 
	 * @param namedNode
	 * @return
	 * @throws InvalidNameException 
	 */
	protected Node validateNode(Node node) throws InvalidNameException {
		if (node instanceof NamedNode) {
			if (!((NamedNode)node).isValidated()) {
				if (node instanceof VariableNode) {
					((VariableNode) node).setNodeType(NodeType.VariableNode);
					userDefinedVariables.add(((NamedNode) node).getName());
				}
				else if (node instanceof RDFTypeNode) {
					((RDFTypeNode) node).setNodeType(NodeType.PropertyNode);
				}
				else {
					ConceptName cname = null;
					ConceptType ctype = null;
					String name = ((NamedNode)node).toString(); //getName();
					if (name == null) {
						throw new InvalidNameException("A NamedNode has a null name! Did ResourceByName resolution fail?");
					}
				    int colon = name.indexOf(':');
					if (colon > 0 && colon < name.length() - 1) {
						String pfx = name.substring(0, colon);
				        ((NamedNode)node).setPrefix(pfx);
				        String lname = name.substring(colon + 1);
				        ((NamedNode)node).setName(lname);
//				        cname = modelManager.validateConceptName(new ConceptName(pfx, lname));
				    }
				    else {
//				    	cname = modelManager.validateConceptName(new ConceptName(name));
				    }
			        ctype = cname.getType();
			        ((NamedNode)node).setNamespace(cname.getNamespace());
			        ((NamedNode)node).setPrefix(cname.getPrefix());
			    	if (ctype.equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)) {
//			    		modelManager.addToVariableNamesCache(cname);
			    		node = new VariableNode(((NamedNode)node).getName());
			    		userDefinedVariables.add(((NamedNode) node).getName());
			    	}
			    	else if (ctype.equals(ConceptType.ANNOTATIONPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.DATATYPEPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.OBJECTPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.ONTCLASS)){
			    		((NamedNode)node).setNodeType(NodeType.ClassNode);
			    	}
			    	else if (ctype.equals(ConceptType.INDIVIDUAL)){
			    		((NamedNode)node).setNodeType(NodeType.InstanceNode);
			    	}
			    	else {
			    		logger.error("Unexpected ConceptType: " + ctype.toString());
				    	addError(new IFTranslationError("Unexpected ConceptType: " + ctype.toString()));
			    	}
			    	if (isCollectNamedNodes()) {
			    		if (namedNodes == null) {
			    			namedNodes = new ArrayList<ConceptName>();
			    		}
			    		if (!namedNodes.contains(cname)) {
			    			namedNodes.add(cname);
			    		}
			    	}
				}
				((NamedNode)node).setValidated(true);
			}
		}
		return node;
	}
	
	private void addError(IFTranslationError error) {
		if (errors == null) {
			errors = new ArrayList<IFTranslationError>();
		}
		errors.add(error);
	}

	public List<IFTranslationError> getErrors() {
		return errors;
	}
	
	private GraphPatternElement createBinaryBuiltin(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (lobj != null) {
			builtin.addArgument(nodeCheck(lobj));
		}
		if (robj != null) {
			builtin.addArgument(nodeCheck(robj));
		}
		return builtin;
	}
	
	private Junction createJunction(Expression expr, String name, Object lobj, Object robj) {
		Junction junction = new Junction();
		junction.setJunctionName(name);
		junction.setLhs(lobj);
		junction.setRhs(robj);
		return junction;
	}

	private Object createUnaryBuiltin(Expression sexpr, String name, Object sobj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (sobj instanceof Literal && BuiltinType.getType(name).equals(BuiltinType.Minus)) {
			Object theVal = ((Literal)sobj).getValue();
			if (theVal instanceof Integer) {
				theVal = ((Integer)theVal) * -1;
			}
			else if (theVal instanceof Long) {
				theVal = ((Long)theVal) * -1;
			}
			else if (theVal instanceof Float) {
				theVal = ((Float)theVal) * -1;
			}
			else if (theVal instanceof Double) {
				theVal = ((Double)theVal) * -1;
			}
			((Literal)sobj).setValue(theVal);
			((Literal)sobj).setOriginalText("-" + ((Literal)sobj).getOriginalText());
			return sobj;
		}
		if (sobj instanceof Junction) {
			// If the junction has two literal values, apply the op to both of them.
			Junction junc = (Junction) sobj;
			Object lhs = junc.getLhs();
			Object rhs = junc.getRhs();
			if (lhs instanceof Literal && rhs instanceof Literal) {
				lhs = createUnaryBuiltin(sexpr, name, lhs);
				rhs = createUnaryBuiltin(sexpr, name, rhs);
				junc.setLhs(lhs);
				junc.setRhs(rhs);
			}
			return junc;
		}
		if (BuiltinType.getType(name).equals(BuiltinType.Equal)) {
			if (sobj instanceof BuiltinElement) {
				if (isComparisonBuiltin(((BuiltinElement)sobj).getFuncName())) {
					// this is a "is <comparison>"--translates to <comparsion> (ignore is)
					return sobj;
				}
			}
			else if (sobj instanceof Literal || sobj instanceof NamedNode) {
				// an "=" interval value of a value is just the value
				return sobj;
			}
		}
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (isModifiedTriple(builtin.getFuncType())) {
			if (sobj instanceof TripleElement) {
				((TripleElement)sobj).setType(getTripleModifierType(builtin.getFuncType()));
				return sobj;
			}
		}
		if (sobj != null) {
			builtin.addArgument(nodeCheck(sobj));
		}
		return builtin;
	}

	private TripleElement addGraphPatternElementAtEnd(GraphPatternElement head, Node subject, Node predicate, Node object, TripleSourceType sourceType) {
		TripleElement newTriple = new TripleElement();
		newTriple.setSubject(subject);
		newTriple.setPredicate(predicate);
		newTriple.setObject(object);
		newTriple.setSourceType(sourceType);
		return newTriple;
	}
	
	private GraphPatternElement addGraphPatternElementAtEnd(GraphPatternElement head, GraphPatternElement newTail) {
		if (head != null) {
			GraphPatternElement lastElement = getLastGraphPatternElement(head);
			lastElement.setNext(newTail);
		}
		else {
			head = newTail;
		}
		return head;
	}
	
	private GraphPatternElement getLastGraphPatternElement(GraphPatternElement pattern) {
		while (pattern.getNext() != null) {
			pattern = pattern.getNext();
		}
		return pattern;
	}
	
	private Node nodeCheck(Object nodeObj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (nodeObj == null) {
//			throw new InvalidTypeException("nodeCheck called with null argument; this should not happen.");
			return null;
		}
		if (nodeObj instanceof Node) {
			return (Node) nodeObj; 
		}
		else if (nodeObj instanceof TripleElement) {
			if (((TripleElement)nodeObj).getPredicate() == null 
					&& ((TripleElement)nodeObj).getObject() == null
					&& ((TripleElement)nodeObj).getSubject() != null) {
				return ((TripleElement)nodeObj).getSubject();
			}
		}
		return new ProxyNode(nodeObj);
	}

	/**
	 * Method to find all of the variables in a graph pattern that might be the implied select variables of a query
	 * @param pattern
	 * @return
	 */
	public Set<VariableNode> getSelectVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = getUnboundVariables(patterns);

		// If we don't find an unreferenced variable, see if the pattern defines
		// a typed b node and get its variable.
		if (vars.isEmpty()) {
			for (int i = 0; i < patterns.size(); i++) {
				GraphPatternElement pattern = patterns.get(i);
				Set<VariableNode> moreVars = getSelectVariables(pattern);
				if (moreVars != null && moreVars.size() > 0) {
					vars.addAll(moreVars);
				}
			}
		}
		return vars;
	}
	
	public Set<VariableNode> getSelectVariables(GraphPatternElement pattern) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();
		if (pattern instanceof TripleElement) {
			TripleElement triple = (TripleElement) pattern;
			if (triple.getSubject() instanceof VariableNode &&
					triple.getPredicate() instanceof RDFTypeNode) {
				VariableNode var = (VariableNode) triple.getSubject();
				vars.add(var);
			}
			else if (triple.getSubject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getSubject()));
			}
			else if (triple.getObject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getObject()));
			}
			else if (triple.getPredicate() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getPredicate()));
			}
		}
		else if (pattern instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)pattern).getArguments();
			if (args != null) {
				// right now we have no mechanism to know which variables are unbound so
				//	assume the last one is
				// TODO
				Node arg = args.get(args.size() - 1);
				if (arg instanceof VariableNode) {
					vars.add((VariableNode) arg);
				}
			}
		}
		else if (pattern instanceof Junction) {
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			if (lhs instanceof GraphPatternElement) {
				Set<VariableNode> lhsvars = getSelectVariables((GraphPatternElement) lhs);
				if (lhsvars != null) {
					vars.addAll(lhsvars);
				}
			}
			if (rhs instanceof GraphPatternElement) {
				Set<VariableNode> rhsvars = getSelectVariables((GraphPatternElement) rhs);
				if (rhsvars != null) {
					vars.addAll(rhsvars);
				}
			}
		}
		return vars;
	}

	private Set<VariableNode> getUnboundVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();

		// We need to find any unreferenced variables in the pattern.
		for (int i = 0; i < patterns.size(); i++) {
			GraphPatternElement gpe = patterns.get(i);
			if (gpe instanceof TripleElement) {
				// Check the object of each triple to see if it has a variable
				// node with zero references.
				TripleElement triple = (TripleElement) gpe;
				Node subjNode = triple.getSubject();
				if (subjNode instanceof VariableNode) {
					VariableNode var = (VariableNode) subjNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (subjNode instanceof NamedNode && ((NamedNode)subjNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)subjNode).getName()));
				}
				Node objNode = triple.getObject();
				if (objNode instanceof VariableNode) {
					VariableNode var = (VariableNode) objNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (objNode instanceof NamedNode && ((NamedNode)objNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)objNode).getName()));
				}
			}
			else if (gpe instanceof BuiltinElement) {
				// Check the arguments of each builtin to see if it has a 
				// variable node with zero references.
				BuiltinElement builtin = (BuiltinElement) gpe;
				for (Node argument : builtin.getArguments()) {
					if (argument instanceof VariableNode) {
						VariableNode var = (VariableNode) argument;
						if (var.getNumReferences() == 0) {
							vars.add(var);
						}
					}
				}
			}
		}

		return vars; 
	}

	/**
	 * This method flattens out GraphPatternElement linked lists into a regular List
	 * @param test
	 * @param object 
	 */
	public void postProcessTest(Test test, TestStatement object) {
		Object lhs = test.getLhs();
		if (lhs instanceof List<?> && ((List<?>)lhs).size() > 0) {
			if (((List<?>)lhs).get(0) instanceof GraphPatternElement) {
				flattenLinkedList((List<GraphPatternElement>)lhs);
			}
			if (lhs instanceof List<?>) {
				if (((List<?>)lhs).size() == 1) {
					lhs = ((List<?>)lhs).get(0);
					test.setLhs(lhs);
				}
				else if (((List<?>)lhs).size() == 2 && ((List<?>)lhs).get(1) instanceof BuiltinElement &&
						((BuiltinElement)((List<?>)lhs).get(1)).isCreatedFromInterval()) {
					test.setLhs(((List<?>)lhs).get(0));
					test.setCompName(((BuiltinElement)((List<?>)lhs).get(1)).getFuncType());
					test.setRhs(((BuiltinElement)((List<?>)lhs).get(1)).getArguments().get(1));
				}
			}
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			boolean done = false;
			if ((((GraphPatternElement)lhs).getNext() instanceof  BuiltinElement)) {
				// there is a builtin next
				BuiltinElement be = (BuiltinElement) ((GraphPatternElement)lhs).getNext();
				if (isComparisonBuiltin(be.getFuncName())) {
					((GraphPatternElement)lhs).setNext(null);
					if (be.getArguments().size() > 1) {
						if (be.getArguments().get(0) instanceof VariableNode) {
							test.setRhs(be.getArguments().get(1));
						}
						else {
							// this is of the form V is P of S so comparison must be reversed
							reverseBuiltinComparisonDirection(be);
							test.setRhs(be.getArguments().get(0));
						}
					}
					else {
						addError(new IFTranslationError("A BuiltinElement in a Test is a comparison (" + be.getFuncName() + ") but has less than two arguemnts (" + be.toString() + ")"));
					}
					test.setCompName(be.getFuncName());
					done = true;
				}
			}
			if (!done) {
				List<GraphPatternElement> newLhs = new ArrayList<GraphPatternElement>();
				newLhs.add((GraphPatternElement) lhs);
				test.setLhs(flattenLinkedList(newLhs));
			}
		}
		else if (lhs instanceof BuiltinElement && isModifiedTriple(((BuiltinElement)lhs).getFuncType())) {
			List<Node> args = ((BuiltinElement)lhs).getArguments();
			if (args != null && args.size() == 2) {
				test.setLhs(args.get(1));
				test.setRhs(args.get(0));
				test.setCompName(((BuiltinElement)lhs).getFuncName());
			}
		}
		if (test.getRhs() instanceof ProxyNode) {
			test.setRhs(((ProxyNode)test.getRhs()).getProxyFor());
		}
		Object rhs = test.getRhs();
		if (rhs instanceof List<?> && ((List<?>)rhs).size() > 0) {
			if (((List<?>)rhs).get(0) instanceof GraphPatternElement) {
				flattenLinkedList((List<GraphPatternElement>)rhs);
			}
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			boolean done = false;
			if ((((GraphPatternElement)rhs).getNext() instanceof BuiltinElement)) {
				BuiltinElement be = (BuiltinElement) ((GraphPatternElement)rhs).getNext();
				if (isComparisonBuiltin(be.getFuncName())) {
					((GraphPatternElement)rhs).setNext(null);
					test.setLhs(be.getArguments().get(1));
					test.setCompName(be.getFuncName());
					done = true;
				}
			}
			if (!done) {
				List<GraphPatternElement> newRhs = new ArrayList<GraphPatternElement>();
				newRhs.add((GraphPatternElement) rhs);
				test.setRhs(flattenLinkedList(newRhs));
			}
		}

		if (test.getLhs() instanceof ProxyNode) {
			test.setLhs(((ProxyNode)test.getLhs()).getProxyFor());
		}
		if (test.getCompType() != null && test.getCompType().equals(ComparisonType.Eq) 
				&& test.getLhs() != null && test.getRhs() != null 
				&& test.getLhs() instanceof NamedNode && test.getRhs() instanceof List<?>) {
			if (test.getRhsVariables() != null && test.getRhsVariables().size() == 1) {
				String rhsvar = test.getRhsVariables().get(0).getName();
				List<?> rhslist = (List<?>) test.getRhs();
				boolean allPass = true;
				for (int i = 0; i < rhslist.size(); i++) {
					Object anrhs = rhslist.get(i);
					if (!(anrhs instanceof TripleElement)) {
						allPass = false;
						break;
					}
					else {
						Node subj = ((TripleElement)anrhs).getSubject();
						if (!(subj instanceof VariableNode) || !(((VariableNode)subj).getName().equals(rhsvar))) {
							allPass = false;
							break;
						}
					}
				}
				if (allPass) {
					for (int i = 0; i < rhslist.size(); i++) {
						TripleElement triple = (TripleElement) rhslist.get(i);
						triple.setSubject((Node) test.getLhs());
					}
					test.setLhs(test.getRhs());
					test.setRhs(null);
					test.setRhsVariables(null);
					test.setCompName((String)null);
				}
			}
		}
		
		// this is a validity checking section
		TripleElement singleTriple = null;
		if (test.getLhs() instanceof TripleElement && test.getRhs() == null && ((TripleElement)test.getLhs()).getNext() == null) {
			singleTriple = (TripleElement) test.getLhs();
		}
		else if (test.getRhs() instanceof TripleElement && test.getLhs() == null && ((TripleElement)test.getRhs()).getNext() == null) {
			singleTriple = (TripleElement) test.getRhs();
		}
		if (singleTriple != null) {
			// a single triple test should not have any variables in it
			if (singleTriple.getSubject() instanceof VariableNode || 
					singleTriple.getPredicate() instanceof VariableNode ||
					singleTriple.getObject() instanceof VariableNode) {
				addError(new IFTranslationError("Test is a single triple to be matched; should not contain variables.", object));
			}
			else {
				try {
//					modelManager.validateStatement(singleTriple.getSubject(), singleTriple.getPredicate(), singleTriple.getObject());
				}
				catch (Throwable t) {
					// try to validate but don't do anything on Exception
				}
			}
		}
	}

	public static void reverseBuiltinComparisonDirection(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<=");
		}
	}

	public static void builtinComparisonComplement(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<=");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<");
		}
	}

	public static boolean isComparisonBuiltin(String builtinName) {
		ComparisonType[] types = ComparisonType.values();
		for (ComparisonType type : types) {
			if (type.matches(builtinName)) {
				return true;
			}
		}
		return false;
	}

	public Rule postProcessRule(Rule rule, EObject object) {
		clearCruleVariableTypedOutput();
		// convert givens linked list to array; expand conjunctions
		List<GraphPatternElement> givens = flattenRuleJunctions(rule.getGivens());
		if (givens != null) {
			Object results;
			try {
				results = expandProxyNodes(givens, false, true);
				if (results instanceof List<?>) {
					rule.setGivens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		else {
			retiredProxyNodes.clear();
		}
		
		// convert ifs linked list to array; expand conjunctions
		List<GraphPatternElement> ifs = flattenRuleJunctions(rule.getIfs());
		if (ifs != null) {
			Object results;
			try {
				results = expandProxyNodes(ifs, false, false);
				if (results instanceof List<?>) {
					rule.setIfs((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		// now process conclusions
		List<GraphPatternElement> thens = flattenRuleJunctions(rule.getThens());
		if (thens != null) {
			Object results;
			try {
				results = expandProxyNodes(thens, true, false);
				if (results instanceof List<?>) {
					for (int i = 0; i < ((List<?>)results).size(); i++) {
						GraphPatternElement tgpe = (GraphPatternElement) ((List<?>)results).get(i);
						results = moveEmbeddedGPEsToIfs(rule, (List<?>) results, tgpe);
					}
					rule.setThens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 		
		}
		removeDuplicateElements(rule);
		return rule;
	}

	private List<GraphPatternElement> decorateCRuleVariables(List<GraphPatternElement> gpes, boolean isRuleThen) {
		for (int i = 0; i < gpes.size(); i++) {
			Object premise = gpes.get(i);
			if (premise instanceof TripleElement) {
				try {
					TripleElement gpe = (TripleElement) premise;
					Node subj = gpe.getSubject();
					Node obj = gpe.getObject();
					if (subj instanceof VariableNode && ((VariableNode)subj).isCRulesVariable() && ((VariableNode)subj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) subj)) {
						TripleElement newTypeTriple = new TripleElement(subj, new RDFTypeNode(), ((VariableNode)subj).getType());
						gpes.add(i++, newTypeTriple);
						addCruleVariableToTypeOutput((VariableNode) subj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) subj);
						}
					}
					if (obj instanceof VariableNode && ((VariableNode)obj).isCRulesVariable() && ((VariableNode)obj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) obj)) {
						TripleElement newTypeTriple = new TripleElement(obj, new RDFTypeNode(), ((VariableNode)obj).getType());
						gpes.add(++i, newTypeTriple);
						addCruleVariableToTypeOutput((VariableNode) obj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) obj);
						}
					}
				} catch (TranslationException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		return gpes;
	}

	private List<GraphPatternElement> flattenRuleJunctions(List<GraphPatternElement> lst) {
		if (lst == null) return null;
		List<GraphPatternElement> results = new ArrayList<GraphPatternElement>();
		for (int i = 0; i < lst.size(); i++) {
			GraphPatternElement gpe = lst.get(i);
			if (gpe instanceof Junction) {
				if (((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					try {
						results.addAll(flattenRuleJunction((Junction) gpe));
					} catch (TranslationException e) {
						addError(new IFTranslationError(e.getMessage(), e));
					}
				}
				else {
					addError(new IFTranslationError("Disjunction not supported in rules at this time"));
				}
			}
//			else if (gpe instanceof BuiltinElement && 
//					((BuiltinElement)gpe).getFuncName() != null && ((BuiltinElement)gpe).getFuncName().equals("and")) {
//				List<Node> args = ((BuiltinElement)gpe).getArguments();
//				for (int j = 0; j <= args.size(); j++) {
//					Node nj = args.get(j);
//				}
//			}
			else {
				results.add(gpe);
			}
		}
		return results;
	}

	private List<GraphPatternElement> flattenRuleJunction(Junction jct) throws TranslationException {
		if (!jct.getJunctionType().equals(JunctionType.Conj)) {
			addError(new IFTranslationError("Disjunction not supported in rules at this time"));
		}
		List<GraphPatternElement>results = new ArrayList<GraphPatternElement>();
		Object lhs = jct.getLhs();
		if (lhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)lhs));
		}
		else if (lhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) lhs);
		}
		else {
			throw new TranslationException("Encountered non-GraphPatternElement during rule translation");
		}
		Object rhs = jct.getRhs();
		if (rhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)rhs));
		}
		else if (rhs instanceof GraphPatternElement) {
			results.add((GraphPatternElement)rhs);
		}
		return results;
	}

	/**
	 * Method to remove GPE's with isEmbedded true from thens to ifs
	 * 
	 * @param rule
	 * @param results
	 * @param tgpe
	 * @return
	 */
	private List<?> moveEmbeddedGPEsToIfs(Rule rule, List<?> results,
			GraphPatternElement tgpe) {
		if (tgpe.isEmbedded()) {
			results.remove(tgpe);
			rule.getIfs().add(tgpe);			
		}
		else {
			if (tgpe instanceof Junction) {
				int idx = results.indexOf(tgpe);
				GraphPatternElement newtgpe = moveEmbeddedFromJunction(rule, (Junction)tgpe);
				if (newtgpe == null) {
					results.remove(idx);
				}
				else if (newtgpe != tgpe) {
					((List<GraphPatternElement>)results).set(idx, newtgpe);
				}
			}
		}
		return results;
	}

	/**
	 * Method to move all embedded GPEs in a Junction to the rule ifs and return whatever should be put in 
	 * the Junction's place or null if nothing.
	 * 
	 * @param rule
	 * @param tgpe
	 * @return
	 */
	private GraphPatternElement moveEmbeddedFromJunction(Rule rule,
			Junction tgpe) {
		boolean lhsRemoved = false;
		boolean rhsRemoved = false;
		Object lhs = ((Junction)tgpe).getLhs();
		Object rhs = ((Junction)tgpe).getRhs();
		if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) lhs);
			lhsRemoved = true;
		}
		else if (lhs instanceof Junction) {
			lhs = moveEmbeddedFromJunction(rule, (Junction) lhs);
		}
		if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) rhs);
			rhsRemoved = true;
		}
		else if (rhs instanceof Junction) {
			rhs = moveEmbeddedFromJunction(rule, (Junction) rhs);
		}
		if (lhsRemoved && rhsRemoved) {
			return null;
		}
		if (lhsRemoved) {
			return (GraphPatternElement) rhs;
		}
		if (rhsRemoved) {
			return (GraphPatternElement) lhs;
		}
		tgpe.setLhs(lhs);
		tgpe.setRhs(rhs);
		return tgpe;
	}

	/**
	 * This Map keeps track of the ProxyNodes that have been retired by GraphPatternElements, allowing the retired
	 * ProxyNode and its associated variable to be reused when that GraphPatternElement is revisited in another ProxyNode.
	 */
	private Map<GraphPatternElement, ProxyNode> retiredProxyNodes = new HashMap<GraphPatternElement, ProxyNode>();
	
	/**
	 * Top-level method for expanding ProxyNodes
	 * 
	 * @param pattern
	 * @param clearPreviousRetired TODO
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object expandProxyNodes(Object pattern, boolean isRuleThen, boolean clearPreviousRetired) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (clearPreviousRetired) {
			retiredProxyNodes.clear();
		}
		List<GraphPatternElement> patterns = new ArrayList<GraphPatternElement>();
		if (pattern instanceof List<?>) {
			for (int i = 0; i < ((List<?>)pattern).size(); i++) {
				expandProxyNodes(patterns, ((List<?>)pattern).get(i), isRuleThen);
			}
		}
		else {
			Object result = expandProxyNodes(patterns, pattern, isRuleThen);
			if (patterns.size() == 0) {
				return result;
			}
		}
		if (patterns.size() > 0) {
			patterns = decorateCRuleVariables((List<GraphPatternElement>) patterns, isRuleThen);
			if (!(target instanceof Test) && patterns.size() > 1) {
				patterns = listToAnd(patterns);
			}
		}
		return patterns;
	}
	
	public List<GraphPatternElement> listToAnd(
			List<GraphPatternElement> patterns) {
		GraphPatternElement lhs = patterns.remove(0);
		if (lhs instanceof List<?>) {
			lhs = listToAnd((List<GraphPatternElement>) lhs).get(0);
		}
		Junction jand = new Junction();
		jand.setJunctionName("and");
		jand.setLhs(lhs);
		if (patterns.size() > 1) {
			patterns = listToAnd(patterns);
		}
		GraphPatternElement rhs = patterns.get(0);
		if (rhs instanceof List<?>) {
			rhs = listToAnd((List<GraphPatternElement>) rhs).get(0);
		}
		jand.setRhs(rhs);
		patterns.set(0, jand);
		return patterns;
	}

	/**
	 * Second-level method for expanding ProxyNodes--this one has a list of the results passed in as an argument
	 * @param patterns
	 * @param pattern
	 * @param isRuleThen 
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, Object pattern, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (pattern instanceof ProxyNode) {
			return expandProxyNodes(patterns, ((ProxyNode)pattern).getProxyFor(), isRuleThen);
		}
		if (pattern instanceof TripleElement) {
			return expandProxyNodes(patterns,(TripleElement)pattern, isRuleThen);
		}
		else if (pattern instanceof BuiltinElement) {
			return expandProxyNodes(patterns, (BuiltinElement)pattern, isRuleThen);
		}
		else if (pattern instanceof Literal) {
			return pattern;
		}
		else if (pattern instanceof Junction) {
			// remember what we have so far and create a new pattern list for each side of the Junction
			List<GraphPatternElement> existingPatterns = patterns;
			List<GraphPatternElement> lhsPatterns = new ArrayList<GraphPatternElement>();
			List<GraphPatternElement> rhsPatterns = new ArrayList<GraphPatternElement>();
			
			// get the two sides
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			
			// at least handle the interesting special case where they  are literals
			
			if (lhs instanceof Literal) {
				BuiltinElement lhsbe = new BuiltinElement();
				lhsbe.setFuncName("==");
				lhsbe.setCreatedFromInterval(true);
				lhsbe.addArgument(nodeCheck(lhs));
				((Junction)pattern).setLhs(lhsbe);
			}
			else {
				expandProxyNodes(lhsPatterns, lhs, isRuleThen);
				if (lhsPatterns.size() == 1) {
					((Junction)pattern).setLhs(lhsPatterns.get(0));
				}
				else if (lhsPatterns.size() < 1) {
					((Junction)pattern).setLhs(lhs);
				}
				else {
					((Junction)pattern).setLhs(listToAnd(lhsPatterns).get(0));
	//				throw new TranslationException("LHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			
			if (rhs instanceof Literal) {
				BuiltinElement rhsbe = new BuiltinElement();
				rhsbe.setFuncName("==");
				rhsbe.setCreatedFromInterval(true);
				rhsbe.addArgument(nodeCheck(rhs));
				((Junction)pattern).setRhs(rhsbe);
			}
			else {
				expandProxyNodes(rhsPatterns, rhs, isRuleThen);
				if (rhsPatterns.size() == 1) {
					((Junction)pattern).setRhs(rhsPatterns.get(0));
				}
				else if (rhsPatterns.size() < 1) {
					((Junction)pattern).setRhs(rhs);
				}
				else {
					((Junction)pattern).setRhs(listToAnd(rhsPatterns).get(0));
	//				throw new TranslationException("RHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			patterns = existingPatterns;
			patterns.add((Junction)pattern);
			return null;
		}
		return patterns;
	}
	
	/**
	 * If a triple has a null, fill it with a variable (search the patterns list first to avoid duplicates), 
	 *  add the triple to the patterns list, and return the variable. The variable also replaces the proxy node 
	 *  that contained this triple.
	 * @param patterns
	 * @param te
	 * @param expType
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, TripleElement te, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(te);
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		Node subj = te.getSubject();
		if (subj instanceof ProxyNode) {
			if (retiredNode != null) {
				subj = returnNode = retiredNode;
			}
			else if (((ProxyNode)subj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)subj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)subj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)subj).getProxyFor(), (ProxyNode) subj);
				}
				subj = returnNode = ((ProxyNode)subj).getReplacementNode();
			}
			else {
				Object realSubj = ((ProxyNode)subj).getProxyFor();
				Object subjNode = expandProxyNodes(patterns, realSubj, isRuleThen);
				if (subjNode == null && realSubj instanceof TripleElement && ((TripleElement)realSubj).getObject() instanceof VariableNode) {
					subjNode = ((TripleElement)realSubj).getObject();
				}
				((ProxyNode)subj).setReplacementNode(nodeCheck(subjNode));
				retiredProxyNodes.put((GraphPatternElement) realSubj, (ProxyNode)subj);
				subj = nodeCheck(subjNode);
				if (realSubj instanceof TripleElement && ((TripleElement)realSubj).getSourceType().equals(TripleSourceType.ITC)) {
					returnNode = subj;
				}
			}
			te.setSubject(subj);
			patterns.add(te);
		}
		else if (subj == null) {
			// this is a triple with a need for a variable for subject
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), te.getObject());
			te.setSubject(returnNode);
			// TODO when this is nested the triple (te) needs to be inserted before the returnNode is used
			patterns.add(te);
		}
		Node obj = te.getObject();
		if (obj instanceof ProxyNode) {
			int initialPatternLength = patterns == null ? 0 : patterns.size();
			if (retiredNode != null) {
				obj = returnNode = retiredNode;
			}
			else if (((ProxyNode)obj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)obj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)obj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)obj).getProxyFor(), (ProxyNode) obj);
				}
				obj = returnNode = ((ProxyNode)obj).getReplacementNode();
			}
			else {
				Object realObj = ((ProxyNode)obj).getProxyFor();
				List<GraphPatternElement> rememberedPatterns = null;
				if (realObj instanceof BuiltinElement && isRuleThen) {
					rememberedPatterns = patterns;
					patterns = new ArrayList<GraphPatternElement>();
				}
				Object objNode = expandProxyNodes(patterns, realObj, isRuleThen);
				if (objNode == null && ((ProxyNode)obj).getReplacementNode() != null) {
					// This can happen because the proxy node gets processed but not returned
					objNode = ((ProxyNode)obj).getReplacementNode();
				}
				if (objNode == null && (realObj instanceof BuiltinElement 
						|| (realObj instanceof Junction && ((Junction)realObj).getLhs() instanceof BuiltinElement 
								&& ((Junction)realObj).getRhs() instanceof BuiltinElement))) {
					List<BuiltinElement> builtins = new ArrayList<BuiltinElement>();
					Node newNode = null;
					if (realObj instanceof BuiltinElement) {
						builtins.add((BuiltinElement)realObj);
						newNode = getVariableNode((BuiltinElement)realObj);
					}
					else {
						builtins.add((BuiltinElement)((Junction)realObj).getLhs());
						newNode = getVariableNode(builtins.get(0));
						builtins.add((BuiltinElement)((Junction)realObj).getRhs());
					}
					for (int i = 0; i < builtins.size(); i++) {
						BuiltinElement bi = builtins.get(i);
						if (bi.isCreatedFromInterval()) {
							bi.addArgument(0, newNode);
						}
						else {
							bi.addArgument(newNode);
						}
					}
					objNode = newNode;
					if (isRuleThen) {
						addToIfts(patterns);
						patterns = rememberedPatterns;
					}
				}
				if (objNode == null) {
					addError(new IFTranslationError("Translation to Intermediate Form failed: " + te.toString()));
				}
				((ProxyNode)obj).setReplacementNode(nodeCheck(objNode));
// TODO this has a problem, run on 	TestSadlIde/Sandbox/UnionClassInRule.sadl			
				retiredProxyNodes.put((GraphPatternElement) ((ProxyNode)obj).getProxyFor(), (ProxyNode)obj);
				obj = nodeCheck(objNode);
			}
			te.setObject(obj);
			if (!patterns.contains(te)) {
				if (target instanceof Rule) {
					patterns.add(te);
				}
				else {
					patterns.add(Math.max(0, initialPatternLength - 1), te);
				}
			}
		}
		else if (obj == null) {
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), obj);
			te.setObject(returnNode);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
		}

		if (te.getNext() != null) {
			GraphPatternElement nextGpe = te.getNext();
			te.setNext(null);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			Object nextResult = expandProxyNodes(patterns, nextGpe, isRuleThen);
			// TODO we don't need to do anything with this, right?
		}
	
		// Special case: a pivot triple ( something type something): return the subject
		if (te instanceof TripleElement && (((TripleElement)te).getPredicate()) instanceof RDFTypeNode) {
			// this is an embedded type triple; only the subject can be a subject of the higher-level pattern
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			return ((TripleElement)te).getSubject();
		}

		// This is to make sure that complete, self-contained triple elements are still added to the output
		if (!patterns.contains(te)) {
			patterns.add(te);
		}
		if (retiredNode != null) {
			return retiredNode;
		}
		return returnNode;
	}
	
	/**
	 * This method is currently just a placeholder for finding variables for reuse in built-in patterns.
	 * Currently it just creates a new variable with a new name.
	 * @param bltin
	 * @return
	 */
	protected VariableNode getVariableNode(BuiltinElement bltin) {
		if (target != null) {
			
		}
		return new VariableNode(getNewVar());
	}
	
	/**
	 * This method looks in the clauses of a Rule to see if there is already a triple matching the given pattern. If there is
	 * a new variable of the same name is created (to make sure the count is right) and returned. If not a rule or no match
	 * a new variable (new name) is created and returned.
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode getVariableNode(Node subject, Node predicate, Node object) {
		if (target != null) {
			// Note: when we find a match we still create a new VariableNode with the same name in order to have the right reference counts for the new VariableNode
			if (target instanceof Rule) {
				VariableNode var = findVariableInTripleForReuse(((Rule)target).getGivens(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
				var = findVariableInTripleForReuse(((Rule)target).getIfs(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
				var = findVariableInTripleForReuse(((Rule)target).getThens(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
			}
		}
		return new VariableNode(getNewVar());
	}
	
	/**
	 * Supporting method for the method above (getVariableNode(Node, Node, Node))
	 * @param gpes
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode findVariableInTripleForReuse(List<GraphPatternElement> gpes, Node subject, Node predicate, Node object) {
		if (gpes != null) {
			Iterator<GraphPatternElement> itr = gpes.iterator();
			while (itr.hasNext()) {
				GraphPatternElement gpe = itr.next();
				while (gpe != null) {
					if (gpe instanceof TripleElement) {
						TripleElement tr = (TripleElement)gpe;
						Node tsn = tr.getSubject();
						Node tpn = tr.getPredicate();
						Node ton = tr.getObject();
						if (subject == null && tsn instanceof VariableNode) {
							if (predicate != null && predicate.equals(tpn) && object != null && object.equals(ton)) {
								return (VariableNode) tsn;
							}
						}
						if (predicate == null && tpn instanceof VariableNode) {
							if (subject != null && subject.equals(tsn) && object != null && object.equals(ton)) {
								return (VariableNode) tpn;
							}
						}
						if (object == null && ton instanceof VariableNode) {
							if (subject != null && subject.equals(tsn) && predicate != null && predicate.equals(tpn)) {
								return (VariableNode) ton;
							}
						}
					}
					gpe = gpe.getNext();
				}
			}
		}
		return null;
	}
	
	protected String getNewVar() {
		String proposedName = "v" + vNum;
		while (userDefinedVariables.contains(proposedName)
//				||
//				!modelManager.getConceptType(proposedName).equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)
		) {
			vNum++;
			proposedName = "v" + vNum;
		}
		vNum++;
		return proposedName;
	}
	
	private Node findMatchingElementInRetiredProxyNodes(GraphPatternElement ge) {
		if (retiredProxyNodes != null) {
			if (retiredProxyNodes.get(ge) != null) {
				return retiredProxyNodes.get(ge);
			}
			else {
				if (ge instanceof TripleElement && !(((TripleElement)ge).getPredicate() instanceof RDFTypeNode)) {
					TripleElement te = (TripleElement) ge;
					Iterator<GraphPatternElement> itr = retiredProxyNodes.keySet().iterator();
					while (itr.hasNext()) {
						GraphPatternElement gpe = itr.next();
						if (gpe instanceof TripleElement && !(((TripleElement)gpe).getPredicate() instanceof RDFTypeNode)) {
							if ((te.getSubject() == null || te.getSubject().equals(((TripleElement)gpe).getSubject()))
									&& (te.getPredicate() == null || te.getPredicate().equals(((TripleElement)gpe).getPredicate()))
									&& (te.getObject() == null || te.getObject().equals(((TripleElement)gpe).getObject()))) {
								ProxyNode pn = retiredProxyNodes.get(gpe);
								return pn.getReplacementNode();
							}
						}
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to handle BuiltinElements--if the 
	 * @param patterns
	 * @param be
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, BuiltinElement be, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(be);
		if (isRuleThen && target instanceof Rule && be.getFuncType().equals(BuiltinType.Equal)
				&& be.getArguments() != null && be.getArguments().size() == 2
				&& be.getArguments().get(0) instanceof ProxyNode && be.getArguments().get(1) instanceof ProxyNode) {
			ProxyNode arg1PN = (ProxyNode) be.getArguments().get(0);
			ProxyNode arg2PN = (ProxyNode) be.getArguments().get(1);
			Object realArgForThen = arg1PN.getProxyFor();
			Object realArgForIfs = arg2PN.getProxyFor();
			int tripleWithObjectNullCount = 0;
			if (realArgForThen instanceof TripleElement && realArgForIfs instanceof TripleElement) {
//				// args can be TripleElement only if both are and objects are both null
				if (((TripleElement)realArgForThen).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (((TripleElement)realArgForIfs).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (tripleWithObjectNullCount == 1) {
					addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + be.toString() + "); try separating rule elements with commas."));

				}
			}
			List<GraphPatternElement> moveToIfts = new ArrayList<GraphPatternElement>();
			Object finalIfsVar = expandProxyNodes(moveToIfts, realArgForIfs, false);
			if (finalIfsVar == null && realArgForIfs instanceof BuiltinElement) {
				Node newNode = getVariableNode((BuiltinElement)realArgForIfs);
				((BuiltinElement)realArgForIfs).addArgument(newNode);
				finalIfsVar = newNode;
				((ProxyNode)arg1PN).setReplacementNode(nodeCheck(finalIfsVar));
				retiredProxyNodes.put((GraphPatternElement) realArgForIfs, arg1PN);
			}
			addToIfts(moveToIfts);
			if (realArgForThen instanceof TripleElement && ((TripleElement)realArgForThen).getObject() == null) {
				((TripleElement)realArgForThen).setObject(nodeCheck(finalIfsVar));
				patterns.add((TripleElement)realArgForThen);
			}
			else {
				throw new TranslationException("Unhandled condition, LHS of Equal in Then isn't a TripleElement: " + realArgForThen.toString());
			}
			return null;
		}
		
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		List<Node> args = be.getArguments();
		for (int i = 0; args != null && i < args.size(); i++) {
			Node arg = args.get(i);
			if (arg instanceof ProxyNode) {
				if (retiredNode != null) {
					args.set(i, retiredNode);
				}
				else {
					Object realArg = ((ProxyNode)arg).getProxyFor();
					Object argNode = expandProxyNodes(patterns, realArg, isRuleThen);
					if (argNode == null) {
						if (realArg instanceof BuiltinElement) {
							if (be.getFuncType().equals(BuiltinType.Not)) {
								// don't put in an intermediate variable for negation of a builtin--if needed the language-specific translator will need to do that
								// the call above to expandProxyNodes might have put the argNode into the patterns; if so remove it
								if (patterns.get(patterns.size() - 1).equals(realArg)) {
									patterns.remove(patterns.size() - 1);
								}
							}
							else {
								Node newNode = getVariableNode((BuiltinElement)realArg);
								((BuiltinElement)realArg).addArgument(newNode);
								argNode = newNode;
								((ProxyNode)arg).setReplacementNode(nodeCheck(argNode));
								retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
								args.set(i, nodeCheck(argNode));
							}
						}
						else if (realArg instanceof TripleElement) {
							// don't do anything--keep proxy if triple, negate triple if "not" builtin
							if (patterns.get(patterns.size() - 1).equals(realArg)) {
								if (be.getFuncType().equals(BuiltinType.Not)) {
									((TripleElement)realArg).setType(TripleModifierType.Not);
									return realArg;	// "not" is a unary operator, so it is safe to assume this is the only argument
								}
								else if (be.getFuncName().equals("there exists") && ((TripleElement)realArg).getSubject() instanceof VariableNode){
									be.getArguments().set(0, ((TripleElement)realArg).getSubject());
									patterns.add(patterns.size() - 1, be);
									return null;
								}
							}
						}
						else {
							throw new TranslationException("Unexpected real argument");
						}
					}
					else {
						((ProxyNode)arg).setReplacementNode(nodeCheck(argNode));
						if (realArg instanceof GraphPatternElement) {
							retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
						}
						else {
							throw new TranslationException("Expected GraphPatternElement in ProxyNode but got " + realArg.getClass().getCanonicalName());
						}
						args.set(i, nodeCheck(argNode));
					}
				}
			}
		}
		patterns.add(be);
		return returnNode;
	}
	
	/**
	 * Combine the argument elements with the existing Rule Ifs elements
	 * @param moveToIfts
	 */
	private void addToIfts(List<GraphPatternElement> moveToIfts) {
		if (target instanceof Rule) {
			List<GraphPatternElement> ifts = ((Rule)target).getIfs();
			if (ifts == null) {
				((Rule)target).setIfs(moveToIfts);
			}
			else {
				ifts.addAll(moveToIfts);
			}
		}
	}

	/**
	 * This method flattens out the GraphPatternElement List so that there are no
	 * next pointers within the list.
	 * 
	 * @param list - input GraphPatternElement List that may have chained elements inside it
	 * @return - the transformed list
	 */
	private List<GraphPatternElement> flattenLinkedList(List<GraphPatternElement> list) {
		// go backwards through list so that the i index will remain valid
		for (int i = list.size() -1; i >= 0; i--) {
			GraphPatternElement element = list.get(i);
			if (element instanceof Junction) {
				flattenJunction((Junction)element);
			}
			GraphPatternElement nextElement = element.getNext();  // an internal chain
			int j = 0;
			while (nextElement != null) {
				element.setNext(null);
				list.add((1+i+(j++)),nextElement);
				element = nextElement;
				nextElement = element.getNext();
			}
		}
		return list;
	}
	
	private void flattenJunction(Junction element) {
		Object lhs = element.getLhs();
		if (lhs instanceof Junction) {
			flattenJunction((Junction)lhs);
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			element.setLhs(flattenJunctionSide((GraphPatternElement) lhs));
		}
		Object rhs = element.getRhs();
		if (rhs instanceof Junction) {
			flattenJunction((Junction)rhs);
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			element.setRhs(flattenJunctionSide((GraphPatternElement) rhs));
		}
	}
	
	private Object flattenJunctionSide(GraphPatternElement gpe) {
		if (gpe.getNext() != null) {
			List<GraphPatternElement> lst = new ArrayList<GraphPatternElement>();
			lst.add(gpe);
			lst = flattenLinkedList(lst);
			return lst;
		}
		return gpe;
	}
	
	private void removeDuplicateElements(Rule rule) {
		List<GraphPatternElement> givens = rule.getGivens();
		List<GraphPatternElement> ifs = rule.getIfs();
		List<GraphPatternElement> thens = rule.getThens();
		removeDuplicates(thens, thens, true);		// remove anything duplicated in thens
//		removeDuplicates(thens, ifs, false);			// remove anything in ifs from thens
//		removeDuplicates(thens, givens, false);		// remove anything in givens from thens
		removeDuplicates(ifs, ifs, true);			// remove anything duplicated in ifs
		removeDuplicates(ifs, givens, false);		// remove anything in givens from ifs
		removeDuplicates(givens, givens, true);		// remove anything duplicated in givens
	}
	
	/**
	 * If an element in list1 is also in list2, remove the element from list1
	 * 
	 * @param list1
	 * @param list2
	 * @param bRetainFirst -- true if same lists; if same lists leave first occurance
	 */
	private int removeDuplicates(List<GraphPatternElement> list1, List<GraphPatternElement> list2, boolean bRetainFirst) {
		if (list1 == null || list2 == null || list1.size() < 1 || list2.size() < 1) {
			return 0;
		}
		List<GraphPatternElement> flatList2 = getAllGPEs(list2);
		int removalCnt = 0;
		List<Integer> toBeRemoved = null;
		for (int idx2 = 0; idx2 < flatList2.size(); idx2++) {
			GraphPatternElement gpeToMatch = flatList2.get(idx2);	// this is the element we are considering for duplicate removals
			boolean foundFirst = false;
			for (int idx1 = 0; idx1 < list1.size(); idx1++) {
				GraphPatternElement gpe = list1.get(idx1);
				if (gpe.equals(gpeToMatch)) {
					if (!bRetainFirst || foundFirst) {
						if (toBeRemoved == null) {
							toBeRemoved = new ArrayList<Integer>();
						}
						if (!toBeRemoved.contains(idx1)) {
							toBeRemoved.add(idx1);
							removalCnt++;
						}
					}
					foundFirst = true;
				}
				else if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					Object[] results = removeJunctionDuplicates((Junction)gpe, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
					GraphPatternElement processedGpe = (GraphPatternElement) results[0];
					foundFirst = ((Boolean)results[1]).booleanValue();
					removalCnt = ((Integer)results[2]).intValue();
					if (!processedGpe.equals(gpe)) {
						list1.set(idx1, processedGpe);
					}
				}
			}
		}
		if (toBeRemoved != null) {
			Collections.sort(toBeRemoved);
			for (int i = (toBeRemoved.size() - 1); i >= 0; i--) {
				list1.remove(toBeRemoved.get(i).intValue());
			}
		}
		return removalCnt;
	}
	
	private Object[] removeJunctionDuplicates(Junction gpe, GraphPatternElement gpeToMatch, boolean bRetainFirst, boolean foundFirst, int removalCnt) {
		boolean lhsDuplicate = false;
		boolean rhsDuplicate = false;
		Object lhs = gpe.getLhs();
		if (lhs.equals(gpeToMatch)) {
			if(!bRetainFirst || foundFirst){
				lhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] lhsResults = removeJunctionDuplicates((Junction)lhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newLhs = (GraphPatternElement) lhsResults[0];
			foundFirst = ((Boolean)lhsResults[1]).booleanValue();
			removalCnt = ((Integer)lhsResults[2]).intValue();
			if (!newLhs.equals(lhs)) {
				gpe.setLhs(newLhs);
			}
		}
		Object rhs = gpe.getRhs();
		if (rhs != null && rhs.equals(gpeToMatch)) {
			if (!bRetainFirst || foundFirst) {
				rhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] rhsResults = removeJunctionDuplicates((Junction)rhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newrhs = (GraphPatternElement) rhsResults[0];
			foundFirst = ((Boolean)rhsResults[1]).booleanValue();
			removalCnt = ((Integer)rhsResults[2]).intValue();
			if (!newrhs.equals(rhs)) {
				gpe.setRhs(newrhs);
			}
		}
		Object[] results = new Object[3];
		if (lhsDuplicate) {
			results[0] = gpe.getRhs();
		}
		else if (rhsDuplicate) {
			results[0] = gpe.getLhs();
		}
		else {
			results[0] = gpe;
		}
		results[1] = new Boolean(foundFirst);
		results[2] = new Integer(removalCnt);
		return results;
	}

	private List<GraphPatternElement> getAllGPEs(List<GraphPatternElement> list) {
		List<GraphPatternElement> results = null;
		for (int i = 0; list != null && i < list.size(); i++) {
			GraphPatternElement gpe = list.get(i);
			if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
				if (results != null) {
					results.addAll(junctionToList((Junction) gpe));
				}
				else {
					results = junctionToList((Junction) gpe);
				}
			}
			else {
				if (results == null) {
					results = new ArrayList<GraphPatternElement>();
				}
				results.add(gpe);
			}
		}
		if (results != null) {
			return results;
		}
		return list;
	}
	
	private List<GraphPatternElement> junctionToList(Junction gpe) {
		List<GraphPatternElement> results = null;
		Object lhs = gpe.getLhs();
		if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			results = junctionToList((Junction)lhs);
		}
		else {
			results = new ArrayList<GraphPatternElement>();
			results.add((GraphPatternElement) lhs);
		}
		Object rhs = gpe.getRhs();
		if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			if (results != null) {
				results.addAll(junctionToList((Junction)rhs));
			}
			else {
				results = junctionToList((Junction)rhs);
			}
		}
		else if (rhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) rhs);
		}
		return results;
	}
	

	/**
	 * This method returns true only if all variables in the element are bound in other rule elements
	 * 
	 * @param rule
	 * @param gpe
	 * @return
	 */
	private boolean allElementVariablesBound(Rule rule,
			GraphPatternElement gpe) {
		if (gpe instanceof TripleElement) {
			Node subject = ((TripleElement)gpe).getSubject();
			if ((subject instanceof VariableNode || subject instanceof NamedNode)
					&& !variableIsBound(rule, gpe, subject)) {
				return false;
			}
			Node object = ((TripleElement)gpe).getObject();
			if ((object instanceof VariableNode || object instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, object)) {
				return false;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			for (int i = 0; args != null && i < args.size(); i++) {
				Node arg = args.get(i);
				if ((arg instanceof VariableNode || arg instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, arg)) {
						return false;
					}
			}
		}
		return true;
	}

	/**
	 * This method returns true if the argument node is bound in some other element of the rule
	 * 
	 * @param rule
	 * @param gpe
	 * @param v
	 * @return
	 */
	public static boolean variableIsBound(Rule rule, GraphPatternElement gpe,
			Node v) {
		if (v instanceof NamedNode) {
			if (((NamedNode)v).getNodeType() != null && !(((NamedNode)v).getNodeType().equals(NodeType.VariableNode))) {
				return true;
			}
		}
		// Variable is bound if it appears in a triple or as the return argument of a built-in
		List<GraphPatternElement> givens = rule.getGivens();
		if (variableIsBoundInOtherElement(givens, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (variableIsBoundInOtherElement(ifs, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (variableIsBoundInOtherElement(thens, 0, gpe, false, true, v)) {
			return true;
		}
		return false;
	}

	/**
	 * This method checks the list of GraphPatternElements to see if the specified variable is bound in these elements
	 * 
	 * @param gpes - list of GraphPatternElements to check
	 * @param startingIndex - where to start in the list
	 * @param gp - the element in which this variable appears 
	 * @param boundIfEqual - use the current element for test?
	 * @param matchMustBeAfter - must the binding be after the current element
	 * @param v - the variable Node being checked
	 * @return - true if the variable is bound else false
	 */
	public static boolean variableIsBoundInOtherElement(List<GraphPatternElement> gpes, int startingIndex, GraphPatternElement gp, 
			boolean boundIfEqual, boolean matchMustBeAfter, Node v) {
		boolean reachedSame = false;
		for (int i = startingIndex; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			while (gpe != null) {
				boolean same = gp == null ? false : gp.equals(gpe);
				if (same) {
					reachedSame = true;
				}
				boolean okToTest = false;
				if (matchMustBeAfter && reachedSame && !same) {
					okToTest = true;
				}
				if (!matchMustBeAfter && (!same || (same && boundIfEqual))) {
					okToTest = true;
				}
				if (okToTest && variableIsBound(gpe, v)) {
					return true;
				}
				gpe = gpe.getNext();
			}
		}
		return false;
	}
	
	private static boolean variableIsBound(GraphPatternElement gpe, Node v) {
		if (gpe instanceof TripleElement) {
			if ((((TripleElement)gpe).getSubject() != null &&((TripleElement)gpe).getSubject().equals(v)) || 
					(((TripleElement)gpe).getObject() != null && ((TripleElement)gpe).getObject().equals(v))) {
				return true;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			// TODO built-ins can actually have more than the last argument as output, but we can only tell this
			//	if we have special knowledge of the builtin. Current SADL grammar doesn't allow this to occur.
			if (args != null && args.get(args.size() - 1) != null && args.get(args.size() - 1).equals(v)) {
				return true;
			}
		}
		else if (gpe instanceof Junction) {
			Object lhsobj = ((Junction)gpe).getLhs();
			if (lhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)lhsobj, v)) {
				return true;
			}
			else if (lhsobj instanceof VariableNode && ((VariableNode)lhsobj).equals(v)) {
				return true;
			}
			Object rhsobj = ((Junction)gpe).getRhs();
			if (rhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)rhsobj, v)) {
				return true;
			}
			else if (rhsobj instanceof VariableNode && ((VariableNode)rhsobj).equals(v)) {
				return true;
			}
		}
		return false;
	}

	private boolean doVariableSubstitution(List<GraphPatternElement> gpes,
			VariableNode v1, VariableNode v2) {
		boolean retval = false;
		for (int i = 0; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
		}
		return retval;
	}

	private boolean doVariableSubstitution(GraphPatternElement gpe, VariableNode v1, VariableNode v2) {
		boolean retval = false;
		do {
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
			gpe = gpe.getNext();
		} while (gpe != null);
		return retval;
	}

	private void setFirstOfPhrase(GraphPatternElement firstOfPhrase) {
		this.firstOfPhrase = firstOfPhrase;
	}

	protected GraphPatternElement getFirstOfPhrase() {
		return firstOfPhrase;
	}

	public void setEncapsulatingTarget(Object _encapsulatingTarget) {
		encapsulatingTarget = _encapsulatingTarget;
	}

	public boolean isCollectNamedNodes() {
		return collectNamedNodes;
	}

	public void setCollectNamedNodes(boolean collectNamedNodes) {
		this.collectNamedNodes = collectNamedNodes;
	}

	/**
	 * This method can be called only once for a given set of translations; calling it clears the list of ConceptNames
	 * @return
	 */
	public List<ConceptName> getNamedNodes() {
		if (namedNodes != null) {
			List<ConceptName> x = new ArrayList<ConceptName>(namedNodes);
			namedNodes.clear();
			return x;
		}
		return null;
	}

	private void setNamedNodes(List<ConceptName> namedNodes) {
		this.namedNodes = namedNodes;
	}

	private boolean isCruleVariableInTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) return false;
		 return cruleVariablesTypeOutput.contains(cruleVariable);
	}

	private void addCruleVariableToTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) {
			cruleVariablesTypeOutput = new ArrayList<VariableNode>();
		}
		cruleVariablesTypeOutput.add(cruleVariable);
	}
	
	private void clearCruleVariableTypedOutput() {
		if (cruleVariablesTypeOutput != null) {
			cruleVariablesTypeOutput.clear();
		}
	}

	private int addNotEqualsBuiltinsForNewCruleVariable(List<GraphPatternElement> gpes, int currentIdx, VariableNode node) throws TranslationException {
		if (cruleVariablesTypeOutput == null) {
			throw new TranslationException("This should never happen! Please report.");
		}
		int crvSize = cruleVariablesTypeOutput.size();
		if (!cruleVariablesTypeOutput.get(crvSize - 1).equals(node)) {
			throw new TranslationException("This method should always be called immediately after creating a Crules variable.");
		}
		if (crvSize == 1) {
			return currentIdx;
		}
		for (int i = crvSize - 2; i >= 0; i--) {
			VariableNode otherVar = cruleVariablesTypeOutput.get(i);
			if (otherVar.getType().equals(node.getType())) {
				if (!notEqualAlreadyPresent(gpes, otherVar, node)) {
					BuiltinElement newBi = new BuiltinElement();
					newBi.setFuncName("!=");
					newBi.setFuncType(BuiltinType.NotEqual);
					newBi.addArgument(otherVar);
					newBi.addArgument(node);
					gpes.add(++currentIdx, newBi);
				}
			}
		}
		return currentIdx;
	}

	private boolean notEqualAlreadyPresent(List<GraphPatternElement> gpes, VariableNode var1,
			VariableNode var2) {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getFuncType().equals(BuiltinType.NotEqual)) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				int found = 0;
				for (int j =0; args != null && j < args.size(); j++) {
					if (args.get(j).equals(var1)) {
						found++;
					}
					if (args.get(j).equals(var2)) {
						found++;
					}
				}
				if (found == 2) {
					return true;
				}
			}
		}
		return false;
	}
}
