 /************************************************************************
 * Copyright Â© 2007-2017 - General Electric Company, All Rights Reserved
 *
 * Project: SADL
 *
 * Description: The Semantic Application Design Language (SADL) is a
 * language for building semantic models and expressing rules that
 * capture additional domain knowledge. The SADL-IDE (integrated
 * development environment) is a set of Eclipse plug-ins that
 * support the editing and testing of semantic models using the
 * SADL language.
 *
 * This software is distributed "AS-IS" without ANY WARRANTIES
 * and licensed under the Eclipse Public License - v 1.0
 * which is available at http://www.eclipse.org/org/documents/epl-v10.php
 *
 ***********************************************************************/

 package com.ge.research.sadl.jena;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.CompositeNodeWithSemanticElement;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ge.research.sadl.jena.JenaBasedSadlModelValidator.TypeCheckInfo;
import com.ge.research.sadl.jena.missingpatterns.DirectedPath;
import com.ge.research.sadl.jena.missingpatterns.MultiplePathsFoundException;
import com.ge.research.sadl.jena.missingpatterns.PathFinder;
import com.ge.research.sadl.jena.missingpatterns.PathFindingException;
import com.ge.research.sadl.model.ConceptName;
import com.ge.research.sadl.model.ConceptName.ConceptType;
import com.ge.research.sadl.model.gp.BuiltinElement;
import com.ge.research.sadl.model.gp.BuiltinElement.BuiltinType;
import com.ge.research.sadl.model.gp.ConstantNode;
import com.ge.research.sadl.model.gp.GraphPatternElement;
import com.ge.research.sadl.model.gp.Junction;
import com.ge.research.sadl.model.gp.Junction.JunctionType;
import com.ge.research.sadl.model.gp.Literal.LiteralType;
import com.ge.research.sadl.model.gp.JunctionList;
import com.ge.research.sadl.model.gp.JunctionNode;
import com.ge.research.sadl.model.gp.Literal;
import com.ge.research.sadl.model.gp.NamedNode;
import com.ge.research.sadl.model.gp.NamedNode.NodeType;
import com.ge.research.sadl.model.gp.Node;
import com.ge.research.sadl.model.gp.ProxyNode;
import com.ge.research.sadl.model.gp.Query;
import com.ge.research.sadl.model.gp.RDFTypeNode;
import com.ge.research.sadl.model.gp.Rule;
import com.ge.research.sadl.model.gp.Test;
import com.ge.research.sadl.model.gp.Test.ComparisonType;
import com.ge.research.sadl.model.gp.TripleElement;
import com.ge.research.sadl.model.gp.TripleElement.TripleModifierType;
import com.ge.research.sadl.model.gp.TripleElement.TripleSourceType;
import com.ge.research.sadl.model.gp.VariableNode;
import com.ge.research.sadl.processing.SadlConstants;
import com.ge.research.sadl.processing.SadlModelProcessor;
import com.ge.research.sadl.reasoner.CircularDependencyException;
import com.ge.research.sadl.reasoner.InvalidNameException;
import com.ge.research.sadl.reasoner.InvalidTypeException;
import com.ge.research.sadl.reasoner.ModelError.ErrorType;
import com.ge.research.sadl.reasoner.TranslationException;
import com.ge.research.sadl.reasoner.utils.SadlUtils;
import com.ge.research.sadl.sADL.Expression;
import com.ge.research.sadl.sADL.TestStatement;
import org.apache.jena.ontology.DatatypeProperty;
import org.apache.jena.ontology.Individual;
import org.apache.jena.ontology.ObjectProperty;
import org.apache.jena.ontology.OntClass;
import org.apache.jena.ontology.OntModel;
import org.apache.jena.ontology.OntProperty;
import org.apache.jena.ontology.OntResource;
import org.apache.jena.ontology.UnionClass;
import org.apache.jena.rdf.model.Property;
import org.apache.jena.rdf.model.RDFNode;
import org.apache.jena.rdf.model.Resource;
import org.apache.jena.rdf.model.StmtIterator;
import org.apache.jena.util.iterator.ExtendedIterator;
import org.apache.jena.vocabulary.RDF;
import org.apache.jena.vocabulary.RDFS;

/**
 * This class translates the output generated by parsing SADL queries, 
 * rules, and tests into what is called the SADL Intermediate Form (IF).  
 * The parser output is in the form of parse trees whose nodes are 
 * instances of the class Expression or of one of its subclasses.
 * The IF uses the Java classes in the Graph Patterns package 
 * (com.ge.research.sadl.model.gp). In the IF, each query or 
 * rule part (given, if, or then) or test phrase consists of 
 * a list of graph pattern elements.  The graph pattern element 
 * can be a triple pattern or it can be a built-in.  This 
 * Intermediate Form is passed to the reasoner-specific translator 
 * to generate rules and queries in an optimized form and format 
 * for the target reasoner.
 * 
 * One of the primary contributions of SADL to the modeling process is
 * its English-like syntax. The translation accomplished by this class
 * goes from this English-like syntax to the IF. Among other things, this
 * involves the generation of "missing" variables to provide the 
 * connectives between the individual graph pattern elements in a list.
 * 
 * The translation process "walks" the Expression parse tree. At the 
 * leaves of this parse tree are ExplicitValues, IntervalValues, 
 * ValueTables, or built-ins. At each node higher in the parse tree, 
 * if returning to the node represents the completion of a graph pattern 
 * element then that element is placed in the list at the appropriate 
 * location and if necessary a variable (Node) is identified to connect 
 * this new graph pattern element to other graph pattern elements 
 * in the list.
 * 
 * 10/2011:
 * The approach of adding variables as the translation proceeds, bottom-up,
 * has issues as looking bottom up one can't always tell the context and
 * therefore make the right decision. Therefore the strategy is changed to 
 * use a ProxyNode to encapsulate the lower-level constructs to replicate
 * the parse tree but in the IF structures. Then the expansion of ProxyNodes
 * can occur with a knowledge of context for proper decisioning. For example,
 * no information is available to know whether a rule built-in has zero, one,
 * or more output variables. However, usage will show that either the built-in
 * is used within a higher-level built-in or triple, in which case it must 
 * generate an output other than boolean so in expand ProxyNodes it will be
 * property handled by adding a generated variable if a specified variable
 * was not given, which variable is also placed in
 * the higher-level construct. In the future built-ins might be allowed to 
 * return multiple values but that would require a construct such as
 * 
 * 	x,y,z is someBuiltin(input1, input2, ..)
 * 
 * This extension of the grammar would provide the necessary information 
 * about the number of output variables to add, but only with the contextual
 * knowledge of the whole statement.
 * 
 * 
 * @author crapo
 *
 */
public class IntermediateFormTranslator implements I_IntermediateFormTranslator {
    protected static final Logger logger = LoggerFactory.getLogger(IntermediateFormTranslator.class);

    protected Map<Resource, NamedNode> resourceToNamedNodeMap = new HashMap<Resource, NamedNode>();
    private int vNum = 0;	// used to create unique variables
    private List<IFTranslationError> errors = null;
    private Object target = null;	// the instance of Rule, Query, or Test into which we are trying to put the translation
	private Map<Resource, List<TripleElement>> missingTriplesByResource;
	private List<NamedNode> namedNodesToCleanOfMissingPatternsWhenCooked = null;
	private Map<String, Boolean> addMissingTriplePatternsReturnValueByReqName;
    private GraphPatternElement firstOfPhrase = null;
    
    private boolean collectNamedNodes = false;
    private List<String> userDefinedVariables = new ArrayList<String>();
    private OntModel theJenaModel = null;
    private JenaBasedSadlModelProcessor modelProcessor = null;
    
	private List<VariableNode> cruleVariablesTypeOutput = null;		// list of crule variables that have had type statements output (only do so once)
	
	public enum UnNestingType {ReturnObjectMoveBefore, ReturnObjectMoveAfter, ReturnSubjectMoveAfter, None}
	// This enum identifies strategy for the unnesting of a nested TripleElement:
	// 1. ReturnObjectMoveBefore
	//   a. There is a nested triple as an argument to a containing BuiltinElement; the nested 
	//		triple will be moved *before* the container and replaced in the container by the
	//      *object* of the triple
	//   b. There is a nested triple as the subject of a containing TripleElement; the nested
	//      triple will be moved *before* the container and replaced in the container by the 
	//      *object* of the triple
	// 2. ReturnObjectMoveAfter
	//   a. This is a variable definition so we want the object returned but the definition should
	//  	come after the identification of the definition
	// 3. ReturnSubjectMoveAfter
	//   a. There is a nested triple as the object of a containing TripleElement; the nested
	//      triple will be moved *after* the container and replaced in the container by the 
	//      *subject* of the triple

	public enum BuiltinUnittedQuantityStatus {SameUnitsRequired, DifferentUnitsAllowedOrLeftOnly, LeftUnitsOnly, UnitsNotSupported, StatusUnknown}
	// This enum identifies the categories of BuiltinElements WRT UnittedQuantity arguments.

	class BuiltinElementAndUnits {
		BuiltinElement builtin;
		Node[] argUnits;
		
		public BuiltinElementAndUnits(BuiltinElement be, Node[] units) {
			builtin = be;
			argUnits = units;
		}
		
		BuiltinElement getBuiltinElement() {
			return builtin;
		}
		
		Node[] getArgUnits() {
			return argUnits;
		}
	}
	
	private List<BuiltinElementAndUnits> modifiedBuiltinElementsAndUnits;
	
	/**
     * The constructor takes a ModelManager argument
     * @param ontModel 
     * @param modmgr
     */
    public IntermediateFormTranslator(OntModel ontModel) {
    	setTheJenaModel(ontModel);
    }
    
	/**
     * The constructor takes a ModelManager argument
     * @param ontModel 
     * @param modmgr
     */
    public IntermediateFormTranslator(JenaBasedSadlModelProcessor processor, OntModel ontModel) {
    	setModelProcessor(processor);
    	setTheJenaModel(ontModel);
    }
    
    // the target can be a Test, a Query, or a Rule instance
    /* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setTarget(java.lang.Object)
	 */
    @Override
	public void setTarget(Object _target) {
    	target = _target;
    }
    
	@Override
	public Object getTarget() {
		return target;
	}
	
	/**
	 * Reset the translator for a new translation task
	 */
	protected void resetIFTranslator() {
		vNum = 0;
		if (errors != null) {
			errors.clear();
		}
		setTarget(null);
		setFirstOfPhrase(null);
	}
	
	/**
	 * Returns the bottom triple whose subject was replaced.
	 * @param pattern
	 * @param proxyFor
	 * @param assignedNode
	 * @return
	 */
	private TripleElement assignNullSubjectInProxies(TripleElement pattern,
			TripleElement proxyFor, Node assignedNode) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
//				((ProxyNode)pattern.getSubject()).setReplacementNode(assignedNode);
				if (((TripleElement)proxy).getSubject() == null) {
					// this is the bottom of the recursion
					((TripleElement)proxy).setSubject(assignedNode);
					return (TripleElement) proxy;
				}
				else {
					// recurse down
					TripleElement bottom = assignNullSubjectInProxies(((TripleElement)proxy), proxyFor, assignedNode);
					// make the proxy next and reassign this subject as assignedNode
					((ProxyNode)((TripleElement)proxy).getSubject()).setReplacementNode(assignedNode);
					((TripleElement)proxy).setSubject(assignedNode);
					if (bottom.getNext() == null) {
						bottom.setNext(pattern);
					}
					return bottom;
				}
			}
		}
		return null;
	}

	/**
	 * Method to determine if a BuiltinElement should generate a DirectedPath
	 * @param bi
	 * @return
	 */
	public boolean isPathGeneratingBuiltinElement(BuiltinElement bi) {
		if (bi.getFuncName().equals("lastElement") ||
				bi.getFuncName().equals("firstElement") ||
				bi.getFuncName().equals("elementBefore") ||
				bi.getFuncName().equals("elementAfter") ||
				bi.getFuncName().equals("elementInList")) {
			return true;
		}
		return false;
	}

	private TripleElement getProxyWithNullSubject(TripleElement pattern) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
				if (((TripleElement)proxy).getSubject() == null) {
					return (TripleElement)proxy;
				}
				else {
					return getProxyWithNullSubject(((TripleElement)proxy));
				}
			}
		}
		return null;
	}

	private boolean isComparisonViaBuiltin(Object robj, Object lobj) {
		if (robj instanceof TripleElement && lobj instanceof Node &&
				((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (isComparisonBuiltin(be.getFuncName()) && be.getArguments().size() == 1) {
				return true;
			}
		}
		return false;
	}

	private boolean isModifiedTripleViaBuitin(Object robj) {
		if (robj instanceof TripleElement && ((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (((TripleElement)robj).getPredicate() instanceof RDFTypeNode) {
				if (isModifiedTriple(be.getFuncType())) {
					Node subj = ((TripleElement)robj).getSubject();
					Node arg = (be.getArguments() != null && be.getArguments().size() > 0) ? be.getArguments().get(0) : null;
					if (subj == null && arg == null) {
						return true;
					}
					if (subj != null && arg != null && subj.equals(arg)) {
						return true;
					}
				}
			}
			else {
				if (isModifiedTriple(be.getFuncType()) && ((TripleElement)robj).getObject().equals(be.getArguments().get(0))) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasCommonVariableSubject(Object robj) {
		if (robj instanceof TripleElement && 
				(((TripleElement)robj).getSubject() instanceof VariableNode && 
						((TripleElement)robj).getSourceType() != null &&
						(((TripleElement)robj).getSourceType().equals(TripleSourceType.SPV)) ||
						((TripleElement)robj).getSourceType().equals(TripleSourceType.ITC))) {
			VariableNode subjvar = (VariableNode) ((TripleElement)robj).getSubject();
			Object trel = robj;
			while (trel != null && trel instanceof TripleElement) {
				if (!(trel instanceof TripleElement) || 
						(((TripleElement)trel).getSubject() != null &&!(((TripleElement)trel).getSubject().equals(subjvar)))) {
					return false;
				}
				trel = ((TripleElement)trel).getNext();
			}
			if (trel == null) {
				return true;
			}
		}
		return false;
	}

	public static boolean isModifiedTriple(BuiltinType type) {
		if (type.equals(BuiltinType.Not) || type.equals(BuiltinType.NotEqual) || type.equals(BuiltinType.Only)||  type.equals(BuiltinType.NotOnly)) {
			return true;
		}
		return false;
	}
	
	public String getSourceGrammarText(EObject po) {
		Object r = po.eResource();
		if (r instanceof XtextResource) {
			INode root = ((XtextResource) r).getParseResult().getRootNode();
	        for(INode node : root.getAsTreeIterable()) {   
	        	if (node instanceof CompositeNodeWithSemanticElement) {
	        		EObject semElt = ((CompositeNodeWithSemanticElement)node).getSemanticElement();
	        		if (semElt.equals(po)) {
	        			// this is the one!
	        			String txt = NodeModelUtils.getTokenText(node);
	   					return txt.trim();
	        		}
	        	}
	        }
			org.eclipse.emf.common.util.TreeIterator<EObject> titr = po.eAllContents();
			while (titr.hasNext()) {
				EObject el = titr.next();
// TODO what's supposed to happen here?
				int i = 0;
			}
		}
		return null;
	}

//	/**
//	 * This method fills in missing information in a NamedNode: 
//	 * the prefix, the namespace, the type
//	 * 
//	 * @param namedNode
//	 * @return
//	 * @throws InvalidNameException 
//	 */
//	protected Node validateNode(Node node) throws InvalidNameException {
//		if (node instanceof NamedNode) {
//			if (!((NamedNode)node).isValidated()) {
//				if (node instanceof VariableNode) {
//					((VariableNode) node).setNodeType(NodeType.VariableNode);
//					userDefinedVariables.add(((NamedNode) node).getName());
//				}
//				else if (node instanceof RDFTypeNode) {
//					((RDFTypeNode) node).setNodeType(NodeType.PropertyNode);
//				}
//				else {
//					ConceptName cname = null;
//					ConceptType ctype = null;
//					String name = ((NamedNode)node).toString(); //getName();
//					if (name == null) {
//						throw new InvalidNameException("A NamedNode has a null name! Did ResourceByName resolution fail?");
//					}
//				    int colon = name.indexOf(':');
//					if (colon > 0 && colon < name.length() - 1) {
//						String pfx = name.substring(0, colon);
//				        ((NamedNode)node).setPrefix(pfx);
//				        String lname = name.substring(colon + 1);
//				        ((NamedNode)node).setName(lname);
////				        cname = modelManager.validateConceptName(new ConceptName(pfx, lname));
//				    }
//				    else {
////				    	cname = modelManager.validateConceptName(new ConceptName(name));
//				    }
//			        ctype = cname.getType();
//			        ((NamedNode)node).setNamespace(cname.getNamespace());
//			        ((NamedNode)node).setPrefix(cname.getPrefix());
//			    	if (ctype.equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)) {
////			    		modelManager.addToVariableNamesCache(cname);
//			    		node = new VariableNode(((NamedNode)node).getName());
//			    		userDefinedVariables.add(((NamedNode) node).getName());
//			    	}
//			    	else if (ctype.equals(ConceptType.ANNOTATIONPROPERTY)){
//			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
//			    	}
//			    	else if (ctype.equals(ConceptType.DATATYPEPROPERTY)){
//			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
//			    	}
//			    	else if (ctype.equals(ConceptType.OBJECTPROPERTY)){
//			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
//			    	}
//			    	else if (ctype.equals(ConceptType.ONTCLASS)){
//			    		((NamedNode)node).setNodeType(NodeType.ClassNode);
//			    	}
//			    	else if (ctype.equals(ConceptType.INDIVIDUAL)){
//			    		((NamedNode)node).setNodeType(NodeType.InstanceNode);
//			    	}
//			    	else {
//			    		logger.error("Unexpected ConceptType: " + ctype.toString());
//				    	addError(new IFTranslationError("Unexpected ConceptType: " + ctype.toString()));
//			    	}
//			    	if (isCollectNamedNodes()) {
//			    		if (namedNodes == null) {
//			    			namedNodes = new ArrayList<ConceptName>();
//			    		}
//			    		if (!namedNodes.contains(cname)) {
//			    			namedNodes.add(cname);
//			    		}
//			    	}
//				}
//				((NamedNode)node).setValidated(true);
//			}
//		}
//		return node;
//	}
	
	private void addError(IFTranslationError error) {
		if (errors == null) {
			errors = new ArrayList<IFTranslationError>();
		}
		errors.add(error);
	}

	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#getErrors()
	 */
	@Override
	public List<IFTranslationError> getErrors() {
		return errors;
	}
	
	private GraphPatternElement createBinaryBuiltin(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (lobj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(lobj));
		}
		if (robj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(robj));
		}
		return builtin;
	}
	
	private Junction createJunction(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		Junction junction = new Junction();
		junction.setJunctionName(name);
		junction.setLhs(SadlModelProcessor.nodeCheck(lobj));
		junction.setRhs(SadlModelProcessor.nodeCheck(robj));
		return junction;
	}

	private Object createUnaryBuiltin(Expression sexpr, String name, Object sobj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (sobj instanceof Literal && BuiltinType.getType(name).equals(BuiltinType.Minus)) {
			Object theVal = ((Literal)sobj).getValue();
			if (theVal instanceof Integer) {
				theVal = ((Integer)theVal) * -1;
			}
			else if (theVal instanceof Long) {
				theVal = ((Long)theVal) * -1;
			}
			else if (theVal instanceof Float) {
				theVal = ((Float)theVal) * -1;
			}
			else if (theVal instanceof Double) {
				theVal = ((Double)theVal) * -1;
			}
			((Literal)sobj).setValue(theVal);
			((Literal)sobj).setOriginalText("-" + ((Literal)sobj).getOriginalText());
			return sobj;
		}
		if (sobj instanceof Junction) {
			// If the junction has two literal values, apply the op to both of them.
			Junction junc = (Junction) sobj;
			Object lhs = junc.getLhs();
			Object rhs = junc.getRhs();
			if (lhs instanceof Literal && rhs instanceof Literal) {
				lhs = createUnaryBuiltin(sexpr, name, lhs);
				rhs = createUnaryBuiltin(sexpr, name, rhs);
				junc.setLhs(SadlModelProcessor.nodeCheck(lhs));
				junc.setRhs(SadlModelProcessor.nodeCheck(rhs));
			}
			return junc;
		}
		if (BuiltinType.getType(name).equals(BuiltinType.Equal)) {
			if (sobj instanceof BuiltinElement) {
				if (isComparisonBuiltin(((BuiltinElement)sobj).getFuncName())) {
					// this is a "is <comparison>"--translates to <comparsion> (ignore is)
					return sobj;
				}
			}
			else if (sobj instanceof Literal || sobj instanceof NamedNode) {
				// an "=" interval value of a value is just the value
				return sobj;
			}
		}
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (isModifiedTriple(builtin.getFuncType())) {
			if (sobj instanceof TripleElement) {
				((TripleElement)sobj).setType(getModelProcessor().getTripleModifierType(builtin.getFuncType()));
				return sobj;
			}
		}
		if (sobj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(sobj));
		}
		return builtin;
	}

	private TripleElement addGraphPatternElementAtEnd(GraphPatternElement head, Node subject, Node predicate, Node object, TripleSourceType sourceType) {
		TripleElement newTriple = new TripleElement();
		newTriple.setSubject(subject);
		newTriple.setPredicate(predicate);
		newTriple.setObject(object);
		newTriple.setSourceType(sourceType);
		return newTriple;
	}
	
	private GraphPatternElement addGraphPatternElementAtEnd(GraphPatternElement head, GraphPatternElement newTail) {
		if (head != null) {
			GraphPatternElement lastElement = getLastGraphPatternElement(head);
			lastElement.setNext(newTail);
		}
		else {
			head = newTail;
		}
		return head;
	}
	
	private GraphPatternElement getLastGraphPatternElement(GraphPatternElement pattern) {
		while (pattern.getNext() != null) {
			pattern = pattern.getNext();
		}
		return pattern;
	}
	
	/**
	 * Method to find all of the variables in a graph pattern that might be the implied select variables of a query
	 * @param pattern
	 * @return
	 */
	public Set<VariableNode> getSelectVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = getUnboundVariables(patterns);

		// If we don't find an unreferenced variable, see if the pattern defines
		// a typed b node and get its variable.
		if (vars.isEmpty()) {
			for (int i = 0; i < patterns.size(); i++) {
				GraphPatternElement pattern = patterns.get(i);
				Set<VariableNode> moreVars = getSelectVariables(pattern);
				if (moreVars != null && moreVars.size() > 0) {
					vars.addAll(moreVars);
				}
			}
		}
		return vars;
	}
	
	public Set<VariableNode> getSelectVariables(GraphPatternElement pattern) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();
		if (pattern instanceof TripleElement) {
			TripleElement triple = (TripleElement) pattern;
			if (triple.getSubject() instanceof VariableNode &&
					triple.getPredicate() instanceof RDFTypeNode) {
				VariableNode var = (VariableNode) triple.getSubject();
				vars.add(var);
			}
			else if (triple.getSubject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getSubject()));
			}
			else if (triple.getObject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getObject()));
			}
			else if (triple.getPredicate() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getPredicate()));
			}
		}
		else if (pattern instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)pattern).getArguments();
			if (args != null) {
				// right now we have no mechanism to know which variables are unbound so
				//	assume the last one is
				// TODO
				Node arg = args.get(args.size() - 1);
				if (arg instanceof VariableNode) {
					vars.add((VariableNode) arg);
				}
			}
		}
		else if (pattern instanceof Junction) {
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			if (lhs instanceof GraphPatternElement) {
				Set<VariableNode> lhsvars = getSelectVariables((GraphPatternElement) lhs);
				if (lhsvars != null) {
					vars.addAll(lhsvars);
				}
			}
			if (rhs instanceof GraphPatternElement) {
				Set<VariableNode> rhsvars = getSelectVariables((GraphPatternElement) rhs);
				if (rhsvars != null) {
					vars.addAll(rhsvars);
				}
			}
		}
		return vars;
	}

	private Set<VariableNode> getUnboundVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();

		// We need to find any unreferenced variables in the pattern.
		for (int i = 0; i < patterns.size(); i++) {
			GraphPatternElement gpe = patterns.get(i);
			if (gpe instanceof TripleElement) {
				// Check the object of each triple to see if it has a variable
				// node with zero references.
				TripleElement triple = (TripleElement) gpe;
				Node subjNode = triple.getSubject();
				if (subjNode instanceof VariableNode) {
					VariableNode var = (VariableNode) subjNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (subjNode instanceof NamedNode && ((NamedNode)subjNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)subjNode).getName()));
				}
				Node objNode = triple.getObject();
				if (objNode instanceof VariableNode) {
					VariableNode var = (VariableNode) objNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (objNode instanceof NamedNode && ((NamedNode)objNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)objNode).getName()));
				}
			}
			else if (gpe instanceof BuiltinElement) {
				// Check the arguments of each builtin to see if it has a 
				// variable node with zero references.
				BuiltinElement builtin = (BuiltinElement) gpe;
				for (Node argument : builtin.getArguments()) {
					if (argument instanceof VariableNode) {
						VariableNode var = (VariableNode) argument;
						if (var.getNumReferences() == 0) {
							vars.add(var);
						}
					}
				}
			}
			else if (gpe instanceof Junction) {
				try {
					JunctionList jctlst = junctionToList((Junction) gpe);
					return getUnboundVariables(jctlst);
				} catch (TranslationException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}

		return vars; 
	}

	/**
	 * This method flattens out GraphPatternElement linked lists into a regular List
	 * @param test
	 * @param object 
	 */
	public void postProcessTest(Test test, TestStatement object) {
		try {
			if (test.getLhs() instanceof ProxyNode) {
				test.setLhs(((ProxyNode)test.getLhs()).getProxyFor());
			}
			Object lhs = test.getLhs();
			if (lhs instanceof List<?> && ((List<?>)lhs).size() > 0) {
				if (((List<?>)lhs).get(0) instanceof GraphPatternElement) {
					flattenLinkedList((List<GraphPatternElement>)lhs);
				}
				if (lhs instanceof List<?>) {
					if (((List<?>)lhs).size() == 1) {
						lhs = ((List<?>)lhs).get(0);
						test.setLhs(lhs);
					}
					else if (((List<?>)lhs).size() == 2 && ((List<?>)lhs).get(1) instanceof BuiltinElement &&
							((BuiltinElement)((List<?>)lhs).get(1)).isCreatedFromInterval()) {
						test.setLhs(((List<?>)lhs).get(0));
						test.setCompName(((BuiltinElement)((List<?>)lhs).get(1)).getFuncType());
						test.setRhs(((BuiltinElement)((List<?>)lhs).get(1)).getArguments().get(1));
					}
				}
			}
			else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
				boolean done = false;
				if ((((GraphPatternElement)lhs).getNext() instanceof  BuiltinElement)) {
					// there is a builtin next
					BuiltinElement be = (BuiltinElement) ((GraphPatternElement)lhs).getNext();
					if (isComparisonBuiltin(be.getFuncName())) {
						((GraphPatternElement)lhs).setNext(null);
						if (be.getArguments().size() > 1) {
							if (be.getArguments().get(0) instanceof VariableNode) {
								test.setRhs(be.getArguments().get(1));
							}
							else {
								// this is of the form V is P of S so comparison must be reversed
								reverseBuiltinComparisonDirection(be);
								test.setRhs(be.getArguments().get(0));
							}
						}
						else {
							addError(new IFTranslationError("A BuiltinElement in a Test is a comparison (" + be.getFuncName() + ") but has less than two arguemnts (" + be.toString() + ")"));
						}
						test.setCompName(be.getFuncName());
						done = true;
					}
				}
				if (!done) {
					List<GraphPatternElement> newLhs = new ArrayList<GraphPatternElement>();
					newLhs.add((GraphPatternElement) lhs);
					test.setLhs(flattenLinkedList(newLhs));
				}
			}
			else if (lhs instanceof BuiltinElement && isModifiedTriple(((BuiltinElement)lhs).getFuncType())) {
				List<Node> args = ((BuiltinElement)lhs).getArguments();
				if (args != null && args.size() == 2) {
					test.setLhs(args.get(1));
					test.setRhs(args.get(0));
					test.setCompName(((BuiltinElement)lhs).getFuncName());
				}
			}
			if (test.getRhs() instanceof ProxyNode) {
				test.setRhs(((ProxyNode)test.getRhs()).getProxyFor());
			}
			Object rhs = test.getRhs();
			if (rhs instanceof List<?> && ((List<?>)rhs).size() > 0) {
				if (((List<?>)rhs).get(0) instanceof GraphPatternElement) {
					flattenLinkedList((List<GraphPatternElement>)rhs);
				}
			}
			else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
				boolean done = false;
				if ((((GraphPatternElement)rhs).getNext() instanceof BuiltinElement)) {
					BuiltinElement be = (BuiltinElement) ((GraphPatternElement)rhs).getNext();
					if (isComparisonBuiltin(be.getFuncName())) {
						((GraphPatternElement)rhs).setNext(null);
						test.setLhs(be.getArguments().get(1));
						test.setCompName(be.getFuncName());
						done = true;
					}
				}
				if (!done) {
					List<GraphPatternElement> newRhs = new ArrayList<GraphPatternElement>();
					newRhs.add((GraphPatternElement) rhs);
					test.setRhs(flattenLinkedList(newRhs));
				}
			}
			
			if (lhs != null && lhs instanceof GraphPatternElement) {
				
			}
	
			if (test.getCompType() != null && test.getCompType().equals(ComparisonType.Eq) 
					&& test.getLhs() != null && test.getRhs() != null 
					&& test.getLhs() instanceof NamedNode && test.getRhs() instanceof List<?>) {
				if (test.getRhsVariables() != null && test.getRhsVariables().size() == 1) {
					String rhsvar = test.getRhsVariables().get(0).getName();
					List<?> rhslist = (List<?>) test.getRhs();
					boolean allPass = true;
					for (int i = 0; i < rhslist.size(); i++) {
						Object anrhs = rhslist.get(i);
						if (!(anrhs instanceof TripleElement)) {
							allPass = false;
							break;
						}
						else {
							Node subj = ((TripleElement)anrhs).getSubject();
							if (!(subj instanceof VariableNode) || !(((VariableNode)subj).getName().equals(rhsvar))) {
								allPass = false;
								break;
							}
						}
					}
					if (allPass) {
						for (int i = 0; i < rhslist.size(); i++) {
							TripleElement triple = (TripleElement) rhslist.get(i);
							triple.setSubject((Node) test.getLhs());
						}
						test.setLhs(test.getRhs());
						test.setRhs(null);
						test.setRhsVariables(null);
						test.setCompName((String)null);
					}
				}
			}
			
			// this is a validity checking section
			TripleElement singleTriple = null;
			if (test.getLhs() instanceof TripleElement && test.getRhs() == null && ((TripleElement)test.getLhs()).getNext() == null) {
				singleTriple = (TripleElement) test.getLhs();
			}
			else if (test.getRhs() instanceof TripleElement && test.getLhs() == null && ((TripleElement)test.getRhs()).getNext() == null) {
				singleTriple = (TripleElement) test.getRhs();
			}
			if (singleTriple != null) {
				// a single triple test should not have any variables in it
				if (singleTriple.getSubject() instanceof VariableNode || 
						singleTriple.getPredicate() instanceof VariableNode ||
						singleTriple.getObject() instanceof VariableNode) {
					addError(new IFTranslationError("Test is a single triple to be matched; should not contain variables.", object));
				}
				else {
					try {
	//					modelManager.validateStatement(singleTriple.getSubject(), singleTriple.getPredicate(), singleTriple.getObject());
					}
					catch (Throwable t) {
						// try to validate but don't do anything on Exception
					}
				}
			}
			else if (test.getLhs() instanceof List<?>) {
				boolean comparisonOpFound = false;
				boolean triplesOnly = true;
				for (GraphPatternElement gpe : (JunctionList)test.getLhs()) {
					if (!(gpe instanceof TripleElement)) {
						triplesOnly = false;
					}
					if (gpe instanceof BuiltinElement && SadlModelProcessor.isComparisonBuiltin(((BuiltinElement)gpe).getFuncName())) {
						comparisonOpFound = true;
					}
				}
				if (!triplesOnly && !comparisonOpFound) {
					addError(new IFTranslationError("Does not appear to be a valid test--contains operators but no comparison comparison.", object));
				}
				else if (triplesOnly) {
					// make sure all variables are bound
					List<VariableNode> vars = new ArrayList<VariableNode>();
					for (GraphPatternElement gpe : (JunctionList)test.getLhs()) {
						if (gpe instanceof TripleElement) {
							if (((TripleElement) gpe).getObject() instanceof VariableNode) {
								vars.add((VariableNode) ((TripleElement) gpe).getObject());
							}
							else if (((TripleElement) gpe).getSubject() instanceof VariableNode) {
								vars.remove(((TripleElement) gpe).getSubject());
							}
						}
					}
					if (vars.size() > 0) {
						addError(new IFTranslationError("Test appears to have unbound variables so can't be evaluated to true or false", object));
					}
				}
			}
		}
		catch (Exception e) {
			addError(new IFTranslationError(e.getMessage() ));
		}
	}

	private void setBuiltinElementNameAndType(ComparisonType compType, BuiltinElement be) throws TranslationException {
		if (compType.equals(ComparisonType.Eq)) {
			be.setFuncName("==");
//			return BuiltinType.Equal;
		}
		else if (compType.equals(ComparisonType.GT)) {
			be.setFuncName(">");
//			return BuiltinType.GT;
		}
		else if (compType.equals(ComparisonType.GTE)) {
			be.setFuncName(">=");
//			return BuiltinType.GTE;
		}
		else if (compType.equals(ComparisonType.LT)) {
			be.setFuncName("<");
//			return BuiltinType.LT;
		}
		else if (compType.equals(ComparisonType.LTE)) {
			be.setFuncName("<=");
//			return BuiltinType.LTE;
		}
		else if (compType.equals(ComparisonType.Neq)) {
			be.setFuncName("!=");
//			return BuiltinType.NotEqual;
		}
		else {
			throw new TranslationException("Invalid ComparisonType: " + compType.toString());
		}
	}

	public static void reverseBuiltinComparisonDirection(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<=");
		}
	}

	public static void builtinComparisonComplement(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<=");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<");
		}
	}

	public static boolean isComparisonBuiltin(String builtinName) {
		ComparisonType[] types = ComparisonType.values();
		for (ComparisonType type : types) {
			if (type.matches(builtinName)) {
				return true;
			}
		}
		return false;
	}

	public Rule postProcessRule(Rule rule, EObject object) throws TranslationException {
		clearCruleVariableTypedOutput();
		clearModifiedBuiltinElementsAndUnits();
		vNum = getModelProcessor().getVariableNumber();
		variableIsInstanceReplacement(rule);
		try {
			// do this first so that the arguments don't change before these are applied
			addImpliedAndExpandedProperties(rule);
			// now do this before any null subjects that are the same variable get replaced with different variables.
			addMissingCommonVariables(rule);
			// now add other missing patterns, if needed
//			addMissingTriplePatterns(rule);
		} catch (InvalidNameException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (InvalidTypeException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} 
		
		// convert givens linked list to array; expand conjunctions
		List<GraphPatternElement> givens = flattenRuleJunctions(rule.getGivens());
		if (givens != null) {
			Object results;
			try {
				results = expandProxyNodes(givens, false, true);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					rule.setGivens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		else {
			retiredProxyNodes.clear();
		}
		
		// convert ifs linked list to array; expand conjunctions
		List<GraphPatternElement> ifs = flattenRuleJunctions(rule.getIfs());
		if (ifs != null) {
			Object results;
			try {
				results = expandProxyNodes(ifs, false, false);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					rule.setIfs((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		// now process conclusions
		List<GraphPatternElement> thens = flattenRuleJunctions(rule.getThens());
		if (thens != null) {
			Object results;
			try {
				results = expandProxyNodes(thens, true, false);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					
					// this removal is recursive in some cases, so it isn't safe to operate over the same list
					//   that is being passed in for removal
					if (results instanceof List<?>) {
						List<GraphPatternElement>copyOfResults = new ArrayList<GraphPatternElement>();
						copyOfResults.addAll((Collection<? extends GraphPatternElement>) results);
						for (int i = 0; i < ((List<?>)copyOfResults).size(); i++) {
							GraphPatternElement tgpe = (GraphPatternElement) ((List<?>)copyOfResults).get(i);
							results = moveEmbeddedGPEsToIfs(rule, (List<?>) results, tgpe);
						}
					}
					rule.setThens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				throw e;
			} 		
		}
		try {
			// this seems like a reasonable place to augment a rule assigning a UnittedQuantity
			//	in the rule head to use the "there exists construct
			rule = checkRuleForNewUnittedQuantityCreation(rule);
			removeDuplicateElements(rule);
		} catch (InvalidNameException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidTypeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TranslationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return rule;
	}
	
	private Rule checkRuleForNewUnittedQuantityCreation(Rule rule) {
		// Using the modifiedBuiltinElementsAndUnits, add any combineUnits and there exists constructs to the rule
		List<BuiltinElementAndUnits> modifiedBEs = getModifiedBuiltinElementsAndUnits();
		if (modifiedBEs != null && modifiedBEs.size() > 0) {
			Iterator<BuiltinElementAndUnits> keyItr = modifiedBEs.iterator();
			while (keyItr.hasNext()) {
				BuiltinElementAndUnits beau = keyItr.next();
				BuiltinElement be = beau.getBuiltinElement();
				if (be.getArguments().size() < 3) {
					continue;
				}
				Node thirdArg = be.getArguments().get(2);
				Node[] unitVars = beau.getArgUnits();
				for (GraphPatternElement gpe : rule.getThens()) {
					if (gpe instanceof TripleElement && ((TripleElement)gpe).getObject().equals(thirdArg)) {
						Node uqUnits = null;
						if (unitVars != null) {
							if (unitVars.length == 2 && unitVars[0] != null && unitVars[1] != null) {
								BuiltinElement combineUnitsBe = new BuiltinElement();
								combineUnitsBe.setFuncName("combineUnits");
								combineUnitsBe.addArgument(new Literal(be.getFuncName(), null, LiteralType.StringLiteral));
								combineUnitsBe.addArgument(unitVars[0]);
								combineUnitsBe.addArgument(unitVars[1]);
								uqUnits = new VariableNode(getNewVar());
								combineUnitsBe.addArgument(uqUnits);
								rule.getIfs().add(combineUnitsBe);
							}
							else if (unitVars.length > 0) {
								uqUnits = unitVars[0];
							}
						}
						BuiltinElement thereExistsBE = new BuiltinElement();
						thereExistsBE.setFuncName("thereExists");
						Node pred = ((TripleElement)gpe).getPredicate();
						OntProperty prop = getTheJenaModel().getOntProperty(pred.getURI());
						NamedNode uQClass = null;
						if (prop != null) {
							OntResource rng = prop.getRange();
							if (rng != null) {
								uQClass = new NamedNode(rng.getURI());
							}
						}
						if (uQClass == null) {
							uQClass = new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI);
						}
						uQClass.setNodeType(NodeType.ClassNode);
						thereExistsBE.addArgument(uQClass);
						NamedNode valuePred = new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_VALUE_URI);
						valuePred.setNodeType(NodeType.DataTypeProperty);
						thereExistsBE.addArgument(valuePred);
						thereExistsBE.addArgument(thirdArg);
						NamedNode unitPred = new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_UNIT_URI);
						unitPred.setNodeType(NodeType.DataTypeProperty);
						thereExistsBE.addArgument(unitPred);
						thereExistsBE.addArgument(uqUnits);
						NamedNode plusNode = new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_URI + "#Plus");
						plusNode.setNodeType(NodeType.InstanceNode);
						thereExistsBE.addArgument(plusNode);
						thereExistsBE.addArgument(((TripleElement)gpe).getSubject());
						thereExistsBE.addArgument(((TripleElement)gpe).getPredicate());
						int thenIdx = rule.getThens().indexOf(gpe);
						rule.getThens().set(thenIdx, thereExistsBE);
					}
				}
			}
		}
		return rule;
	}
	
	private void variableIsInstanceReplacement(Rule rule) {
		 List<VariableNode> vars = rule.getRuleVariables();
		 if (vars != null) {
			 for (VariableNode var : vars) {
				 if (var.getDefinitions() != null) {
					 for (Node vardef : var.getDefinitions()) {
						 if (vardef instanceof NamedNode &&
								 ((NamedNode)vardef).getNodeType().equals(NodeType.InstanceNode)) {
							 // replace all instances of this VariableNode with its definition NamedNode
							 replaceVariableNodeWithInstanceNamedNode(var, vardef, rule.getGivens());
							 replaceVariableNodeWithInstanceNamedNode(var, vardef, rule.getIfs());
							 replaceVariableNodeWithInstanceNamedNode(var, vardef, rule.getThens());
						 }
					 }
				 }
			 }
		 }
		
	}

	private void replaceVariableNodeWithInstanceNamedNode(VariableNode var, Node vardef, List<GraphPatternElement> gpes) {
		if (gpes != null) {
			for (GraphPatternElement gpe : gpes) {
				replaceVariableNodeWithInstanceNamedNode(var, vardef, gpe);
			}
		}
		
	}

	private void replaceVariableNodeWithInstanceNamedNode(VariableNode var, Node vardef, GraphPatternElement gpe) {
		if (gpe instanceof TripleElement) {
			if (((TripleElement)gpe).getSubject().equals(var)) {
				((TripleElement)gpe).setSubject(vardef);
			}
			if (((TripleElement)gpe).getPredicate().equals(var)) {
				((TripleElement)gpe).setPredicate(vardef);
			}
			if (((TripleElement)gpe).getObject().equals(var)) {
				((TripleElement)gpe).setObject(vardef);
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			for (int idx = 0; idx < args.size(); idx++) {
				if (args.get(idx).equals(var)) {
					args.set(idx, vardef);
				}
			}
		}
		else if (gpe instanceof Junction) {
			Object lhs = ((Junction)gpe).getLhs();
			Object rhs = ((Junction)gpe).getRhs();
			if (lhs instanceof ProxyNode) {
				replaceVariableNodeWithInstanceNamedNode(var, vardef, ((ProxyNode)((Junction)gpe).getLhs()).getProxyFor());
			}
			if (rhs instanceof ProxyNode) {
				replaceVariableNodeWithInstanceNamedNode(var, vardef, ((ProxyNode)((Junction)gpe).getRhs()).getProxyFor());
			}
		}
	}

	private void addMissingCommonVariables(Rule rule) throws TranslationException {
		// Find triples with null subjects
		List<TripleElement> nullSubjects = null;
		if (rule.getGivens() != null) {
			nullSubjects = getNullSubjectTriples(rule.getGivens(), nullSubjects);
		}
		if (rule.getIfs() != null) {
			nullSubjects = getNullSubjectTriples(rule.getIfs(), nullSubjects);
		}
		if (rule.getThens() != null) {
			nullSubjects = getNullSubjectTriples(rule.getThens(), nullSubjects);
		}
		if (nullSubjects != null) {
			Map<NamedNode,List<Resource>> cache = new HashMap<NamedNode, List<Resource>>();
			for (int i = 0; i < nullSubjects.size(); i++) {
				Node prop = nullSubjects.get(i).getPredicate();
				if (prop instanceof NamedNode) {
					Property p = getTheJenaModel().getProperty(((NamedNode)prop).toFullyQualifiedString());
					StmtIterator dmnitr = getTheJenaModel().listStatements(p, RDFS.domain, (RDFNode)null);
					if (dmnitr.hasNext()) {
						List<Resource> dmnclses = new ArrayList<Resource>();
						while (dmnitr.hasNext()) {
							RDFNode dmn = dmnitr.nextStatement().getObject();
							if (dmn.isURIResource()) {
								dmnclses.add((Resource) dmn);
							}
							else if (dmn.canAs(OntClass.class)&& dmn.as(OntClass.class).isUnionClass()) {
								dmnclses.addAll(getUnionClassMembers(dmn.as(OntClass.class).asUnionClass()));
							}
							else {
								throw new TranslationException("Unhandled case");
							}
						}
						cache.put((NamedNode)prop, dmnclses);
					}
				}
			}
			for (int i = 0; i < nullSubjects.size(); i++) {
				List<Resource> dmns1 = cache.get(nullSubjects.get(i).getPredicate());
				for (int j = i +1; j < nullSubjects.size(); j++) {
					boolean matched = false;
					List<Resource> dmns2 = cache.get(nullSubjects.get(j).getPredicate());
					for (int k = 0; k < dmns2.size(); k++) {
						Resource dmn2 = dmns2.get(k);
						if (dmns1.contains(dmn2)) {
							// there's a match--connect them
							VariableNode cmnvar = new VariableNode(getNewVar());
							nullSubjects.get(i).setSubject(cmnvar);
							nullSubjects.get(j).setSubject(cmnvar);
							matched = true;
							break;
						}
						else if (dmn2.canAs(OntClass.class)) {
							for (int l = 0; l < dmns1.size(); l++) {
								Resource dmn1 = dmns1.get(l);
								if (dmn1.canAs(OntClass.class)) {
									if (SadlUtils.classIsSuperClassOf(dmn1.as(OntClass.class), dmn2.as(OntClass.class))) {
										VariableNode cmnvar = new VariableNode(getNewVar());
										nullSubjects.get(i).setSubject(cmnvar);
										nullSubjects.get(j).setSubject(cmnvar);
										matched = true;
										break;
									}
									else if (SadlUtils.classIsSuperClassOf(dmn2.as(OntClass.class), dmn1.as(OntClass.class))) {
										VariableNode cmnvar = new VariableNode(getNewVar());
										nullSubjects.get(i).setSubject(cmnvar);
										nullSubjects.get(j).setSubject(cmnvar);
										matched = true;
										break;
									}
								}
							}
						}
					}
					if (matched) {
						continue;
					}
				}
			}

		}
	}

	private List<OntClass> getUnionClassMembers(UnionClass unionClass) {
		List<OntClass> members = new ArrayList<OntClass>();
		ExtendedIterator<? extends OntClass> ucitr = unionClass.listOperands();
		while (ucitr.hasNext()) {
			OntClass uccls = ucitr.next();
			if (uccls.isURIResource()) {
				members.add(uccls);
			}
			else if (uccls.isUnionClass()) {
				members.addAll(getUnionClassMembers(uccls.asUnionClass()));
			}
		}
		return members;
	}

	private List<TripleElement> getNullSubjectTriples(List<GraphPatternElement> gpes,
			List<TripleElement> nullSubjects) {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			nullSubjects = getNullSubjectTriples(nullSubjects, gpe);
		}
		return nullSubjects;
	}

	private List<TripleElement> getNullSubjectTriples(List<TripleElement> nullSubjects, GraphPatternElement gpe) {
		if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject() == null) {
			if (nullSubjects == null) {
				nullSubjects = new ArrayList<TripleElement>();
			}
			nullSubjects.add((TripleElement) gpe);
		}
		else {
			if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject() instanceof ProxyNode) {
				nullSubjects = getNullSubjectTriples(nullSubjects, (GraphPatternElement)((ProxyNode)((TripleElement)gpe).getSubject()).getProxyFor());
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int i = 0; args != null && i < args.size(); i++) {
					if (args.get(i) instanceof ProxyNode) {
						nullSubjects = getNullSubjectTriples(nullSubjects, (GraphPatternElement)((ProxyNode)args.get(i)).getProxyFor());
					}
				}
			}
		}
		return nullSubjects;
	}

	private Rule addImpliedAndExpandedProperties(Rule rule) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<GraphPatternElement> gvns = rule.getGivens();
		if (gvns != null) {
			addImpliedAndExpandedProperties(gvns);
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (ifs != null) {
			addImpliedAndExpandedProperties(ifs);
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (thens != null) {
			addImpliedAndExpandedProperties(thens);
		}
		return rule;
	}
	
//	public Test postProcessTest(Test test, EObject context) {
//		
//		return test;
//	}
//	
//	private Test addImpliedAndExpandedProperties(Test test) {
//		
//		return test;
//	}
	
//	public Query postProcessQuery(Query query, EObject context) {
//		
//		return query;
//	}
//	
//	private Query addImpliedAndExpandedProperties(Query query) {
//		
//		return query;
//	}
	
	@SuppressWarnings("unchecked")
	public Object postProcessExpressionStatement(Object exprStmt, EObject context) throws TranslationException, InvalidNameException, InvalidTypeException {
		if (exprStmt instanceof GraphPatternElement) {
			return addImpliedAndExpandedProperties((GraphPatternElement)exprStmt);
		}
		else if (exprStmt instanceof List<?>) {
			return addImpliedAndExpandedProperties((List<GraphPatternElement>)exprStmt);
		}
		else if (exprStmt instanceof Query) {
			List<GraphPatternElement> patterns = addImpliedAndExpandedProperties(((Query)exprStmt).getPatterns());
			((Query)exprStmt).setPatterns(patterns);
			return exprStmt;
		}
//		throw new TranslationException("Unexpected input into postProcessExpressionStatement: " + exprStmt.getClass().getCanonicalName());
		return exprStmt;
	}
	
	protected List<GraphPatternElement> addImpliedAndExpandedProperties(List<GraphPatternElement> fgpes) throws InvalidNameException, InvalidTypeException, TranslationException {
		for (int i = 0; i < fgpes.size(); i++) {
			GraphPatternElement gpeback = addImpliedAndExpandedProperties(fgpes.get(i));
			fgpes.set(i, gpeback);
		}
		return fgpes;
	}

	protected GraphPatternElement addImpliedAndExpandedProperties(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean processed = false;
		if (gpe.getExpandedPropertiesToBeUsed() != null) {
			gpe = applyExpandedProperties(gpe);
			processed = true;
		}
		if (!processed) {
			if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				if (args != null) {
					if (args.size() == 2 && ((BuiltinElement)gpe).getFuncType().equals(BuiltinType.Equal) &&
							args.get(1) instanceof VariableNode &&
							args.get(0) instanceof ProxyNode && 
							((ProxyNode)args.get(0)).getProxyFor() instanceof TripleElement &&
							((TripleElement)((ProxyNode)args.get(0)).getProxyFor()).getObject() == null) {
						// this needs to be collapsed to a single triple, which will happen later, so don't do anything
						return gpe;
					}
					for (int i = 0; args != null && i < args.size(); i++ ) {
						Node arg = args.get(i);
						if (arg instanceof ProxyNode) {
							GraphPatternElement gpeback = addImpliedAndExpandedProperties((GraphPatternElement)((ProxyNode)arg).getProxyFor());
							((ProxyNode)arg).setProxyFor(gpeback);
						}
					}
				}
			}
			else if (gpe instanceof TripleElement) {
				Node pred = ((TripleElement)gpe).getPredicate();
				if (pred instanceof NamedNode && ((NamedNode)pred).getImpliedPropertyNode() != null) {
					TripleElement newTriple = new TripleElement(null, ((TripleElement)gpe).getPredicate(), null);
					newTriple.setSourceType(TripleSourceType.ImpliedPropertyTriple);
					newTriple.setPredicate(((NamedNode)pred).getImpliedPropertyNode());
					newTriple.setObject(((TripleElement)gpe).getObject());
					((TripleElement)gpe).setObject(SadlModelProcessor.nodeCheck(newTriple));
					((NamedNode)pred).setImpliedPropertyNode(null);
					if (((TripleElement)gpe).getModifierType().equals(TripleModifierType.Not)) {
						newTriple.setType(TripleModifierType.Not);
						((TripleElement)gpe).setType(TripleModifierType.None);
					}
				}
			}
			else if (gpe instanceof Junction) {
				Object lhs = ((Junction) gpe).getLhs();
				if (lhs instanceof ProxyNode) {
					((Junction)gpe).setLhs(SadlModelProcessor.nodeCheck(addImpliedAndExpandedProperties(((ProxyNode)lhs).getProxyFor())));
				}
				else {
					throw new TranslationException("Junction must contain only ProxyNode as left and right.");
				}
				Object rhs = ((Junction) gpe).getRhs();
				if (rhs instanceof ProxyNode) {
					((Junction)gpe).setRhs(SadlModelProcessor.nodeCheck(addImpliedAndExpandedProperties(((ProxyNode)rhs).getProxyFor())));
				}
				else if (rhs instanceof NamedNode && ((NamedNode)rhs).getNodeType().equals(NodeType.FunctionNode)) {
					// let it go--it should eventually be a BuiltinElement.
				}
				else if (rhs != null){
					throw new TranslationException("Junction must contain only ProxyNode as left and right.");
				}
			}
		}
		return gpe;
	}

	private GraphPatternElement applyExpandedProperties(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<NamedNode> eps = gpe.getExpandedPropertiesToBeUsed();
		List<GraphPatternElement> junctionMembers = null;
		JunctionType jcttype = JunctionType.Conj;
		if (gpe instanceof BuiltinElement && eps.size() > 1) {
			if (((BuiltinElement)gpe).getFuncType().equals(BuiltinType.NotEqual)) {
				if (((BuiltinElement)gpe).getFuncName().equals("assign")) {
					throw new TranslationException("Can't have disjunction in assignment");
				}
				jcttype = JunctionType.Disj;
			}
			junctionMembers = new ArrayList<GraphPatternElement>();
		}
		
		if (gpe instanceof BuiltinElement) {
			if (((BuiltinElement)gpe).getArguments() == null || ((BuiltinElement)gpe).getArguments().size() != 2) {
				throw new TranslationException("Expanded properties can't be applied to a BuiltinElement with other than 2 arguments");
			}
			int expPropCntr = 0;
			List<Node> originalArgs = new ArrayList<Node>();
			for (NamedNode ep : eps) {
				BuiltinElement workingGpe = (BuiltinElement) gpe;
				if (expPropCntr == 0) {
					for (int i = 0; i < ((BuiltinElement)workingGpe).getArguments().size(); i++) {
						Node agi = ((BuiltinElement)workingGpe).getArguments().get(i);
						if (agi instanceof ProxyNode && ((ProxyNode)agi).getProxyFor() instanceof BuiltinElement) {
							addImpliedAndExpandedProperties((BuiltinElement)((ProxyNode)agi).getProxyFor());
						}
						originalArgs.add(agi);
					}
				}
				else {
					workingGpe = new BuiltinElement();
					workingGpe.setFuncName(((BuiltinElement) gpe).getFuncName());
					workingGpe.setFuncType(((BuiltinElement) gpe).getFuncType());
					for (int i = 0; i < ((BuiltinElement) gpe).getArguments().size(); i++) {
						workingGpe.addArgument(originalArgs.get(i));
					}
				}
				Node arg0 = ((BuiltinElement)workingGpe).getArguments().get(0);
				if (arg0 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg0))) {
					TripleElement newTriple = singlePropertyToTriple((NamedNode)arg0);
					arg0 = SadlModelProcessor.nodeCheck(newTriple);
				}
				TripleElement newTriple1 = new TripleElement(arg0, ep, null);
				newTriple1.setSourceType(TripleSourceType.ExpandedPropertyTriple);
				arg0 = SadlModelProcessor.nodeCheck(newTriple1);
				((BuiltinElement)workingGpe).getArguments().set(0, arg0);			

				Node arg1 = ((BuiltinElement)workingGpe).getArguments().get(1);
				if (arg1 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg1))) {
					TripleElement newTriple = singlePropertyToTriple((NamedNode)arg1);
					newTriple.setSourceType(TripleSourceType.ExpandedPropertyTriple);
					arg1 = SadlModelProcessor.nodeCheck(newTriple);
				}
				TripleElement newTriple2 = new TripleElement(arg1, ep, null);
				newTriple2.setSourceType(TripleSourceType.ExpandedPropertyTriple);
				arg1 = SadlModelProcessor.nodeCheck(newTriple2);
				((BuiltinElement)workingGpe).getArguments().set(1, arg1);	
				
				((BuiltinElement)workingGpe).setExpandedPropertiesToBeUsed(null);
				if (junctionMembers != null) {
					junctionMembers.add(workingGpe);
				}
				expPropCntr++;
			}
			if (junctionMembers != null) {
				if (jcttype.equals(JunctionType.Conj)) {
					gpe = (GraphPatternElement) listToAnd(junctionMembers).get(0);
				}
				else {
					gpe = listToOr(junctionMembers);
				}
			}
		}
		else if (gpe instanceof TripleElement) {
			Node objNode = ((TripleElement)gpe).getObject();
			if (!(objNode instanceof ConstantNode && ((ConstantNode)objNode).getName().equals(SadlConstants.CONSTANT_NONE))) {		
				int i = 0;
			}
		}
		else {
			// expanded properties can only apply to equality/inequality and assignment, so no other GraphPatternElement type should be encountered
			throw new TranslationException("Unexpeced non-BuiltinElement has expanded properties");
		}
		gpe.setExpandedPropertiesToBeUsed(null);
		return gpe;
	}

	private TripleElement singlePropertyToTriple(NamedNode prop) {
		VariableNode nvar = null; //new VariableNode(getNewVar());
		TripleElement newTriple = new TripleElement(nvar, prop, null);
		return newTriple;
	}

	private List<GraphPatternElement> decorateCRuleVariables(List<GraphPatternElement> gpes, boolean isRuleThen) {
		for (int i = 0; i < gpes.size(); i++) {
			Object premise = gpes.get(i);
			if (premise instanceof BuiltinElement) {
				if (((BuiltinElement)premise).getArguments() != null) {
					for (Node n: ((BuiltinElement)premise).getArguments()) {
						if (n instanceof VariableNode && ((VariableNode)n).isCRulesVariable() && ((VariableNode)n).getType() != null && !isCruleVariableInTypeOutput((VariableNode) n)) {
							TripleElement newTypeTriple = new TripleElement(n, new RDFTypeNode(), ((VariableNode)n).getType());
							if (isRuleThen && !((BuiltinElement)premise).getFuncName().equals("thereExists")) {
								((Rule) getTarget()).getIfs().add(0, newTypeTriple);
							}
							else {
								gpes.add(++i, newTypeTriple);
							}
							addCruleVariableToTypeOutput((VariableNode) n);
							if (!isRuleThen) {
								try {
									i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) n);
								} catch (TranslationException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
							}
						}
					}
				}
			}
			else if (premise instanceof TripleElement) {
				try {
					TripleElement gpe = (TripleElement) premise;
					Node subj = gpe.getSubject();
					Node obj = gpe.getObject();
					if (subj instanceof VariableNode && ((VariableNode)subj).isCRulesVariable() && ((VariableNode)subj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) subj)) {
						if (!updateVariableTypeTriple((VariableNode) subj, ((VariableNode)subj).getType(), gpes)) {
							TripleElement newTypeTriple = new TripleElement(subj, new RDFTypeNode(), ((VariableNode)subj).getType());
							newTypeTriple.setSourceType(TripleSourceType.ITC);
							if (isRuleThen && getTarget() instanceof Rule) {
								((Rule) getTarget()).getIfs().add(0, newTypeTriple);
							}
							else {
								gpes.add(i++, newTypeTriple);
							}
						}
						addCruleVariableToTypeOutput((VariableNode) subj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) subj);
						}
					}
					if (obj instanceof VariableNode && ((VariableNode)obj).isCRulesVariable() && ((VariableNode)obj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) obj)) {
						if (!updateVariableTypeTriple((VariableNode) obj, ((VariableNode)obj).getType(), gpes)) {
							TripleElement newTypeTriple = new TripleElement(obj, new RDFTypeNode(), ((VariableNode)obj).getType());
							newTypeTriple.setSourceType(TripleSourceType.ITC);
							if (isRuleThen && getTarget() != null && getTarget() instanceof Rule &&
									((Rule)getTarget()).getIfs() != null) {
								((Rule) getTarget()).getIfs().add(0, newTypeTriple);
							}
							else {
								gpes.add(i++, newTypeTriple);
							}
						}
						addCruleVariableToTypeOutput((VariableNode) obj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) obj);
						}
					}
				} catch (TranslationException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		return gpes;
	}

	private boolean updateVariableTypeTriple(VariableNode var, Node type, List<GraphPatternElement> gpes) {
		for (GraphPatternElement gpe : gpes) {
			if (gpe instanceof TripleElement && ((TripleElement)gpe).getPredicate() instanceof RDFTypeNode) {
				if (((TripleElement)gpe).getSubject().equals(var)) {
					// don't broaden the type
					if (!classNodeIsSubclass(((TripleElement)gpe).getObject(), type)) {
						((TripleElement)gpe).setObject(type);
					}
					return true;
				}
			}
		}
		return false;
	}

	private boolean classNodeIsSubclass(Node type, Node type2) {
		if (type.equals(type2)) {
			return true;
		}
		if (type instanceof NamedNode && type2 instanceof NamedNode && 
				((NamedNode)type).getNodeType().equals(NodeType.ClassNode) &&
				((NamedNode)type2).getNodeType().equals(NodeType.ClassNode)) {
			OntClass cls1 = getTheJenaModel().getOntClass(type.getURI());
			OntClass cls2 = getTheJenaModel().getOntClass(type2.getURI());
			try {
				if (SadlUtils.classIsSubclassOf(cls1, cls2, true, null)) {
					return true;
				}
			} catch (CircularDependencyException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return false;
	}

	private List<GraphPatternElement> flattenRuleJunctions(List<GraphPatternElement> lst) {
		if (lst == null) return null;
		List<GraphPatternElement> results = new ArrayList<GraphPatternElement>();
		for (int i = 0; i < lst.size(); i++) {
			GraphPatternElement gpe = lst.get(i);
			if (gpe instanceof Junction) {
				if (((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					try {
						results.addAll(flattenRuleJunction((Junction) gpe));
					} catch (TranslationException e) {
						addError(new IFTranslationError(e.getMessage(), e));
					}
				}
				else {
//					addError(new IFTranslationError("Disjunction not supported in rules at this time"));
					// leave this error checking for the final translations step--some rules may support disjunction
					results.add(gpe);
				}
			}
//			else if (gpe instanceof BuiltinElement && 
//					((BuiltinElement)gpe).getFuncName() != null && ((BuiltinElement)gpe).getFuncName().equals("and")) {
//				List<Node> args = ((BuiltinElement)gpe).getArguments();
//				for (int j = 0; j <= args.size(); j++) {
//					Node nj = args.get(j);
//				}
//			}
			else {
				results.add(gpe);
			}
		}
		return results;
	}

	private List<GraphPatternElement> flattenRuleJunction(Junction jct) throws TranslationException {
		List<GraphPatternElement>results = new ArrayList<GraphPatternElement>();
		if (!jct.getJunctionType().equals(JunctionType.Conj)) {
			// Whether this is supported is up to the target translator to decide, not the Intermediate Form Translator
			results.add(jct);
			return results;
		}
		Object lhs = jct.getLhs();
		if (lhs instanceof ProxyNode) {
			lhs = ((ProxyNode)lhs).getProxyFor();
		}
		if (lhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)lhs));
		}
		else if (lhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) lhs);
		}
		else if (lhs instanceof List<?>) {
			for (int i = 0; i < ((List<?>)lhs).size(); i++) {
				results.add((GraphPatternElement) ((List<?>)lhs).get(i));
			}
		}
		else {
			throw new TranslationException("Encountered non-GraphPatternElement during rule translation");
		}
		Object rhs = jct.getRhs();
		if (rhs instanceof ProxyNode) {
			rhs = ((ProxyNode)rhs).getProxyFor();
		}
		if (rhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)rhs));
		}
		else if (rhs instanceof GraphPatternElement) {
			results.add((GraphPatternElement)rhs);
		}
		else if (rhs instanceof List<?>) {
			for (int i = 0; i < ((List<?>)rhs).size(); i++) {
				results.add((GraphPatternElement) ((List<?>)rhs).get(i));
			}
		}
		else {
			throw new TranslationException("Encountered non-GraphPatternElement during rule translation");
		}
		return results;
	}

	/**
	 * Method to remove GPE's with isEmbedded true from thens to ifs
	 * 
	 * @param rule
	 * @param results
	 * @param tgpe
	 * @return
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private List<?> moveEmbeddedGPEsToIfs(Rule rule, List<?> results,
			GraphPatternElement tgpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (tgpe.isEmbedded()) {
			if (results.remove(tgpe)) {
				if (rule.getIfs() ==  null) {
				      rule.setIfs(new ArrayList<GraphPatternElement>());
				}
			}
			rule.getIfs().add(tgpe);			
		}
		else {
			if (tgpe instanceof Junction) {
				int idx = results.indexOf(tgpe);
				GraphPatternElement newtgpe = moveEmbeddedFromJunction(rule, (Junction)tgpe);
				if (newtgpe == null) {
					results.remove(idx);
				}
				else if (newtgpe != tgpe) {
					((List<GraphPatternElement>)results).set(idx, newtgpe);
				}
			}
		}
		return results;
	}

	/**
	 * Method to move all embedded GPEs in a Junction to the rule ifs and return whatever should be put in 
	 * the Junction's place or null if nothing.
	 * 
	 * @param rule
	 * @param tgpe
	 * @return
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private GraphPatternElement moveEmbeddedFromJunction(Rule rule,
			Junction tgpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean lhsRemoved = false;
		boolean rhsRemoved = false;
		Object lhs = ((Junction)tgpe).getLhs();
		Object rhs = ((Junction)tgpe).getRhs();
		if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) lhs);
			lhsRemoved = true;
		}
		else if (lhs instanceof Junction) {
			lhs = moveEmbeddedFromJunction(rule, (Junction) lhs);
		}
		if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) rhs);
			rhsRemoved = true;
		}
		else if (rhs instanceof Junction) {
			rhs = moveEmbeddedFromJunction(rule, (Junction) rhs);
		}
		if (lhsRemoved && rhsRemoved) {
			return null;
		}
		if (lhsRemoved) {
			return (GraphPatternElement) rhs;
		}
		if (rhsRemoved) {
			return (GraphPatternElement) lhs;
		}
		tgpe.setLhs(SadlModelProcessor.nodeCheck(lhs));
		tgpe.setRhs(SadlModelProcessor.nodeCheck(rhs));
		return tgpe;
	}

	/**
	 * This Map keeps track of the ProxyNodes that have been retired by GraphPatternElements, allowing the retired
	 * ProxyNode and its associated variable to be reused when that GraphPatternElement is revisited in another ProxyNode.
	 */
	protected Map<GraphPatternElement, ProxyNode> retiredProxyNodes = new HashMap<GraphPatternElement, ProxyNode>();
	
	/**
	 * Top-level method for expanding ProxyNodes. Takes input (pattern) as an Object as
	 * it be instances of different types. Handling is separated by whether a List or not.  
	 * 
	 * @param pattern
	 * @param clearPreviousRetired TODO
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object expandProxyNodes(Object pattern, boolean isRuleThen, boolean clearPreviousRetired) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (clearPreviousRetired) {
			retiredProxyNodes.clear();
		}
		List<GraphPatternElement> patterns = new ArrayList<GraphPatternElement>();
		if (pattern instanceof List<?>) {
			// input is a list so process one at a time
			for (int i = 0; i < ((List<?>)pattern).size(); i++) {
				expandProxyNodes(patterns, ((List<?>)pattern).get(i), isRuleThen, UnNestingType.None);
			}
		}
		else {
			// input is NOT a list so only one thing to process
			Object result = expandProxyNodes(patterns, pattern, isRuleThen, UnNestingType.None);
			if (patterns.size() == 0) {
				return result;
			}
		}
		if (patterns.size() > 0) {
			patterns = decorateCRuleVariables((List<GraphPatternElement>) patterns, isRuleThen);
			if (!(getTarget() instanceof Test) && patterns.size() > 1) {
				patterns = listToAnd(patterns);
			}
		}
		return patterns;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#listToAnd(java.util.List)
	 */
	@Override
	public List<GraphPatternElement> listToAnd(
			List<GraphPatternElement> patterns) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (patterns == null || patterns.size() == 0) {
			return null;
		}
		if (patterns.size() == 1) {
			return patterns;
		}
		GraphPatternElement lhs = patterns.remove(0);
		if (lhs instanceof List<?>) {
			lhs = listToAnd((List<GraphPatternElement>) lhs).get(0);
		}
		Junction jand = new Junction();
		jand.setJunctionName("and");
		jand.setLhs(SadlModelProcessor.nodeCheck(lhs));
		if (patterns.size() > 1) {
			patterns = listToAnd(patterns);
		}
		GraphPatternElement rhs = patterns.get(0);
		if (rhs instanceof List<?>) {
			rhs = listToAnd((List<GraphPatternElement>) rhs).get(0);
		}
		jand.setRhs(SadlModelProcessor.nodeCheck(rhs));
		patterns.set(0, jand);
		return patterns;
	}

	private GraphPatternElement listToOr(List<GraphPatternElement> patterns) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (patterns == null || patterns.size() == 0) {
			return null;
		}
		if (patterns.size() == 1) {
			return patterns.get(0);
		}
		GraphPatternElement lhs = patterns.remove(0);
		Junction jor = new Junction();
		jor.setJunctionName("or");
		jor.setLhs(SadlModelProcessor.nodeCheck(lhs));
		GraphPatternElement rhs = listToOr(patterns);
		jor.setRhs(SadlModelProcessor.nodeCheck(rhs));
		return jor;
	}

	/**
	 * Second-level method for expanding ProxyNodes--this one has a list of inputs passed in as an argument (empty on first call)
	 * and a specific input (pattern) to process.
	 * @param patterns -- the complete list of inputs
	 * @param pattern -- the specific input now being processed
	 * @param isRuleThen -- true if this set of inputs if for a rule conclusion
	 * @param container -- the container of pattern, if known
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, Object pattern, boolean isRuleThen, UnNestingType strategy) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (pattern instanceof ProxyNode) {
			return expandProxyNodes(patterns, ((ProxyNode)pattern).getProxyFor(), isRuleThen, strategy);
		}
		if (pattern instanceof TripleElement) {
			return expandProxyNodes(patterns,(TripleElement)pattern, isRuleThen, strategy);
		}
		else if (pattern instanceof BuiltinElement) {
			return expandProxyNodes(patterns, (BuiltinElement)pattern, isRuleThen);
		}
		else if (pattern instanceof Literal) {
			return pattern;
		}
		else if (pattern instanceof Junction) {
			Object retval = null;
			// remember what we have so far and create a new pattern list for each side of the Junction
			List<GraphPatternElement> existingPatterns = patterns;
			List<GraphPatternElement> lhsPatterns = new ArrayList<GraphPatternElement>();
			List<GraphPatternElement> rhsPatterns = new ArrayList<GraphPatternElement>();
			
			// get the two sides
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			
			// at least handle the interesting special case where they  are literals
			
			if (lhs instanceof Literal) {
				BuiltinElement lhsbe = new BuiltinElement();
				lhsbe.setFuncName("==");
				lhsbe.setCreatedFromInterval(true);
				lhsbe.addArgument(SadlModelProcessor.nodeCheck(lhs));
				((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhsbe));
			}
			else {
				expandProxyNodes(lhsPatterns, lhs, isRuleThen, UnNestingType.None);
				if (lhsPatterns.size() == 1) {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhsPatterns.get(0)));
				}
				else if (lhsPatterns.size() < 1) {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhs));
				}
				else {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(listToAnd(lhsPatterns).get(0)));
				}
			}
			
			if (rhs instanceof Literal) {
				BuiltinElement rhsbe = new BuiltinElement();
				rhsbe.setFuncName("==");
				rhsbe.setCreatedFromInterval(true);
				rhsbe.addArgument(SadlModelProcessor.nodeCheck(rhs));
				retval = SadlModelProcessor.nodeCheck(rhsbe);
				((Junction)pattern).setRhs(retval);
			}
			else {
				retval = expandProxyNodes(rhsPatterns, rhs, isRuleThen, UnNestingType.None);
				if (rhsPatterns.size() == 1) {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(rhsPatterns.get(0)));
				}
				else if (rhsPatterns.size() < 1) {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(rhs));
				}
				else {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(listToAnd(rhsPatterns).get(0)));
				}
			}
			patterns = existingPatterns;
			patterns.add((Junction)pattern);
			return retval;
		}
		return patterns;
	}
	
	/**
	 * If a triple has a null, fill it with a variable (search the patterns list first to avoid duplicates), 
	 *  add the triple to the patterns list, and return the variable. The variable also replaces the proxy node 
	 *  that contained this triple.
	 *  Note that if the triple has both a null subject and a null object, then we must know the container type
	 *  to know which replacement to return. Contained in a BuiltinElement, return the object variable as that becomes the 
	 *  builtin argument and the triple moves before. Contained in a TripleElement, return the subject variable as that
	 *  becomes the object of the containing triple and this triple comes after.
	 * @param patterns
	 * @param te
	 * @param isRuleThen
	 * @param container
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, TripleElement te, boolean isRuleThen, UnNestingType strategy) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(te);
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		else if (retiredNode instanceof VariableNode) {
			// there's already a triple for te in those patterns processed
			// however, check to see if there's an embedded TripleElement to be expanded
			if (te.getObject() instanceof ProxyNode && 
					((ProxyNode)te.getObject()).getProxyFor() instanceof TripleElement &&
					((TripleElement)((ProxyNode)te.getObject()).getProxyFor()).getSubject() == null) {
				TripleElement nestedTriple = (TripleElement)((ProxyNode)te.getObject()).getProxyFor();
				nestedTriple.setSubject(retiredNode);
				patterns.add(nestedTriple);
			}
			return retiredNode;
		}
		Node subj = te.getSubject();
		if (subj instanceof ProxyNode) {
			if (retiredNode != null) {
				subj = returnNode = retiredNode;
			}
			else if (((ProxyNode)subj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)subj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)subj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)subj).getProxyFor(), (ProxyNode) subj);
				}
				subj = returnNode = ((ProxyNode)subj).getReplacementNode();
			}
			else {
				Object realSubj = ((ProxyNode)subj).getProxyFor();
				Object subjNode = expandProxyNodes(patterns, realSubj, isRuleThen, UnNestingType.ReturnObjectMoveBefore);
				if (subjNode == null && realSubj instanceof TripleElement) {
					if (((TripleElement)realSubj).getObject() instanceof VariableNode) {
						subjNode = ((TripleElement)realSubj).getObject();
					}
					else if (te.getSourceType() != null && te.getSourceType().equals(TripleSourceType.SPV)) {
						subjNode = ((TripleElement)realSubj).getSubject();
					}
				}
				((ProxyNode)subj).setReplacementNode(SadlModelProcessor.nodeCheck(subjNode));
				retiredProxyNodes.put((GraphPatternElement) realSubj, (ProxyNode)subj);
				subj = SadlModelProcessor.nodeCheck(subjNode);
				if (realSubj instanceof TripleElement && ((TripleElement)realSubj).getSourceType() != null && 
						((TripleElement)realSubj).getSourceType().equals(TripleSourceType.ITC)) {
					returnNode = subj;
				}
			}
			te.setSubject(subj);
			patterns.add(te);
		}
		else if (subj == null) {
			// this is a triple with a need for a variable for subject
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), te.getObject(), true);
			te.setSubject(returnNode);
			// TODO when this is nested the triple (te) needs to be inserted before the returnNode is used
			patterns.add(te);
		}
		Node obj = te.getObject();
		if (obj instanceof ProxyNode) {
			UnNestingType unt = null;
			int initialPatternLength = patterns == null ? 0 : patterns.size();
			if (retiredNode != null) {
				obj = returnNode = retiredNode;
			}
			else if (((ProxyNode)obj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)obj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)obj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)obj).getProxyFor(), (ProxyNode) obj);
				}
				obj = returnNode = ((ProxyNode)obj).getReplacementNode();
			}
			else {
				Object realObj = ((ProxyNode)obj).getProxyFor();
				List<GraphPatternElement> rememberedPatterns = null;
				if (realObj instanceof BuiltinElement && isRuleThen) {
					rememberedPatterns = patterns;
					patterns = new ArrayList<GraphPatternElement>();
				}
				Object objNode;
				if (realObj instanceof TripleElement && te.getSourceType() != null && te.getSourceType().equals(TripleSourceType.VariableDefinition)) {
					unt = UnNestingType.ReturnObjectMoveAfter;
				}
				else {
					unt = UnNestingType.ReturnSubjectMoveAfter;
				}
				objNode = expandProxyNodes(patterns, realObj, isRuleThen, unt);

				// Do a check, maybe a better approach than passing in UnNestingType and passing back subj or obj... awc 11/18/2019
				if (te.getPredicate() instanceof NamedNode && ((NamedNode)te.getPredicate()).getLocalizedType() != null && 
						realObj instanceof TripleElement && ((TripleElement)realObj).getPredicate() instanceof NamedNode &&
						((NamedNode)((TripleElement)realObj).getPredicate()).getLocalizedType() != null &&
								((NamedNode)te.getPredicate()).getLocalizedType().equals(((NamedNode)((TripleElement)realObj).getPredicate()).getLocalizedType())) {
					objNode = ((TripleElement)realObj).getObject();
					unt = UnNestingType.ReturnObjectMoveBefore;
				}
				if (objNode == null && ((ProxyNode)obj).getReplacementNode() != null) {
					// This can happen because the proxy node gets processed but not returned
					objNode = ((ProxyNode)obj).getReplacementNode();
				}
				if (objNode == null && (realObj instanceof BuiltinElement 
						|| (realObj instanceof Junction && ((Junction)realObj).getLhs() instanceof BuiltinElement 
								&& ((Junction)realObj).getRhs() instanceof BuiltinElement))) {
					List<BuiltinElement> builtins = new ArrayList<BuiltinElement>();
					Node newNode = null;
					if (realObj instanceof BuiltinElement) {
						builtins.add((BuiltinElement)realObj);
						newNode = getVariableNode((BuiltinElement)realObj);
					}
					else {
						builtins.add((BuiltinElement)((Junction)realObj).getLhs());
						newNode = getVariableNode(builtins.get(0));
						builtins.add((BuiltinElement)((Junction)realObj).getRhs());
					}
					for (int i = 0; i < builtins.size(); i++) {
						BuiltinElement bi = builtins.get(i);
						if (bi.isCreatedFromInterval()) {
							bi.addArgument(0, newNode);
						}
						else {
							bi.addArgument(newNode);
						}
					}
					objNode = newNode;
					if (isRuleThen) {
						addToPremises(patterns);
						patterns = rememberedPatterns;
					}
				}
				if (objNode == null) {
					addError(new IFTranslationError("Translation to Intermediate Form failed: " + te.toString()));
				}
				((ProxyNode)obj).setReplacementNode(SadlModelProcessor.nodeCheck(objNode));
// TODO this has a problem, run on 	TestSadlIde/Sandbox/UnionClassInRule.sadl			
				retiredProxyNodes.put((GraphPatternElement) ((ProxyNode)obj).getProxyFor(), (ProxyNode)obj);
				obj = SadlModelProcessor.nodeCheck(objNode);
			}
			te.setObject(obj);
			if (!patterns.contains(te)) {
				int indexOfInterest = Math.max(0, initialPatternLength - 1);
				boolean placeBefore = !(getTarget() instanceof Rule);
				if (unt.equals(UnNestingType.ReturnObjectMoveBefore) || 
						indexOfInterest >= 0 && indexOfInterest < patterns.size() &&
						patterns.get(indexOfInterest) instanceof TripleElement &&
						((TripleElement)patterns.get(indexOfInterest)).getSourceType() != null &&
						((TripleElement)patterns.get(indexOfInterest)).getSourceType().equals(TripleSourceType.ImpliedPropertyTriple) ) {
					placeBefore = true;
				}
				if (!placeBefore) {
					patterns.add(te);
				}
				else {
					patterns.add(indexOfInterest, te);
				}
			}
		}
		else if (obj == null) {
			if (returnNode == null) {
				// if the subject was null, so returnNode is not null, don't create a variable for object and return that as
				//	it will mess up what's up the stack
				returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), obj, false);
				te.setObject(returnNode);
				if (!patterns.contains(te)) {
					patterns.add(te);
				}
			}
			else {
				// deal with a remaining null object in the triple
				VariableNode v = getVariableNode(te.getSubject(), 
						te.getPredicate(), null, false);
				if (v != null) {
					te.setObject(v);
					returnNode = v;
				}
			}
			if (strategy.equals(UnNestingType.ReturnSubjectMoveAfter)) {
				returnNode = te.getSubject();
			}
			else if (strategy.equals(UnNestingType.ReturnObjectMoveBefore) ||
					strategy.equals(UnNestingType.ReturnObjectMoveAfter)) {
				returnNode = te.getObject();
			}
		}

		if (te.getNext() != null) {
			GraphPatternElement nextGpe = te.getNext();
			te.setNext(null);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			Object nextResult = expandProxyNodes(patterns, nextGpe, isRuleThen, strategy);
			// TODO we don't need to do anything with this, right?
		}
	
		// Special case: a pivot triple ( something type something): return the subject
		if (te instanceof TripleElement && (((TripleElement)te).getPredicate()) instanceof RDFTypeNode) {
			// this is an embedded type triple; only the subject can be a subject of the higher-level pattern
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			return ((TripleElement)te).getSubject();
		}

		// This is to make sure that complete, self-contained triple elements are still added to the output
		if (!patterns.contains(te)) {
			patterns.add(te);
		}
		if (retiredNode != null) {
			return retiredNode;
		}
		return returnNode;
	}
	
	/**
	 * This method is currently just a placeholder for finding variables for reuse in built-in patterns.
	 * Currently it just creates a new variable with a new name.
	 * @param bltin
	 * @return
	 * @throws InvalidNameException 
	 * @throws TranslationException 
	 */
	protected VariableNode getVariableNode(BuiltinElement bltin) throws TranslationException, InvalidNameException {
		if (getTarget() != null) {
			
		}
		VariableNode var = new VariableNode(getNewVar());
		if (bltin.getFuncName().equals(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_BUILTIN_NAME) ||
				builtinElementWithUnittedQuantityArgReturnsUnittedQuantity(bltin)) {
			NamedNode uqType = new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI, NodeType.ClassNode);
			var.setType(modelProcessor.validateNode(uqType));

		}
		return var;
	}
	
	/**
	 * This method looks in the clauses of a Rule to see if there is already a triple matching the given pattern. If there is
	 * a new variable of the same name is created (to make sure the count is right) and returned. If not a rule or no match
	 * a new variable (new name) is created and returned.
	 * @param subject
	 * @param predicate
	 * @param object
	 * @param varIsSubject 
	 * @return
	 */
	protected VariableNode getVariableNode(Node subject, Node predicate, Node object, boolean varIsSubject) {
		VariableNode var = findVariableInTargetForReuse(subject, predicate, object);
		if (var != null) {
			return var;
		}
		if (predicate != null) {
			var = new VariableNode(getNewVar());
			Property prop = this.getTheJenaModel().getProperty(predicate.toFullyQualifiedString());
			try {
				ConceptName propcn = new ConceptName(predicate.toFullyQualifiedString());
				propcn.setType(ConceptType.RDFPROPERTY);  	// assume the most general
				if (varIsSubject) {
					// type is domain
					TypeCheckInfo dtci = getModelValidator().getTypeInfoFromDomain(propcn, prop, null);
					if (dtci != null && dtci.getTypeCheckType() != null) {
						Node tcitype = dtci.getTypeCheckType();
						if (tcitype instanceof NamedNode) {
							NamedNode defn;
							defn = new NamedNode(((NamedNode)tcitype).toFullyQualifiedString(), ((NamedNode)tcitype).getNodeType());
							var.setType(modelProcessor.validateNode(defn));
						}
						else {
							addError(new IFTranslationError("Domain type did not return a ConceptName."));
						}
					}
				}
				else {
					// type is range
					TypeCheckInfo dtci;
					dtci = getModelValidator().getTypeInfoFromRange(propcn, prop, null);
					if (dtci != null && dtci.getTypeCheckType() != null) {
						Node tcitype = dtci.getTypeCheckType();
						if (tcitype instanceof NamedNode) {
							NamedNode defn;
							defn = new NamedNode(((NamedNode)tcitype).toFullyQualifiedString(), ((NamedNode)tcitype).getNodeType());
							var.setType(modelProcessor.validateNode(defn));
						}
						else {
							addError(new IFTranslationError("Range type did not return a ConceptName."));
						}
					}
				}

			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (DontTypeCheckException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return var;
	}
	
	protected VariableNode findVariableInTargetForReuse(Node subject, Node predicate, Node object) {
		if (getTarget() instanceof Rule) {
			VariableNode var = findVariableInTripleForReuse(((Rule)getTarget()).getGivens(), subject, predicate, object);
			if (var != null) {
				return var;
			}
			var = findVariableInTripleForReuse(((Rule)getTarget()).getIfs(), subject, predicate, object);
			if (var != null) {
				return var;
			}
			var = findVariableInTripleForReuse(((Rule)getTarget()).getThens(), subject, predicate, object);
			if (var != null) {
				return var;
			}
		}
		else if (getTarget() == null) {
			Node candidate = findMatchingElementInRetiredProxyNodes(new TripleElement( subject, predicate, object));
			if (candidate instanceof VariableNode) {
				return (VariableNode)candidate;
			}
		}
		return null;
	}

	private JenaBasedSadlModelValidator getModelValidator() throws TranslationException {
		if (getModelProcessor() != null) {
			return getModelProcessor().getModelValidator();
		}
		return null;
	}

	/**
	 * Supporting method for the method above (getVariableNode(Node, Node, Node))
	 * @param gpes
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode findVariableInTripleForReuse(List<GraphPatternElement> gpes, Node subject, Node predicate, Node object) {
		if (gpes != null) {
			Iterator<GraphPatternElement> itr = gpes.iterator();
			while (itr.hasNext()) {
				GraphPatternElement gpe = itr.next();
				VariableNode var = findVariableInTargetForReuse(gpe, subject, predicate, object);
				if (var != null) {
					return var;
				}
			}
		}
		return null;
	}
	
	
	private VariableNode findVariableInTargetForReuse(GraphPatternElement gpe, Node subject, Node predicate, Node object) {
		while (gpe != null) {
			if (gpe instanceof TripleElement) {
				VariableNode var = findVariableInTripleForReuse((TripleElement)gpe, subject, predicate, object);
				if (var != null) {
					return var;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				if (args != null) {
					for (Node arg: args) {
						if (arg instanceof ProxyNode && ((ProxyNode)arg).getProxyFor() instanceof GraphPatternElement) {
							VariableNode var = findVariableInTargetForReuse((GraphPatternElement)((ProxyNode)arg).getProxyFor(), subject, predicate, object);
							if (var != null) {
								return var;
							}
						}
					}
				}
			}
			else if (gpe instanceof Junction) {
				Object lhs = ((Junction)gpe).getLhs();
				if (lhs instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)lhs, subject, predicate, object);
					if (var != null) {
						return var;
					}
				}
				else if (lhs instanceof ProxyNode && ((ProxyNode)lhs).getProxyFor() instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)((ProxyNode)lhs).getProxyFor(), subject, predicate, object);
					if (var != null) {
						return var;
					}
				}
				Object rhs = ((Junction)gpe).getRhs();
				if (rhs instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)rhs, subject, predicate, object);
					if (var != null) {
						return var;
					}
				}
				else if (rhs instanceof ProxyNode && ((ProxyNode)rhs).getProxyFor() instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)((ProxyNode)rhs).getProxyFor(), subject, predicate, object);
					if (var != null) {
						return var;
					}					
				}
			}
			gpe = gpe.getNext();
		}
		return null;
	}

	protected VariableNode findVariableInTripleForReuse(TripleElement tr, Node subject, Node predicate, Node object) {
		Node tsn = tr.getSubject();
		Node tpn = tr.getPredicate();
		Node ton = tr.getObject();
		if (subject == null && tsn instanceof VariableNode) {
			if (predicate != null && predicate.equals(tpn) && object != null && object.equals(ton)) {
				return (VariableNode) tsn;
			}
		}
		if (predicate == null && tpn instanceof VariableNode) {
			if (subject != null && subject.equals(tsn) && object != null && object.equals(ton)) {
				return (VariableNode) tpn;
			}
		}
		if (object == null && ton instanceof VariableNode) {
			if (subject != null && subject.equals(tsn) && predicate != null && predicate.equals(tpn)) {
				return (VariableNode) ton;
			}
		}
		return null;
	}
	
	protected String getNewVar() {
		String proposedName = "v" + vNum;
		while (userDefinedVariables.contains(proposedName)) {
			vNum++;
			proposedName = "v" + vNum;
		}
		vNum++;
		return proposedName;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setStartingVariableNumber(int)
	 */
	@Override
	public void setStartingVariableNumber(int vn) {
		vNum = vn;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#getVariableNumber()
	 */
	@Override
	public int getVariableNumber() {
		return vNum;
	}
	
	private Node findMatchingElementInRetiredProxyNodes(GraphPatternElement ge) {
		if (retiredProxyNodes != null) {
			if (retiredProxyNodes.get(ge) != null) {
				return retiredProxyNodes.get(ge);
			}
			else {
				if (ge instanceof TripleElement && !(((TripleElement)ge).getPredicate() instanceof RDFTypeNode)) {
					TripleElement te = (TripleElement) ge;
					Iterator<GraphPatternElement> itr = retiredProxyNodes.keySet().iterator();
					while (itr.hasNext()) {
						GraphPatternElement gpe = itr.next();
						if (gpe instanceof TripleElement && !(((TripleElement)gpe).getPredicate() instanceof RDFTypeNode)) {
							if ((te.getSubject() == null || te.getSubject().equals(((TripleElement)gpe).getSubject()))
									&& (te.getPredicate() == null || te.getPredicate().equals(((TripleElement)gpe).getPredicate()))) {
								// first condition
								if ((te.getObject() == null || te.getObject().equals(((TripleElement)gpe).getObject())) ||
										// second condition
										(((TripleElement)gpe).getObject() instanceof VariableNode) &&
										te.getObject() instanceof ProxyNode && 
										((ProxyNode)te.getObject()).getProxyFor() instanceof TripleElement &&
										((TripleElement)((ProxyNode)te.getObject()).getProxyFor()).getSubject() == null) {
									if (te.getObject() == null && te.getSubject() == null) {
										// this is too broad for some cases
										continue;
									}
									ProxyNode pn = retiredProxyNodes.get(gpe);
									return pn.getReplacementNode();
								}
							}
						}
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to handle BuiltinElements. Some builtins around triples will go away as the information moves to a modifier on the triple 
	 * @param patterns
	 * @param be
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, BuiltinElement be, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		int patternsSize = patterns != null ? patterns.size() : 0;
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(be);
		boolean isNotOfEqual = false;
		if (isRuleThen 
				&& (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign))
				&& be.getArguments() != null 
				&& be.getArguments().size() == 2
				&& be.getArguments().get(0) instanceof ProxyNode 
				&& be.getArguments().get(1) instanceof ProxyNode) {
			ProxyNode arg1PN = (ProxyNode) be.getArguments().get(0);
			ProxyNode arg2PN = (ProxyNode) be.getArguments().get(1);
			Object realArgForThen = arg1PN.getProxyFor();
			Object realArgForIfs = arg2PN.getProxyFor();
			int tripleWithObjectNullCount = 0;
			if (realArgForThen instanceof TripleElement && realArgForIfs instanceof TripleElement) {
//				// args can be TripleElement only if both are and objects are both null
				if (((TripleElement)realArgForThen).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (((TripleElement)realArgForIfs).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (tripleWithObjectNullCount == 1) {
					addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + be.toString() + "); try separating rule elements with ands."));

				}
			}
			List<GraphPatternElement> moveToIfts = new ArrayList<GraphPatternElement>();
			Object finalIfsVar = expandProxyNodes(moveToIfts, realArgForIfs, false, UnNestingType.ReturnObjectMoveBefore);
			if (finalIfsVar == null && realArgForIfs instanceof BuiltinElement) {
				Node newNode = getVariableNode((BuiltinElement)realArgForIfs);
				((BuiltinElement)realArgForIfs).addArgument(newNode);
				finalIfsVar = newNode;
				((ProxyNode)arg1PN).setReplacementNode(SadlModelProcessor.nodeCheck(finalIfsVar));
				retiredProxyNodes.put((GraphPatternElement) realArgForIfs, arg1PN);
			}
			if (realArgForThen instanceof TripleElement && ((TripleElement)realArgForThen).getObject() == null) {
				Object finalThensVar = expandProxyNodes(patterns, realArgForThen, isRuleThen, UnNestingType.ReturnObjectMoveBefore);
				((TripleElement)realArgForThen).setObject(SadlModelProcessor.nodeCheck(finalIfsVar));
				if (!patterns.contains((TripleElement)realArgForThen)) {
					patterns.add((TripleElement)realArgForThen);
				}
				if (be.getFuncName().equals("assign")) {
					((TripleElement)realArgForThen).setType(TripleModifierType.Assignment);
				}
			}
			else if (realArgForThen instanceof BuiltinElement && ((BuiltinElement)realArgForThen).getArguments() != null) {
				if (((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1) == null) {
					((BuiltinElement)realArgForThen).getArguments().set(((BuiltinElement)realArgForThen).getArguments().size() - 1, SadlModelProcessor.nodeCheck(finalIfsVar));
				}
				else if (((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1) instanceof ProxyNode &&
						((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor() instanceof TripleElement &&
						((TripleElement)((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor()).getObject() == null) {
					((TripleElement)((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor()).setObject(SadlModelProcessor.nodeCheck(finalIfsVar));
				}
				else {
					throw new TranslationException("Unhandled condition, LHS of Equal in Then isn't a BuiltinElement that needs an argument: " + realArgForThen.toString());
				}
			}
			else if (realArgForThen instanceof Junction) {
				List<GraphPatternElement> lst = junctionToList((Junction)realArgForThen);
				GraphPatternElement last = lst.remove(lst.size() - 1);
				moveToIfts.addAll(lst);
				patterns.add(last);
			}
			else if (realArgForThen instanceof GraphPatternElement){
				moveToIfts.add((GraphPatternElement) realArgForThen);
			}
			if (!addToPremises(moveToIfts)) {
				patterns.addAll(patternsSize, moveToIfts);
			}
			return null;
		}
		else if (getTarget() instanceof Rule && (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign))) {
			if (be.getArguments().size() == 2) {  // this should always be true
				if (be.getArguments().get(0) instanceof VariableNode && be.getArguments().get(1) instanceof ProxyNode) {
					Object realArg2 = ((ProxyNode)be.getArguments().get(1)).getProxyFor();
					if (realArg2 instanceof BuiltinElement) {
						((BuiltinElement)realArg2).addArgument(be.getArguments().get(0)); // the variable goes to return from arg 2 builtin and this builtin goes away
						return expandProxyNodes(patterns, realArg2, isRuleThen, UnNestingType.ReturnObjectMoveBefore);
					}
					else if (realArg2 instanceof TripleElement && ((TripleElement)realArg2).getObject() == null) {
						((TripleElement)realArg2).setObject(be.getArguments().get(0));  // the variable goes to the object of the arg 2 triple and this builtin  goes away
						return expandProxyNodes(patterns, realArg2, isRuleThen, UnNestingType.ReturnObjectMoveBefore);
					}
				}
				else if ((be.getArguments().get(1) instanceof Literal || be.getArguments().get(1) instanceof ConstantNode || 
						(be.getArguments().get(1) instanceof NamedNode && ((NamedNode)be.getArguments().get(1)).getNodeType().equals(NodeType.InstanceNode)) ||
						be.getArguments().get(1) instanceof VariableNode) && 
						be.getArguments().get(0) instanceof ProxyNode && 
						((ProxyNode)be.getArguments().get(0)).getProxyFor() instanceof TripleElement &&
						(((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject() == null ||
								(((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject() instanceof ProxyNode &&
										((ProxyNode)((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject()).getProxyFor() instanceof TripleElement &&
										((TripleElement)((ProxyNode)((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject()).getProxyFor()).getPredicate().getURI().equals(SadlConstants.SADL_IMPLICIT_MODEL_VALUE_URI) &&
										((TripleElement)((ProxyNode)((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject()).getProxyFor()).getSubject() == null &&
										((TripleElement)((ProxyNode)((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject()).getProxyFor()).getObject() == null			
										))) {
					if (objectShouldBeUnittedQuantity((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor())) {
						// make sure we have the right triples for UnittedQuantity
						if (((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject() == null) {
							if (be.getArguments().get(1) instanceof VariableNode) {
								((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setObject(be.getArguments().get(1));
							}
							else if (be.getArguments().get(1) instanceof Literal) {
								// don't have triple for value of UnittedQuantity
								TripleElement valueTriple = new TripleElement(null, new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_VALUE_URI), be.getArguments().get(1));
								((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setObject(new ProxyNode(valueTriple));
							}
						}
						else {
							// have triple for value of UnittedQuantity
							TripleElement valueTriple = (TripleElement) ((ProxyNode) ((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject()).getProxyFor();
							valueTriple.setObject(be.getArguments().get(1));
						}
					}
					else {
						((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setObject(be.getArguments().get(1));
					}
					patterns.add(((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()));
					if (be.getFuncName().equals("assign")) {
						((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setType(TripleModifierType.Assignment);
					}
					return null;
				}
			}
		}
		else if (getTarget() instanceof Rule && be.getFuncType().equals(BuiltinType.Not) && be.getArguments() != null && 
				be.getArguments().get(0) instanceof ProxyNode && ((ProxyNode)be.getArguments().get(0)).getProxyFor() instanceof BuiltinElement &&
				((BuiltinElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getFuncType().equals(BuiltinType.Equal)) {
			BuiltinElement eqb = ((BuiltinElement)((ProxyNode)be.getArguments().get(0)).getProxyFor());
			Node arg0 = eqb.getArguments().get(0);
			Node arg1 = eqb.getArguments().get(1);
			if (arg0 instanceof ProxyNode && ((ProxyNode)arg0).getProxyFor() instanceof TripleElement &&
					((arg1 instanceof ProxyNode && ((ProxyNode)arg1).getProxyFor() instanceof TripleElement &&
					((TripleElement)((ProxyNode)arg1).getProxyFor()).getObject() == null)) ||
					arg1 instanceof NamedNode){
				// this is of the form: not(is(rdf(s1,p1,v1), rdf(s2,p2,null))) where v1 might also be null
				// so we want to transform into: rdf(s1,p1,v1), not(rdf(s2,p2,v1))
				// or it is of the form: not(is(..., <NamedNode>)
				// so we want to transform into: !=(..., <NamedNode>)
				// see below
				isNotOfEqual = true;
			}
		}
		
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		List<Node> args = be.getArguments();
		for (int i = 0; args != null && i < args.size(); i++) {
			Node arg = args.get(i);
			if (arg == null) {
				VariableNode var = new VariableNode(getNewVar());
				args.set(i, var);
				returnNode = var;
			}
			else if (arg instanceof ProxyNode) {
				if (retiredNode != null) {
					args.set(i, retiredNode);
				}
				else {
					Object realArg = ((ProxyNode)arg).getProxyFor();
					Object argNode = expandProxyNodes(patterns, realArg, isRuleThen, UnNestingType.ReturnObjectMoveBefore);
					if (argNode == null) {
						if (realArg instanceof BuiltinElement) {
							if (be.getFuncType().equals(BuiltinType.Not)) {
								if (patterns.get(patterns.size() - 1).equals(realArg)) {
									// don't put in an intermediate variable for negation of a builtin--if needed the language-specific translator will need to do that
									// the call above to expandProxyNodes might have put the argNode into the patterns; if so remove it
									patterns.remove(patterns.size() - 1);
									if (isNotOfEqual) {
										if (patterns.size() >= 2 && patterns.get(patterns.size() -1) instanceof TripleElement && patterns.get(patterns.size() - 2) instanceof TripleElement) {
											// this is of the form: not(is(rdf(s1,p1,v1), rdf(s2,p2,null))) where v1 might also be null
											// so we want to transform into: rdf(s1,p1,v1), not(rdf(s2,p2,v1))
											TripleElement firstTriple = (TripleElement) patterns.get(patterns.size() - 2);
											TripleElement secondTriple = (TripleElement) patterns.get(patterns.size() - 1);
											if (!isRuleThen && !ruleThensContainsTriple(secondTriple)) {
												if (retiredProxyNodes.containsKey(secondTriple)) {
													retiredProxyNodes.remove(secondTriple);
												}
												secondTriple.setObject(firstTriple.getObject());
												secondTriple.setType(TripleModifierType.Not);
											}
											else {
												TripleElement newTriple = new TripleElement(secondTriple.getSubject(), secondTriple.getPredicate(), firstTriple.getObject());
												newTriple.setType(TripleModifierType.Not);
												patterns.add(newTriple);
											}
										}
										else {
											// this is of the form: not(is(..., <NamedNode>)
											// so we want to transform into: !=(..., <NamedNode>)
											((BuiltinElement) realArg).setFuncName("notEqual");
											patterns.add((GraphPatternElement) realArg);
										}
									}
								}
								else if (isNotOfEqual && patterns.get(patterns.size() - 1) instanceof TripleElement) {
									((TripleElement)patterns.get(patterns.size() - 1)).setType(TripleModifierType.Not);
								}
							}
							else if (((BuiltinElement)realArg).getArguments() != null &&
									getModelProcessor().isBuiltinMissingArgument(((BuiltinElement)realArg).getFuncName(), ((BuiltinElement)realArg).getArguments().size())){
								Node newNode = getVariableNode((BuiltinElement)realArg);
								((BuiltinElement)realArg).addArgument(newNode);
								argNode = newNode;
								((ProxyNode)arg).setReplacementNode(SadlModelProcessor.nodeCheck(argNode));
								retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
								args.set(i, SadlModelProcessor.nodeCheck(argNode));
							}
							else if (((BuiltinElement)realArg).getArguments() == null &&
									getModelProcessor().isBuiltinMissingArgument(((BuiltinElement)realArg).getFuncName(), 0)) {
								Node newNode = getVariableNode((BuiltinElement)realArg);
								((BuiltinElement)realArg).addArgument(newNode);
								argNode = newNode;
								((ProxyNode)arg).setReplacementNode(SadlModelProcessor.nodeCheck(argNode));
								retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
								args.set(i, SadlModelProcessor.nodeCheck(argNode));
							}
						}
						else if (realArg instanceof TripleElement) {
							// don't do anything--keep proxy if triple, negate triple if "not" builtin
							if (patterns.get(patterns.size() - 1).equals(realArg)) {
								if (be.getFuncType().equals(BuiltinType.Not)) {
									((TripleElement)realArg).setType(TripleModifierType.Not);
									return realArg;	// "not" is a unary operator, so it is safe to assume this is the only argument
								}
								else if (be.getFuncName().equals(JenaBasedSadlModelProcessor.THERE_EXISTS) && ((TripleElement)realArg).getSubject() instanceof VariableNode){
									be.getArguments().set(0, ((TripleElement)realArg).getSubject());
									patterns.add(patterns.size() - 1, be);
									return null;
								}
							}
						}
						else if (realArg instanceof Junction) {
							patterns.remove(patterns.size() - 1);
						}
						else {
							throw new TranslationException("Unexpected real argument");
						}
					}
					else {		// argNode is not null, add to retiredProxyNodes and set the arg to the argNode
						((ProxyNode)arg).setReplacementNode(SadlModelProcessor.nodeCheck(argNode));
						if (realArg instanceof GraphPatternElement) {
							retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
						}
						else {
							throw new TranslationException("Expected GraphPatternElement in ProxyNode but got " + realArg.getClass().getCanonicalName());
						}
						args.set(i, SadlModelProcessor.nodeCheck(argNode));
					}
				}
			}
		}
		if (be.getFuncName().equals(JenaBasedSadlModelProcessor.THERE_EXISTS)) {
			if (patterns.size() == 0) {
				patterns.add(be);
			}
			else {
				patterns.add(be);
			}
			returnNode = be.getArguments() != null ? be.getArguments().get(0) : null;	// this can occur during editing
		}
		else if (!isNotOfEqual) {
			removeArgsFromPatterns(patterns, be);
			patterns.add(be);
		}
		patterns = moveTriplesOutOfBuiltin(patterns, be, isRuleThen);
		if (!getModelProcessor().isIgnoreUnittedQuantities() && 
				(isExpandableComparisonOperator(be) || 
						getModelProcessor().isExpandUnittedQuantityInTranslation())) {
			patterns = expandUnittedQuantities(patterns, be, isRuleThen);
		}
		return returnNode;
	}

	private boolean isExpandableComparisonOperator(BuiltinElement be) {
		BuiltinType bit = be.getFuncType();
		if (bit.equals(BuiltinType.GT) ||
				bit.equals(BuiltinType.GTE) ||
				bit.equals(BuiltinType.LT) ||
				bit.equals(BuiltinType.LTE) ||
				bit.equals(BuiltinType.Equal) ||
				bit.equals(BuiltinType.NotEqual)) {
			return true;
		}
		return false;
	}
	
	/**
	 * Method to expand a binary operation on UnittedQuantity arguments. The TripleElement instances needed to expand 
	 * the UnittedQuantity instances or variables to patterns referencing the UnittedQuantity unit and value property
	 * values are identifed and returned. The new arguments for the value objects to be passed to the binary operator
	 * are put into the BuiltinElement's args list.
	 * @param gpe
	 * @return
	 * @throws TranslationException
	 * */
	private List<GraphPatternElement> expandUnittedQuantities(List<GraphPatternElement> patterns, BuiltinElement be,
			boolean isRuleThen) throws TranslationException {
		if (be.getArguments() == null || be.getArguments().size() != 2) {
			// all BuiltinElements of interest are binary at this point (before any 3rd output arg for a math operation is added later)
			return patterns;
		}
		if (be.getArguments().get(0) instanceof Literal && be.getArguments().get(1) instanceof Literal) {
			// if both args are Literals we don't want to do anything. If the units aren't the same that will be detected later (?? verify with test case ??).
			return patterns;
		}
		BuiltinUnittedQuantityStatus bestatus = getBuiltinElementUQStatus(be);
		boolean isComparison = isComparisonOperation(be);
		int beIdx = patterns != null ? patterns.indexOf(be) : -1;
		if (beIdx >= 0) {
			// the BuiltinElement be should be in the patterns list--otherwise it is an unexpected error
			// if the BuiltinElement be is a comparison operator it must have 2 args
			if (be.getArguments().size() != 2) {
				throw new TranslationException("Unexpectd number of BuiltinElement arguments (" + be.getArguments().size() + ")");
			}
			NamedNode valuePredNode = UtilsForJena.validateNamedNode(getModelProcessor().getConfigMgr(), getModelProcessor().getModelName() + "#" , new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_VALUE_URI));
			valuePredNode.setNodeType(NodeType.DataTypeProperty);
			NamedNode unitPredNode = UtilsForJena.validateNamedNode(getModelProcessor().getConfigMgr(), getModelProcessor().getModelName() + "#" , new NamedNode(SadlConstants.SADL_IMPLICIT_MODEL_UNIT_URI));
			unitPredNode.setNodeType(NodeType.DataTypeProperty);

			Node lhsArg = be.getArguments().get(0);
			Node rhsArg = be.getArguments().get(1);
			boolean lhsUQ = isUnittedQuantity(lhsArg);
			boolean rhsUQ = isUnittedQuantity(rhsArg);
			if (!lhsUQ && !rhsUQ) {
				return patterns;
			}
			Node newLhsArg = null;
			Node newRhsArg = null;
			TripleElement lhsArgValueTriple = null;
			TripleElement rhsArgValueTriple = null;
			String lhsUnits = null;
			String rhsUnits = null;
			Map <GraphPatternElement, GraphPatternElement> newTriples = new HashMap<GraphPatternElement, GraphPatternElement>();
			List<GraphPatternElement> toBeRemoved = new ArrayList<GraphPatternElement>();
			for (GraphPatternElement gpe : patterns) {
				if (gpe instanceof TripleElement) {
					Node currentTripleObject = ((TripleElement)gpe).getObject();
//					if (lhsUQ) {
						if (currentTripleObject.equals(lhsArg) && !valueTripleAdded(patterns, lhsArg)) {
							// the lhsArg is obtained from a triple so need to expand to get value and unit
							newLhsArg = new VariableNode(getNewVar());
							TripleElement addedTriple1 = new TripleElement(lhsArg, valuePredNode, newLhsArg);
							lhsArgValueTriple = addedTriple1;
							addNewTriple(newTriples, gpe, addedTriple1);
						}
						else if (currentTripleObject.equals(rhsArg)) {
							// the rhsArg is obtained from a triple so need to expand to get value and unit
							newRhsArg = new VariableNode(getNewVar());
							TripleElement addedTriple1 = new TripleElement(rhsArg, valuePredNode, newRhsArg);
							rhsArgValueTriple = addedTriple1;
							addNewTriple(newTriples, gpe, addedTriple1);
						} else if (isUnittedQuantity(currentTripleObject) && 
								!patternsExpandCurrentObject(patterns, currentTripleObject, valuePredNode, unitPredNode)) {					
							GraphPatternElement referencingGpe = getReferencingGpe(patterns, patterns.indexOf(gpe), currentTripleObject);
							VariableNode replacementArg = new VariableNode(getNewVar());
							TripleElement addedTriple1 = new TripleElement(currentTripleObject, valuePredNode, replacementArg);
							addNewTriple(newTriples,gpe, addedTriple1);
							// If the output of the math operation is a variable used in the comparison
							//	BuiltinElement be, then the unit of the math operation output must also
							//	be the unit of the other comparison operation argument.
							if (referencingGpe instanceof BuiltinElement && isCommonMathOperation((BuiltinElement)referencingGpe)) {
								String unit = getUnitFromMathOperation((BuiltinElement)referencingGpe);
								List<Node> args = ((BuiltinElement)referencingGpe).getArguments();
								for (int i = 0; i < args.size() - 1; i++) {
									Node arg = args.get(i);
									if (arg instanceof Literal && ((Literal)arg).getUnits() != null) {
										((Literal)arg).setUnits(null);
									}
									else if (arg instanceof NamedNode) {
										args.set(args.indexOf(arg), replacementArg);
									}
								}
								if (unit != null) {
									TripleElement addedTriple2 = new TripleElement(currentTripleObject, unitPredNode, new Literal(unit, null, LiteralType.StringLiteral));
									addNewTriple(newTriples, addedTriple1, addedTriple2);
									if (args.size() > 2 && args.get(2).equals(lhsArg)) {
										lhsUnits = unit;
									}
									else if (args.size() > 2 && args.get(2).equals(rhsArg)) {
										rhsUnits = unit;
									}
								}
							}
							replaceReferencingGpeArg(referencingGpe, currentTripleObject, replacementArg);
						}
						else if (isUnittedQuantity(((TripleElement)gpe).getSubject()) && 
								!patternsExpandCurrentObject(patterns, ((TripleElement)gpe).getSubject(), valuePredNode, unitPredNode)) {
							Node currentTripleSubject = ((TripleElement)gpe).getSubject();
							GraphPatternElement referencingGpe = getReferencingGpe(patterns, patterns.indexOf(gpe), currentTripleSubject);
							VariableNode replacementArg = new VariableNode(getNewVar());
							TripleElement addedTriple1 = new TripleElement(currentTripleSubject, valuePredNode, replacementArg);
							addNewTriple(newTriples, gpe, addedTriple1);
							replaceReferencingGpeArg(referencingGpe, currentTripleSubject, replacementArg);
						}
//					}
//					else if (rhsUQ) {
//						
//					}
				}
				else if (gpe instanceof BuiltinElement) {
//					if (lhsUQ) {
						if (((BuiltinElement)gpe).getFuncName().equals(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_BUILTIN_NAME)) {
							List<Node> uqArgs = ((BuiltinElement)gpe).getArguments();
							if (uqArgs.size() > 2 && uqArgs.get(2).equals(lhsArg)) {
								newLhsArg = uqArgs.get(0);
								lhsUnits = SadlUtils.stripQuotes(uqArgs.get(1).toString());
							}
							else if (uqArgs.size() > 2 && uqArgs.get(2).equals(rhsArg)) {
								newRhsArg = uqArgs.get(0);
								rhsUnits = SadlUtils.stripQuotes(uqArgs.get(1).toString());
							}
							toBeRemoved.add(gpe);
						}
						else if (isCommonMathOperation((BuiltinElement)gpe)) {
							// If the output of the math operation is a variable used in the
							//	BuiltinElement be, then the unit of the math operation output must also
							//	be the unit of the other comparison operation argument.
							String unit = getUnitFromMathOperation((BuiltinElement)gpe);
							if (unit != null) {
								List<Node> args = ((BuiltinElement)gpe).getArguments();
								for (int i = 0; i <= args.size() - 1; i++) {
									Node arg = args.get(i);
									if (arg instanceof Literal && ((Literal)arg).getUnits() != null) {
										((Literal)arg).setUnits(null);
									}
									else if (arg instanceof NamedNode) {
										if (arg instanceof VariableNode && bestatus.equals(BuiltinUnittedQuantityStatus.SameUnitsRequired)) {
//											TripleElement addedTriple2 = new TripleElement(arg, unitPredNode, new Literal(unit, null, LiteralType.StringLiteral));
//											if (!patterns.contains(addedTriple2)) {
//												addNewTriple(newTriples, gpe, addedTriple2);
//											}
											if (i == 0) {
												rhsUnits = unit;
											}
											else {
												lhsUnits = unit;
											}
										}
										else {
											VariableNode newArg = new VariableNode(getNewVar());
											TripleElement addedTriple1 = new TripleElement(arg, valuePredNode, newArg);
											addNewTriple(newTriples, gpe, addedTriple1);
											args.set(args.indexOf(arg), newArg);
											TripleElement addedTriple2 = new TripleElement(arg, unitPredNode, new Literal(unit, null, LiteralType.StringLiteral));
											addNewTriple(newTriples, addedTriple1, addedTriple2);
										}
									}
								}
								if (args.size() > 2 && args.get(2).equals(lhsArg)) {
									lhsUnits = unit;
								}
								else if (args.size() > 2 && args.get(2).equals(rhsArg)) {
									rhsUnits = unit;
								}
							}
						}
						if (gpe.equals(be) && isComparisonOperation(be)) {
							if (newLhsArg != null) {
								be.getArguments().set(0, newLhsArg);
							}
							else if (lhsArg instanceof Literal && ((Literal)lhsArg).getUnits() != null) {
								lhsUnits = ((Literal)lhsArg).getUnits();
								((Literal)lhsArg).setUnits(null);
							}
							if (newRhsArg != null) {
								be.getArguments().set(1,  newRhsArg);
							}
							else if (rhsArg instanceof Literal && ((Literal)rhsArg).getUnits() != null) {
								rhsUnits = ((Literal)rhsArg).getUnits();
								((Literal)rhsArg).setUnits(null);
							}
						}
//					}
//					else if (rhsUQ) {
//						
//					}
				}
			}
			if (lhsUnits != null) {
				TripleElement addedTriple2 = new TripleElement(rhsArg, unitPredNode, new Literal(lhsUnits, null, LiteralType.StringLiteral));
				addNewTriple(newTriples, rhsArgValueTriple, addedTriple2);
			}
			if (rhsUnits != null) {
				TripleElement addedTriple2 = new TripleElement(lhsArg, unitPredNode, new Literal(rhsUnits, null, LiteralType.StringLiteral));
				addNewTriple(newTriples, lhsArgValueTriple, addedTriple2);
			}
			if (lhsUnits == null && rhsUnits == null) {
				Node lhsUnitVar = getUnitVarFromPrevious(patterns, lhsArg, unitPredNode);
				Node rhsUnitVar = getUnitVarFromPrevious(patterns, rhsArg, unitPredNode);
				if (bestatus.equals(BuiltinUnittedQuantityStatus.SameUnitsRequired)) {
					// we don't know what the units are, but they need to be the same
					if (lhsUnitVar == null) {
						lhsUnitVar = rhsUnitVar;
					}
					else if (rhsUnitVar == null) {
						rhsUnitVar = lhsUnitVar;
					}
					if (lhsUnitVar == null) {
						lhsUnitVar = new VariableNode(getNewVar());
						rhsUnitVar = lhsUnitVar;
					}
				}
				else if (bestatus.equals(BuiltinUnittedQuantityStatus.DifferentUnitsAllowedOrLeftOnly)){
					if (lhsUnitVar == null) {
						lhsUnitVar = new VariableNode(getNewVar());
					}
					if (rhsUQ && rhsUnitVar == null) {
						rhsUnitVar = new VariableNode(getNewVar());
					}
				}
				TripleElement addedTriple2 = new TripleElement(lhsArg, unitPredNode, lhsUnitVar);
				addNewTriple(newTriples, lhsArgValueTriple, addedTriple2);
				if (rhsUQ) {
					TripleElement addedTriple3 = new TripleElement(rhsArg, unitPredNode, rhsUnitVar);
					addNewTriple(newTriples, rhsArgValueTriple, addedTriple3);
				}
				// cache modified be with units of lhs, rhs
				addModifiedBuiltinElementAndUnits(be, lhsUnitVar, rhsUnitVar);
			}
			for (GraphPatternElement gpe : toBeRemoved) {
				patterns.remove(gpe);
			}

			if (newTriples != null && newTriples.size() > 0) {
				Iterator<GraphPatternElement> keyItr = newTriples.keySet().iterator();
				while (keyItr.hasNext()) {
					GraphPatternElement newTriple = keyItr.next();
					if (!patterns.contains(newTriple)) {
						GraphPatternElement predecessor = newTriples.get(newTriple);
						if (predecessor != null) {
							int predecessorIdx = patterns.indexOf(predecessor);
							if (predecessorIdx < 0) {
								// predecessor apparently hasn't been added yet--find it and add it	
								GraphPatternElement predecessorSuccessor = newTriples.get(predecessor);
								int predecessorSuccessorIdx = patterns.indexOf(predecessorSuccessor);
								beIdx = patterns.indexOf(be);	// latest position
								if (predecessorSuccessorIdx > beIdx) {
									patterns.add(beIdx, predecessor);
								}
								else {
									patterns.add(predecessorSuccessorIdx + 1, predecessor);
								}	
								predecessorIdx = patterns.indexOf(predecessor);
							}
							beIdx = patterns.indexOf(be);	// latest position
							if (predecessorIdx > beIdx) {
								patterns.add(beIdx, newTriple);
							}
							else {
								patterns.add(predecessorIdx + 1, newTriple);
							}
						}
						else {
							System.out.println("What to do here?");
						}
					}
				} 
			}
		}
		else {
			throw new TranslationException("Unexpected condition: BuiltinElement is not in the list of GraphPatternElements");
		}
		return patterns;
	}

	/**
	 * Method to determine if the argument Node is already the subject of a TripleElement in patterns with "value" as the predicate
	 * @param patterns
	 * @param arg
	 * @return
	 */
	private boolean valueTripleAdded(List<GraphPatternElement> patterns, Node arg) {
		Iterator<GraphPatternElement> gpeItr = patterns.iterator();
		while (gpeItr.hasNext()) {
			GraphPatternElement gpe = gpeItr.next();
			if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject().equals(arg)) {
				if (((TripleElement)gpe).getPredicate().getURI().equals(SadlConstants.SADL_IMPLICIT_MODEL_VALUE_URI)) {
					return true;
				}
			}
		}
		return false;
	}

	private void addModifiedBuiltinElementAndUnits(BuiltinElement be, Node lhsUnitVar, Node rhsUnitVar) {
		if (modifiedBuiltinElementsAndUnits == null) {
			modifiedBuiltinElementsAndUnits = new ArrayList<BuiltinElementAndUnits>();
		}
		Node[] units = new Node[2];
		units[0] = lhsUnitVar;
		units[1] = rhsUnitVar;
		BuiltinElementAndUnits mbeau = new BuiltinElementAndUnits(be, units);
		modifiedBuiltinElementsAndUnits.add(mbeau);
	}
	
	private List<BuiltinElementAndUnits> getModifiedBuiltinElementsAndUnits() {
		return modifiedBuiltinElementsAndUnits;
	}
	
	private void clearModifiedBuiltinElementsAndUnits() {
		if (modifiedBuiltinElementsAndUnits != null) {
			modifiedBuiltinElementsAndUnits.clear();
		}
	}

	private BuiltinUnittedQuantityStatus getBuiltinElementUQStatus(BuiltinElement be) {
		BuiltinType funcType = be.getFuncType();
		String funcName = be.getFuncName();
		if (funcType.equals(BuiltinType.Plus) || funcType.equals(BuiltinType.Minus)) {
			return BuiltinUnittedQuantityStatus.SameUnitsRequired;
		}
		else if (isComparisonBuiltin(funcName)) {
			return BuiltinUnittedQuantityStatus.SameUnitsRequired;
		}
		else if (funcType.equals(BuiltinType.Multiply) || funcType.equals(BuiltinType.Divide)) {
			return BuiltinUnittedQuantityStatus.DifferentUnitsAllowedOrLeftOnly;
		}
		else if (funcType.equals(BuiltinType.Power)) {
			return BuiltinUnittedQuantityStatus.LeftUnitsOnly;
		}
		else if (funcType.equals(BuiltinType.Modulus)) {
			return BuiltinUnittedQuantityStatus.UnitsNotSupported;
		}
		else {
			return BuiltinUnittedQuantityStatus.StatusUnknown;
		}
	}
	
	/**
	 * Method to determine if the returned value of a BuiltinElement with
	 * UnittedQuantityArgs should return a UnittedQuantity
	 * @param be -- the BuiltinElement
	 * @return -- true or false
	 */
	private boolean builtinElementWithUnittedQuantityArgReturnsUnittedQuantity(BuiltinElement be) {
		if (be.getArguments() != null && be.getArguments().size() == 2) {
			boolean arg0IsUQ = isUnittedQuantity(be.getArguments().get(0));
			boolean arg1IsUQ = isUnittedQuantity(be.getArguments().get(1));
			BuiltinType funcType = be.getFuncType();
			String funcName = be.getFuncName();
			if (funcType.equals(BuiltinType.Plus) || funcType.equals(BuiltinType.Minus)) {
				if (arg0IsUQ || arg1IsUQ) {
					return true;
				}
			}
			else if (isComparisonBuiltin(funcName)) {
				return false;
			}
			else if (funcType.equals(BuiltinType.Multiply) || funcType.equals(BuiltinType.Divide)) {
				if (arg0IsUQ || arg1IsUQ) {
					return true;
				}
			}
			else if (funcType.equals(BuiltinType.Power)) {
				if (arg0IsUQ) {
					return true;
				}
			}
			else if (funcType.equals(BuiltinType.Modulus)) {
				return false;
			}
		}
		return false;
	}

	/**
	 * Method to find the unit of a variable from the patterns GraphPatternElement List.
	 * @param patterns
	 * @param rhsArg
	 * @param unitPredNode
	 * @return
	 */
	private Node getUnitVarFromPrevious(List<GraphPatternElement> patterns, Node rhsArg,
			NamedNode unitPredNode) {
		for (GraphPatternElement gpe : patterns) {
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject() != null && ((TripleElement)gpe).getSubject().equals(rhsArg) &&
						((TripleElement)gpe).getPredicate().equals(unitPredNode)) {
					return ((TripleElement)gpe).getObject();
				}
			}
		}
		return null;
	}

	/**
	 * Method to determine if the patterns List contains already contains an expansion of the currentTripleObject UnittedQuantity
	 * @param patterns
	 * @param currentTripleObject
	 * @param valuePredNode
	 * @param unitPredNode
	 * @return
	 */
	private boolean patternsExpandCurrentObject(List<GraphPatternElement> patterns, Node currentTripleObject, NamedNode valuePredNode, NamedNode unitPredNode) {
		boolean valueTripleFound = false;
		boolean unitTripleFound = false;
		for (GraphPatternElement gpe : patterns) {
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getPredicate().equals(valuePredNode)) {
					valueTripleFound = true;
				}
				else if (((TripleElement)gpe).getPredicate().equals(unitPredNode)) {
					unitTripleFound = true;
				}
				if (valueTripleFound && unitTripleFound) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Method to add a TripleElement to the Map as key and the GraphPatternElement that is to follow as value
	 * @param newTriples
	 * @param predecessorGpe
	 * @param addedTriple1
	 */
	private void addNewTriple(Map<GraphPatternElement, GraphPatternElement> newTriples, GraphPatternElement predecessorGpe, TripleElement tripleToAdd) {
		newTriples.put(tripleToAdd, predecessorGpe);
	}

	/**
	 * Method to find a {@link GraphPatternElement} in a list of such that references a given Node
	 * @param patterns
	 * @param startingAtIndex
	 * @param node
	 * @return
	 */
	private GraphPatternElement getReferencingGpe(List<GraphPatternElement> patterns, int startingAtIndex, Node node) {
		for (int i = startingAtIndex + 1; i < patterns.size(); i++) {
			GraphPatternElement gpe = patterns.get(i);
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getObject().equals(node)) {
					return gpe;
				}
				else if (((TripleElement)gpe).getSubject().equals(node)) {
					return gpe;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				for (Node arg : ((BuiltinElement)gpe).getArguments()) {
					if (arg.equals(node)) {
						return gpe;
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to replace a Node in a GrpahPatternElement with a different Node
	 * @param gpe
	 * @param currentNode
	 * @param replacementNode
	 */
	private void replaceReferencingGpeArg(GraphPatternElement gpe, Node currentNode, VariableNode replacementNode) {
		if (gpe instanceof TripleElement) {
			if (((TripleElement)gpe).getObject().equals(currentNode)) {
				((TripleElement)gpe).setObject(replacementNode);
				return;
			}
			else if (((TripleElement)gpe).getSubject().equals(currentNode)) {
				((TripleElement)gpe).setSubject(replacementNode);
				return;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			for (Node arg : ((BuiltinElement)gpe).getArguments()) {
				if (arg.equals(currentNode)) {
					List<Node> args = ((BuiltinElement)gpe).getArguments();
					args.set(args.indexOf(currentNode), replacementNode);
					return;
				}
			}
		}
	}

	/**
	 * Method to compute unit of result of common math operation for Literal arguments
	 * @param be
	 * @return
	 */
	private String getUnitFromMathOperation(BuiltinElement be) {
		String fn = be.getFuncName();
		String arg1Unit = null;
		String arg2Unit = null;
		if (be.getArguments().get(0) instanceof Literal &&
				((Literal)be.getArguments().get(0)).getUnits() != null) {
			arg1Unit = ((Literal)be.getArguments().get(0)).getUnits();
		}
		if (be.getArguments().get(1) instanceof Literal &&
				((Literal)be.getArguments().get(1)).getUnits() != null) {
			arg2Unit = ((Literal)be.getArguments().get(1)).getUnits();
		}
		if (fn.equals("+") || fn.equals("-") ) {
			if (arg1Unit != null) {
				return arg1Unit;
			}
			else if (arg2Unit != null) {
				return arg2Unit;
			}
			else {
				return null;
			}
		}
		else if (arg1Unit != null && arg2Unit != null && 
			(fn.equals("*") || fn.equals("/") || fn.equals("%") || fn.equals("^"))) {
			return arg1Unit + fn + arg2Unit;
		}
		return null;
	}

	/**
	 * Method to determine if BuiltinElement is a common math operation
	 * @param be
	 * @return
	 */
	private boolean isCommonMathOperation(BuiltinElement be) {
		return getModelProcessor().isNumericOperator(be.getFuncName());
	}

	/**
	 * Method to determine if BuiltinElement is a comparison operation
	 * @param be
	 * @return
	 */
	private boolean isComparisonOperation(BuiltinElement be) {
		return getModelProcessor().isComparisonOperator(be.getFuncName());
	}

	/**
	 * Method to determine if a Node is a UnittedQuantity
	 * @param arg
	 * @return
	 */
	private boolean isUnittedQuantity(Node arg) {
		if (arg instanceof VariableNode) {
			return isUnittedQuantityVariable(arg);
		}
		if (arg instanceof ProxyNode) {
			GraphPatternElement pf = ((ProxyNode)arg).getProxyFor();
			if (pf instanceof BuiltinElement && ((BuiltinElement)pf).getFuncName().equals(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_BUILTIN_NAME)) {
				return true;
			}
		}
		if (arg instanceof Literal && ((Literal)arg).getUnits() != null) {
			return true;
		}
		return false;
	}

	/**
	 * Method to determine if a VariableNode is a subclass of UnittedQuantity
	 * @param node
	 * @return
	 */
	private boolean isUnittedQuantityVariable(Node node) {
		if (node instanceof VariableNode && ((VariableNode)node).getType() instanceof NamedNode) {
			NamedNode varType = (NamedNode) ((VariableNode)node).getType();
			if (varType.getURI().equals(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI)) {
				return true;
			}
			OntClass varTypeCls = getTheJenaModel().getOntClass(varType.getURI());
			if (varTypeCls != null) {
				OntClass uQCls = getTheJenaModel().getOntClass(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI);
				if (uQCls != null && (varTypeCls.equals(uQCls) || varTypeCls.hasSuperClass(uQCls, false))) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean objectShouldBeUnittedQuantity(TripleElement tr) {
		OntClass propRange = getPropertyRange(tr.getPredicate());
		if (propRange != null) {
			if (propRange.getURI().equals(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI)) {
				return true;
			}
			OntClass unittedQuantitySubclass = getTheJenaModel().getOntClass(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI);
			try {
				if (SadlUtils.classIsSubclassOf(propRange, unittedQuantitySubclass, true, null)) {
					return true;
				}
			} catch (CircularDependencyException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return false;
	}

	private OntClass getPropertyRange(Node pred) {
		Property prop = getTheJenaModel().getProperty(pred.getURI());
		StmtIterator rngItr = getTheJenaModel().listStatements(prop.asResource(), RDFS.range, (RDFNode)null);
		OntClass unittedQuantitySubclass = null;
		if (rngItr.hasNext()) {
			RDFNode rng = rngItr.nextStatement().getObject();
			if (!rngItr.hasNext()) {
				if (rng.isURIResource() && rng.canAs(OntClass.class)) {
					unittedQuantitySubclass = rng.as(OntClass.class);
				}
			}
			if (unittedQuantitySubclass == null) {
				// apparently has more than 1 range, use UnittedQuantity
				unittedQuantitySubclass = getTheJenaModel().getOntClass(SadlConstants.SADL_IMPLICIT_MODEL_UNITTEDQUANTITY_URI);
			}
		}
		return unittedQuantitySubclass;
	}

	/**
	 * Method to move triples out of a builtin that should be before the builtin, e.g.,
	 * ">(height, 8000)"
	 * becomes
	 * ">(and(rdf(PathFinding2:Mountaineer, climbs, Mountain), and(rdf(Mountain, summit, Summit), and(rdf(Summit, PathFinding2:height, v0), rdf(v0, value, v1)))),8000)"
	 * but should be
	 * "and(rdf(PathFinding2:Mountaineer, climbs, Mountain), and(rdf(Mountain, summit, Summit), and(rdf(Summit, PathFinding2:height, v0), and(rdf(v0, value, v1), >(v1,8000)))))"
	 * @param patterns
	 * @param be
	 * @return
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private List<GraphPatternElement> moveTriplesOutOfBuiltin(List<GraphPatternElement> patterns, BuiltinElement be, boolean isRuleThen) throws TranslationException, InvalidNameException, InvalidTypeException {
		int beIndex = patterns.indexOf(be);
		List<Node> args = be.getArguments();
		if (args != null) {
			for (int i = 0; i < args.size(); i++) {
				Node arg = args.get(i);
				List<GraphPatternElement> gpes = null;
				if (arg instanceof ProxyNode) {
					if (((ProxyNode)arg).getProxyFor() instanceof Junction) {
						gpes = junctionToList((Junction)((ProxyNode)arg).getProxyFor());
					}
					else {
						gpes = new ArrayList<GraphPatternElement>();
						gpes.add(((ProxyNode) arg).getProxyFor());
					}
				}
				if (gpes != null) {
					List<TripleElement> toBeRemoved = null;
					for (int j = 0; j < gpes.size(); j++) {
						GraphPatternElement gpe = gpes.get(j);
						if (gpe instanceof BuiltinElement) {
							// do nothing?
						}
						else if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject() != null && ((TripleElement)gpe).getObject() != null) {
							if (toBeRemoved == null) {
								toBeRemoved = new ArrayList<TripleElement>();
							}
							toBeRemoved.add((TripleElement)gpe);
						}
					}
					if (toBeRemoved != null) {
						for (int k = toBeRemoved.size() - 1; k >= 0; k--) {
							TripleElement toRemove = toBeRemoved.get(k);
							gpes.remove(toRemove);
							patterns.add(beIndex, toRemove);
						}
					}
					GraphPatternElement newProxyFor = null;
					if (toBeRemoved != null) {
						newProxyFor = toBeRemoved.get(toBeRemoved.size() - 1);
					}
					if (newProxyFor instanceof TripleElement) {
						args.set(i, ((TripleElement) newProxyFor).getObject());
					}
					else if (newProxyFor != null) {
						((ProxyNode)arg).setProxyFor(newProxyFor);
					}
				}
			}
		}
		return patterns;
	}

	private boolean ruleThensContainsTriple(TripleElement triple) {
		if (getTarget() instanceof Rule) {
			List<GraphPatternElement> thens = ((Rule)getTarget()).getThens();
			if (thens != null) {
				for (GraphPatternElement then : thens) {
					if (graphPatternsMatch(then, triple)) {
						return true;
					}
				}
			}
		}
		return false;
	}
	
	private boolean graphPatternsMatch(GraphPatternElement gp, TripleElement tr) {
		if (gp instanceof TripleElement) {
			if (((TripleElement)gp).getSubject().equals(tr.getSubject()) &&
					((TripleElement)gp).getPredicate().equals(tr.getPredicate())) {
				return true;
			}
		}
		else if (gp instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gp).getArguments();
			for (Node arg : args) {
				if (arg instanceof ProxyNode) {
					GraphPatternElement argGp = ((ProxyNode)arg).getProxyFor();
					if (graphPatternsMatch(argGp, tr)) {
						return true;
					}
				}
			}
		}
		else if (gp instanceof Junction) {
			Object lhs = ((Junction)gp).getLhs();
			if (lhs instanceof ProxyNode) {
				if (graphPatternsMatch(((ProxyNode)lhs).getProxyFor(), tr)) {
					return true;
				}
			}
			Object rhs = ((Junction)gp).getRhs();
			if (rhs instanceof ProxyNode) {
				if (graphPatternsMatch(((ProxyNode)rhs).getProxyFor(), tr)) {
					return true;
				}
			}
		}
		return false;
	}

	private void removeArgsFromPatterns(List<GraphPatternElement> patterns, BuiltinElement be) {
		if (patterns != null && patterns.size() > 0) {
			List<Node> args = be.getArguments();
			if (args != null) {
				for (Node arg:args) {
					Object effectiveArg = arg;
					if (arg instanceof ProxyNode) {
						effectiveArg = ((ProxyNode)arg).getProxyFor();
					}
					if (effectiveArg instanceof GraphPatternElement) {
						if (patterns.contains((GraphPatternElement)effectiveArg)) {
							patterns.remove((GraphPatternElement)effectiveArg);
						}
						if (effectiveArg instanceof BuiltinElement) {
							removeArgsFromPatterns(patterns, (BuiltinElement)effectiveArg);
						}
					}
				}
			}
		}
	}

	/**
	 * Combine the argument elements with the existing Rule Ifs elements
	 * @param moveToIfts
	 * @throws TranslationException 
	 */
	protected boolean addToPremises(List<GraphPatternElement> moveToIfts) throws TranslationException {
		if (getTarget() instanceof Rule) {
			List<GraphPatternElement> ifts = ((Rule)getTarget()).getIfs();
			if (ifts == null) {
				((Rule)getTarget()).setIfs(moveToIfts);
			}
			else {
				ifts.addAll(moveToIfts);
			}
			return true;
		}
		return false;
	}

	/**
	 * This method flattens out the GraphPatternElement List so that there are no
	 * next pointers within the list.
	 * 
	 * @param list - input GraphPatternElement List that may have chained elements inside it
	 * @return - the transformed list
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private List<GraphPatternElement> flattenLinkedList(List<GraphPatternElement> list) throws InvalidNameException, InvalidTypeException, TranslationException {
		// go backwards through list so that the i index will remain valid
		for (int i = list.size() -1; i >= 0; i--) {
			GraphPatternElement element = list.get(i);
			if (element instanceof Junction) {
				flattenJunction((Junction)element);
			}
			GraphPatternElement nextElement = element.getNext();  // an internal chain
			int j = 0;
			while (nextElement != null) {
				element.setNext(null);
				list.add((1+i+(j++)),nextElement);
				element = nextElement;
				nextElement = element.getNext();
			}
		}
		return list;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#flattenJunction(com.ge.research.sadl.model.gp.Junction)
	 */
	@Override
	public void flattenJunction(Junction element) throws InvalidNameException, InvalidTypeException, TranslationException {
		Object lhs = element.getLhs();
		if (lhs instanceof Junction) {
			flattenJunction((Junction)lhs);
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			element.setLhs(SadlModelProcessor.nodeCheck(flattenJunctionSide((GraphPatternElement) lhs)));
		}
		Object rhs = element.getRhs();
		if (rhs instanceof Junction) {
			flattenJunction((Junction)rhs);
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			element.setRhs(SadlModelProcessor.nodeCheck(flattenJunctionSide((GraphPatternElement) rhs)));
		}
	}
	
	private Object flattenJunctionSide(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (gpe.getNext() != null) {
			List<GraphPatternElement> lst = new ArrayList<GraphPatternElement>();
			lst.add(gpe);
			lst = flattenLinkedList(lst);
			return lst;
		}
		return gpe;
	}
	
	private void removeDuplicateElements(Rule rule) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<GraphPatternElement> givens = rule.getGivens();
		List<GraphPatternElement> ifs = rule.getIfs();
		List<GraphPatternElement> thens = rule.getThens();
		removeDuplicates(thens, thens, true);		// remove anything duplicated in thens
//		removeDuplicates(thens, ifs, false);			// remove anything in ifs from thens
//		removeDuplicates(thens, givens, false);		// remove anything in givens from thens
		removeDuplicates(ifs, ifs, true);			// remove anything duplicated in ifs
		removeDuplicates(ifs, givens, false);		// remove anything in givens from ifs
		removeDuplicates(givens, givens, true);		// remove anything duplicated in givens
	}
	
	/**
	 * If an element in list1 is also in list2, remove the element from list1
	 * 
	 * @param list1
	 * @param list2
	 * @param bRetainFirst -- true if same lists; if same lists leave first occurance
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	protected int removeDuplicates(List<GraphPatternElement> list1, List<GraphPatternElement> list2, boolean bRetainFirst) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (list1 == null || list2 == null || list1.size() < 1 || list2.size() < 1) {
			return 0;
		}
		List<GraphPatternElement> flatList2 = getAllGPEs(list2);
		int removalCnt = 0;
		List<Integer> toBeRemoved = null;
		for (int idx2 = 0; idx2 < flatList2.size(); idx2++) {
			GraphPatternElement gpeToMatch = flatList2.get(idx2);	// this is the element we are considering for duplicate removals
			boolean foundFirst = false;
			for (int idx1 = 0; idx1 < list1.size(); idx1++) {
				GraphPatternElement gpe = list1.get(idx1);
				if (gpe.equals(gpeToMatch)) {
					if (!bRetainFirst || foundFirst) {
						if (toBeRemoved == null) {
							toBeRemoved = new ArrayList<Integer>();
						}
						if (!toBeRemoved.contains(idx1)) {
							toBeRemoved.add(idx1);
							removalCnt++;
						}
					}
					foundFirst = true;
				}
				else if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					Object[] results = removeJunctionDuplicates((Junction)gpe, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
					GraphPatternElement processedGpe = (GraphPatternElement) results[0];
					foundFirst = ((Boolean)results[1]).booleanValue();
					removalCnt = ((Integer)results[2]).intValue();
					if (!processedGpe.equals(gpe)) {
						list1.set(idx1, processedGpe);
					}
				}
			}
		}
		if (toBeRemoved != null) {
			Collections.sort(toBeRemoved);
			for (int i = (toBeRemoved.size() - 1); i >= 0; i--) {
				list1.remove(toBeRemoved.get(i).intValue());
			}
		}
		return removalCnt;
	}
	
	private Object[] removeJunctionDuplicates(Junction gpe, GraphPatternElement gpeToMatch, boolean bRetainFirst, boolean foundFirst, int removalCnt) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean lhsDuplicate = false;
		boolean rhsDuplicate = false;
		Object lhs = gpe.getLhs();
		if (lhs.equals(gpeToMatch)) {
			if(!bRetainFirst || foundFirst){
				lhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] lhsResults = removeJunctionDuplicates((Junction)lhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newLhs = (GraphPatternElement) lhsResults[0];
			foundFirst = ((Boolean)lhsResults[1]).booleanValue();
			removalCnt = ((Integer)lhsResults[2]).intValue();
			if (!newLhs.equals(lhs)) {
				gpe.setLhs(SadlModelProcessor.nodeCheck(newLhs));
			}
		}
		Object rhs = gpe.getRhs();
		if (rhs != null && rhs.equals(gpeToMatch)) {
			if (!bRetainFirst || foundFirst) {
				rhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] rhsResults = removeJunctionDuplicates((Junction)rhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newrhs = (GraphPatternElement) rhsResults[0];
			foundFirst = ((Boolean)rhsResults[1]).booleanValue();
			removalCnt = ((Integer)rhsResults[2]).intValue();
			if (!newrhs.equals(rhs)) {
				gpe.setRhs(SadlModelProcessor.nodeCheck(newrhs));
			}
		}
		Object[] results = new Object[3];
		if (lhsDuplicate) {
			results[0] = gpe.getRhs();
		}
		else if (rhsDuplicate) {
			results[0] = gpe.getLhs();
		}
		else {
			results[0] = gpe;
		}
		results[1] = Boolean.valueOf(foundFirst);
		results[2] = Integer.valueOf(removalCnt);
		return results;
	}
	
	public List<?> removeDuplicates(List<?> jct) {
		if (jct.size() == 1 && jct.get(0) instanceof Junction && 
				((Junction)jct.get(0)).getJunctionType().equals(JunctionType.Conj)) {
			try {
				JunctionList lst = junctionToList((Junction)jct.get(0));
				List<Integer> indexToRemove = new ArrayList<Integer>();
				for (int i = 0; i < lst.size(); i++) {
					Object el = lst.get(i);
					for (int j = i + 1; j < lst.size(); j++) {
						Object el2 = lst.get(j);
						if (el.equals(el2)) {
							if (!indexToRemove.contains(j)) {
								indexToRemove.add(j);
							}
						}
					}
				}
				if (indexToRemove.size() > 0) {
					for (int i = indexToRemove.size() - 1; i >= 0; i--) {
						lst.remove(indexToRemove.get(i).intValue());
					}
				}
				return listToAnd(lst);
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return jct;
	}

	public List<GraphPatternElement> getAllGPEs(List<GraphPatternElement> list) throws TranslationException {
		List<GraphPatternElement> results = null;
		for (int i = 0; list != null && i < list.size(); i++) {
			GraphPatternElement gpe = list.get(i);
			if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
				if (results != null) {
					results.addAll(junctionToList((Junction) gpe));
				}
				else {
					results = junctionToList((Junction) gpe);
				}
			}
			else {
				if (results == null) {
					results = new ArrayList<GraphPatternElement>();
				}
				results.add(gpe);
			}
		}
		if (results != null) {
			return results;
		}
		return list;
	}
	
	/**
	 * Method to convert a Junction to a List<GraphPatternElement>. Note that this method will either handle
	 * conjunction or disjunction at the top level but once the type is set the other type will not be converted
	 * to a list as if both were converted the results would be non-functional.
	 * @param gpe
	 * @return
	 * @throws TranslationException 
	 */
	public static JunctionList junctionToList(Junction gpe)
	throws TranslationException {
		JunctionList lResult = new JunctionList();
		lResult.setContext(gpe.getContext());
		lResult.setJunctionType(gpe.getJunctionType());
		List<Node> lProxies = junctionToNodeList(gpe);
		for( Node lProxy : lProxies ) {
			if( lProxy instanceof ProxyNode ) {
				lResult.add(((ProxyNode)lProxy).getProxyFor());
			}
		}
		return lResult;
	}
	
	/**
	 * Method to convert a Junction to a List<Node>. Note that this method will either handle
	 * conjunction or disjunction at the top level but once the type is set the other type will not be converted
	 * to a list as if both were converted the results would be non-functional.
	 * @param gpe
	 * @return
	 */
	public static List<Node> junctionToNodeList(Junction gpe) {
		List<Node> lResult = new ArrayList<>(1);
		if ( JunctionType.Conj.equals(gpe.getJunctionType()) ) {
			lResult = conjunctionToList(gpe);
		} else if ( JunctionType.Disj.equals(gpe.getJunctionType()) ) {
			lResult = disjunctionToList(gpe);
		} else {
			try {
				lResult.add(new ProxyNode(gpe));
			} catch ( InvalidTypeException e ) {}
		}
		return lResult;
	}
	
	public static List<Node> conjunctionToList(Junction gpe) {
		List<Node> lResult = new ArrayList<>();

		Node lhs = (Node)gpe.getLhs();
		if (lhs instanceof ProxyNode) {
			GraphPatternElement lhsProxy = ((ProxyNode)lhs).getProxyFor();
			if (lhsProxy instanceof Junction && JunctionType.Conj.equals(((Junction)lhsProxy).getJunctionType())) {
				lResult.addAll( conjunctionToList((Junction)lhsProxy) );
			} else {
				lResult.add(lhs);
			}
		} else {
			lResult.add(lhs);
		}

		Node rhs = (Node)gpe.getRhs();
		if (rhs instanceof ProxyNode) {
			GraphPatternElement rhsProxy = ((ProxyNode)rhs).getProxyFor();
			if (rhsProxy instanceof Junction && JunctionType.Conj.equals(((Junction)rhsProxy).getJunctionType())) {
				lResult.addAll( conjunctionToList((Junction)rhsProxy) );
			} else {
				lResult.add(rhs);
			}
		} else {
			lResult.add(rhs);
		}

		return lResult;
	}	
	
	public static List<Node> conjunctionToList(JunctionNode jn) throws TranslationException {
		List<Node> lResult = new ArrayList<>();

		Node lhs = (Node)jn.getLhs();
		if (lhs instanceof ProxyNode) {
			throw new TranslationException("A JunctionNode should never contain a ProxyNode");
		} else if (lhs instanceof JunctionNode) {
			lResult.addAll(conjunctionToList((JunctionNode)lhs));
		} else {
			lResult.add(lhs);
		}

		Node rhs = (Node)jn.getRhs();
		if (rhs instanceof ProxyNode) {
			throw new TranslationException("A JunctionNode should never contain a ProxyNode");
		} else if (rhs instanceof JunctionNode) {
			lResult.addAll(conjunctionToList((JunctionNode)rhs));
		} else {
			lResult.add(rhs);
		}

		return lResult;
	}

	public static List<Node> disjunctionToList(Junction gpe) {
		List<Node> lResult = new ArrayList<>();

		Node lhs = (Node)gpe.getLhs();
		if (lhs instanceof ProxyNode) {
			GraphPatternElement lhsProxy = ((ProxyNode)lhs).getProxyFor();
			if (lhsProxy instanceof Junction && JunctionType.Disj.equals(((Junction)lhsProxy).getJunctionType())) {
				lResult.addAll( disjunctionToList((Junction)lhsProxy) );
			} else {
				lResult.add(lhs);
			}
		} else {
			lResult.add(lhs);
		}

		Node rhs = (Node)gpe.getRhs();
		if (rhs instanceof ProxyNode) {
			GraphPatternElement rhsProxy = ((ProxyNode)rhs).getProxyFor();
			if (rhsProxy instanceof Junction && JunctionType.Disj.equals(((Junction)rhsProxy).getJunctionType())) {
				lResult.addAll( disjunctionToList((Junction)rhsProxy) );
			} else {
				lResult.add(rhs);
			}
		} else {
			lResult.add(rhs);
		}

		return lResult;
	}

	/**
	 * This method returns true if the argument node is bound in some other element of the rule
	 * 
	 * @param rule
	 * @param gpe
	 * @param v
	 * @return
	 */
	public static boolean variableIsBound(Rule rule, GraphPatternElement gpe,
			Node v) {
		if (v instanceof NamedNode) {
			if (((NamedNode)v).getNodeType() != null && !(((NamedNode)v).getNodeType().equals(NodeType.VariableNode))) {
				return true;
			}
		}
		// Variable is bound if it appears in a triple or as the return argument of a built-in
		List<GraphPatternElement> givens = rule.getGivens();
		if (variableIsBoundInOtherElement(givens, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (variableIsBoundInOtherElement(ifs, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (variableIsBoundInOtherElement(thens, 0, gpe, false, true, v)) {
			return true;
		}
		return false;
	}

	/**
	 * This method checks the list of GraphPatternElements to see if the specified variable is bound in these elements
	 * 
	 * @param gpes - list of GraphPatternElements to check
	 * @param startingIndex - where to start in the list
	 * @param gp - the element in which this variable appears 
	 * @param boundIfEqual - use the current element for test?
	 * @param matchMustBeAfter - must the binding be after the current element
	 * @param v - the variable Node being checked
	 * @return - true if the variable is bound else false
	 */
	public static boolean variableIsBoundInOtherElement(List<GraphPatternElement> gpes, int startingIndex, GraphPatternElement gp, 
			boolean boundIfEqual, boolean matchMustBeAfter, Node v) {
		boolean reachedSame = false;
		for (int i = startingIndex; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			while (gpe != null) {
				boolean same = gp == null ? false : gp.equals(gpe);
				if (same) {
					reachedSame = true;
				}
				boolean okToTest = false;
				if (matchMustBeAfter && reachedSame && !same) {
					okToTest = true;
				}
				if (!matchMustBeAfter && (!same || (same && boundIfEqual))) {
					okToTest = true;
				}
				if (okToTest && variableIsBound(gpe, v)) {
					return true;
				}
				gpe = gpe.getNext();
			}
		}
		return false;
	}
	
	private static boolean variableIsBound(GraphPatternElement gpe, Node v) {
		if (gpe instanceof TripleElement) {
			if ((((TripleElement)gpe).getSubject() != null &&((TripleElement)gpe).getSubject().equals(v)) || 
					(((TripleElement)gpe).getObject() != null && ((TripleElement)gpe).getObject().equals(v))) {
				return true;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			// TODO built-ins can actually have more than the last argument as output, but we can only tell this
			//	if we have special knowledge of the builtin.
			if (args != null && args.get(args.size() - 1) != null && args.get(args.size() - 1).equals(v)) {
				return true;
			}
		}
		else if (gpe instanceof Junction) {
			Object lhsobj = ((Junction)gpe).getLhs();
			if (lhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)lhsobj, v)) {
				return true;
			}
			else if (lhsobj instanceof VariableNode && ((VariableNode)lhsobj).equals(v)) {
				return true;
			}
			Object rhsobj = ((Junction)gpe).getRhs();
			if (rhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)rhsobj, v)) {
				return true;
			}
			else if (rhsobj instanceof VariableNode && ((VariableNode)rhsobj).equals(v)) {
				return true;
			}
		}
		return false;
	}

	private void setFirstOfPhrase(GraphPatternElement firstOfPhrase) {
		this.firstOfPhrase = firstOfPhrase;
	}

	protected GraphPatternElement getFirstOfPhrase() {
		return firstOfPhrase;
	}

	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setEncapsulatingTarget(java.lang.Object)
	 */
	@Override
	public void setEncapsulatingTarget(Object _encapsulatingTarget) {
	}

	public boolean isCollectNamedNodes() {
		return collectNamedNodes;
	}

	public void setCollectNamedNodes(boolean collectNamedNodes) {
		this.collectNamedNodes = collectNamedNodes;
	}

	private boolean isCruleVariableInTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) return false;
		 return cruleVariablesTypeOutput.contains(cruleVariable);
	}

	private void addCruleVariableToTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) {
			cruleVariablesTypeOutput = new ArrayList<VariableNode>();
		}
		cruleVariablesTypeOutput.add(cruleVariable);
	}
	
	private void clearCruleVariableTypedOutput() {
		if (cruleVariablesTypeOutput != null) {
			cruleVariablesTypeOutput.clear();
		}
	}

	private int addNotEqualsBuiltinsForNewCruleVariable(List<GraphPatternElement> gpes, int currentIdx, VariableNode node) throws TranslationException {
		if (cruleVariablesTypeOutput == null) {
			throw new TranslationException("This should never happen! Please report.");
		}
		int crvSize = cruleVariablesTypeOutput.size();
		if (!cruleVariablesTypeOutput.get(crvSize - 1).equals(node)) {
			throw new TranslationException("This method should always be called immediately after creating a Crules variable.");
		}
		if (crvSize == 1) {
			return currentIdx;
		}
		for (int i = crvSize - 2; i >= 0; i--) {
			VariableNode otherVar = cruleVariablesTypeOutput.get(i);
			if (otherVar.getType().equals(node.getType())) {
				if (!notEqualAlreadyPresent(gpes, otherVar, node)) {
					BuiltinElement newBi = new BuiltinElement();
					newBi.setFuncName("!=");
					newBi.setFuncType(BuiltinType.NotEqual);
					newBi.addArgument(otherVar);
					newBi.addArgument(node);
					gpes.add(++currentIdx, newBi);
				}
			}
		}
		return currentIdx;
	}

	private boolean notEqualAlreadyPresent(List<GraphPatternElement> gpes, VariableNode var1,
			VariableNode var2) {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getFuncType().equals(BuiltinType.NotEqual)) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				int found = 0;
				for (int j =0; args != null && j < args.size(); j++) {
					if (args.get(j).equals(var1)) {
						found++;
					}
					if (args.get(j).equals(var2)) {
						found++;
					}
				}
				if (found == 2) {
					return true;
				}
			}
		}
		return false;
	}

	@Override
	public JenaBasedSadlModelProcessor getModelProcessor() {
		return modelProcessor;
	}

	private void setModelProcessor(JenaBasedSadlModelProcessor modelProcessor) {
		this.modelProcessor = modelProcessor;
	}

	@Override
	public Object cook(Object obj) throws TranslationException, InvalidNameException, InvalidTypeException {
		if (obj instanceof Rule) {
			return cook((Rule)obj);
		}
		resetIFTranslator();
		setStartingVariableNumber(getVariableNumber() + getModelProcessor().getVariableNumber());
		return expandProxyNodes(obj, false, true);
	}
	
	@Override
	public Object cook(Object obj, boolean treatAsConclusion) throws TranslationException, InvalidNameException, InvalidTypeException {
		if (obj instanceof Rule) {
			return cook((Rule)obj);
		}
		resetIFTranslator();
		setStartingVariableNumber(getVariableNumber() + getModelProcessor().getVariableNumber());
		return expandProxyNodes(obj, treatAsConclusion, true);
	}
	
	public Rule cook(Rule rule) {
		try {
			// find and add missing pattern triples
			if (!rule.isMissingPatternsAdded()) {
				try {
					addMissingTriplePatterns(getTheJenaModel(), rule);
				}
				catch (TranslationException e) {
					addError(new IFTranslationError(e.getMessage()));
				}
			}
			
			// expand missing patterns and add implied and expanded properties
			List<GraphPatternElement> givens = rule.getGivens();
			if (givens != null) {
				removeUnnecessaryIsAroundTriple(givens);
				expandMissingPatterns(givens);
				addImpliedAndExpandedProperties(givens);
			}
			List<GraphPatternElement> ifs = rule.getIfs();
			if (ifs != null) {
				removeUnnecessaryIsAroundTriple(ifs);
				expandMissingPatterns(ifs);
				addImpliedAndExpandedProperties(ifs);
			}
			List<GraphPatternElement> thens = rule.getThens();
			if (thens != null) {
				removeUnnecessaryIsAroundTriple(thens);
				expandMissingPatterns(thens);
				addImpliedAndExpandedProperties(thens);
			}
			
			// expand proxy nodes
			Object results = null;
			givens = rule.getGivens();
			ifs = rule.getIfs();
			rule.setGivens(null);
			rule.setIfs(null);
			if (givens != null) {
				results = expandProxyNodes(givens, false, true);
			}
			if (results instanceof List<?>) {
				if (((List<?>)results).size() > 1) {
					results = listToAnd((List<GraphPatternElement>)results);
				}
				rule.setIfs((List<GraphPatternElement>)results);
			}			
			if (ifs != null) {
				results = expandProxyNodes(ifs, false, false);
			}
			else {
				results = null;
			}
			if (results instanceof List<?>) {
				if (((List<GraphPatternElement>)results).size() == 1 && ((List<GraphPatternElement>)results).get(0) instanceof Junction &&
						((Junction)((List<GraphPatternElement>)results).get(0)).getJunctionType().equals(JunctionType.Conj)) {	// can't do this if an OR
					results = junctionToList((Junction)((List<GraphPatternElement>)results).get(0));
				}
				if (rule.getIfs() == null) {
					rule.setIfs((List<GraphPatternElement>)results);
				}
				else {
					rule.getIfs().addAll((List<GraphPatternElement>) results);
				}
			}
			thens = rule.getThens();
			if (thens != null) {
				// this is necessary for special handling of assignments in conclusions using superclass rule capability
				results = expandProxyNodes(thens, true, false);	// first true arg means that the value to be assigned to a triple
				if (((List<GraphPatternElement>)results).size() == 1 && ((List<GraphPatternElement>)results).get(0) instanceof Junction) {
					results = junctionToList((Junction)((List<GraphPatternElement>)results).get(0));
				}
				rule.setThens((List<GraphPatternElement>)results);
			}
			// now post-process
			replaceClassesWithInstances(rule);
			replaceClassesWithVariables(rule);
			postProcessRule(rule, null);
			
		} catch (Exception e) {
			addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + e.toString() + ") while 'cooking' IntermediateForm.", null, ErrorType.WARNING));
//			e.printStackTrace();
		} 
		return rule;
	}

	private Map<NamedNode, NamedNode> findInstances(Rule rule) throws TranslationException {
		Map<NamedNode,NamedNode> classInstanceMap = findInstances(null, rule.getGivens());
		classInstanceMap = findInstances(classInstanceMap, rule.getIfs());
		classInstanceMap = findInstances(classInstanceMap, rule.getThens());
		return classInstanceMap;
	}

	private Map<NamedNode, NamedNode> findInstances(Map<NamedNode, NamedNode> classInstanceMap, List<GraphPatternElement> gpes) throws TranslationException {
		if (gpes != null) {
			for (GraphPatternElement gpe : gpes) {
				classInstanceMap = findInstances(classInstanceMap, gpe);
			}
		}
		return classInstanceMap;
	}

	private Map<NamedNode, NamedNode> findInstances(Map<NamedNode, NamedNode> classInstanceMap,
			GraphPatternElement gpe) throws TranslationException {
		if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			if (args != null) {
				for (Node n : args) {
					if (n instanceof NamedNode && ((NamedNode)n).getNodeType().equals(NodeType.InstanceNode)) {
						Node type = ((NamedNode)n).getLocalizedType();
						if (type instanceof NamedNode && ((NamedNode)type).getNodeType().equals(NodeType.ClassNode)) {
							if (classInstanceMap == null) classInstanceMap = new HashMap<NamedNode, NamedNode>();
							if (classInstanceMap.containsKey(type)) {
								throw new TranslationException("Multiple instances could match class '" + type.getName() + "'");
							}
							classInstanceMap.put((NamedNode)type, (NamedNode)n);
						}
					}
					else if (n instanceof ProxyNode) {
						classInstanceMap = findInstances(classInstanceMap, ((ProxyNode)n).getProxyFor());
					}
				}
			}
		}
		else if (gpe instanceof TripleElement) {
			Node subj = ((TripleElement)gpe).getSubject();
			if ( subj instanceof NamedNode && ((NamedNode)subj).getNodeType().equals(NodeType.InstanceNode)) {
				Node type = ((NamedNode)subj).getLocalizedType();
				if (type instanceof NamedNode && ((NamedNode)type).getNodeType().equals(NodeType.ClassNode)) {
					if (classInstanceMap == null) classInstanceMap = new HashMap<NamedNode, NamedNode>();
					if (classInstanceMap.containsKey(type)) {
						throw new TranslationException("Multiple instances could match class '" + type.getName() + "'");
					}
					classInstanceMap.put((NamedNode)type, (NamedNode)subj);
				}
			}
			else if (subj instanceof ProxyNode) {
				classInstanceMap = findInstances(classInstanceMap, ((ProxyNode)subj).getProxyFor());
			}
			Node obj = ((TripleElement)gpe).getObject();
			if ( obj instanceof NamedNode && ((NamedNode)obj).getNodeType().equals(NodeType.InstanceNode)) {
				Node type = ((NamedNode)obj).getLocalizedType();
				if (type instanceof NamedNode && ((NamedNode)type).getNodeType().equals(NodeType.ClassNode)) {
					if (classInstanceMap == null) classInstanceMap = new HashMap<NamedNode, NamedNode>();
					if (classInstanceMap.containsKey(type)) {
						throw new TranslationException("Multiple instances could match class '" + type.getName() + "'");
					}
					classInstanceMap.put((NamedNode)type, (NamedNode)obj);
				}
			}
			else if (obj instanceof ProxyNode) {
				classInstanceMap = findInstances(classInstanceMap, ((ProxyNode)obj).getProxyFor());
			}
		}
		return classInstanceMap;
	}

	private void replaceClassesWithInstances(Rule rule) throws TranslationException {
		Map<NamedNode,NamedNode> classInstanceMap = findInstances(rule);
		replaceClassesWithInstances(classInstanceMap, rule.getGivens(), false);
		replaceClassesWithInstances(classInstanceMap,rule.getIfs(), false);
		replaceClassesWithInstances(classInstanceMap,rule.getThens(), false);
	}

	private void replaceClassesWithVariables(Rule rule) throws TranslationException {
		List<VariableNode> variables = rule.getRuleVariables();
		boolean newVarCreated = false;
		if (variables == null) {
			variables = new ArrayList<VariableNode>();
			newVarCreated = true;
		}
		if (replaceClassesWithVariables(variables, rule.getGivens(), false)) {
			newVarCreated = true;
		}
		if (replaceClassesWithVariables(variables,rule.getIfs(), false)) {
			newVarCreated = true;
		}
		if (replaceClassesWithVariables(variables,rule.getThens(), false)) {
			newVarCreated = true;
		}
		if (newVarCreated && variables.size() > 0) {
			for (VariableNode var : variables) {
				rule.addRuleVariable(var);
			}
			newVarCreated = false;
		}
		if (replaceClassesWithVariables(variables, rule.getGivens(), true)) {
			newVarCreated = true;
		}
		if (replaceClassesWithVariables(variables,rule.getIfs(), true)) {
			newVarCreated = true;
		}
		if (replaceClassesWithVariables(variables,rule.getThens(), true)) {
			newVarCreated = true;
		}
		if (newVarCreated && variables.size() > 0) {
			for (VariableNode var : variables) {	
				rule.addRuleVariable(var);
				int insertionIdx = varTypedInRuleIfs(rule, var);
				if (insertionIdx >= 0) {
					rule.getIfs().add(insertionIdx, new TripleElement(var, new RDFTypeNode(), var.getType()));
				}
			}
		}
	}

	/**
	 * Method to determine if this variable already has a type triple
	 * @param rule
	 * @param var
	 * @return
	 */
	private int varTypedInRuleIfs(Rule rule, VariableNode var) {
		int firstUsed = 0;	// default is to put at beginning
		List<GraphPatternElement> ifs = rule.getIfs();
		for (GraphPatternElement gpe : ifs) {
			if (gpe instanceof TripleElement) {
				if ((((TripleElement)gpe).getSubject() != null && ((TripleElement)gpe).getSubject().equals(var)) || 
						(((TripleElement)gpe).getObject() != null && ((TripleElement)gpe).getObject().equals(var))) {
					if (firstUsed == 0) {
						// don't set it if it is already set to a first use
						firstUsed = ifs.indexOf(gpe);
					}
				}
				if (((TripleElement)gpe).getPredicate() instanceof RDFTypeNode &&
						((TripleElement)gpe).getSubject() != null && ((TripleElement)gpe).getSubject().equals(var)) {
					return -1;	// don't put it in at all
				}
			}
		}
		return firstUsed;
	}

	private void replaceClassesWithInstances(Map<NamedNode, NamedNode> classInstanceMap,
			List<GraphPatternElement> gpes, boolean b) throws TranslationException {
		if (gpes != null) {
			for (GraphPatternElement gpe : gpes) {
				replaceClassesWithInstances(classInstanceMap, gpe);
			}
		}
	}

	private boolean replaceClassesWithVariables(List<VariableNode> variables, 
			List<GraphPatternElement> gpes, boolean useOnlyClassesWithContext) throws TranslationException {
		boolean newVarCreated = false;
		if (gpes != null) {
			for (GraphPatternElement gpe : gpes) {
				if (replaceClassesWithVariables(variables, gpe, useOnlyClassesWithContext)) {
					newVarCreated = true;
				}
			}
		}
		return newVarCreated;
	}

	private void replaceClassesWithInstances(Map<NamedNode, NamedNode> classInstanceMap,
			GraphPatternElement gpe) throws TranslationException {
		if (gpe instanceof TripleElement) {
			replaceClassesWithInstances(classInstanceMap, (TripleElement)gpe);
		}
		else if (gpe instanceof BuiltinElement) {
			replaceClassesWithInstances(classInstanceMap, (BuiltinElement)gpe);
		}
	}

	private boolean replaceClassesWithVariables(List<VariableNode> variables, 
			GraphPatternElement gpe, boolean useOnlyClassesWithContext) throws TranslationException {
		if (gpe instanceof TripleElement) {
			return replaceClassesWithVariables(variables, (TripleElement)gpe, useOnlyClassesWithContext);
		}
		else if (gpe instanceof BuiltinElement) {
			return replaceClassesWithVariables(variables, (BuiltinElement)gpe, useOnlyClassesWithContext);
		}
		return false;
	}

	/**
	 * Method to replace a class argument to a BuiltinElement with the first variable of the same type (class)
	 * @param variables
	 * @param be
	 * @throws TranslationException 
	 */
	private void replaceClassesWithInstances(Map<NamedNode, NamedNode> classInstanceMap, 
			BuiltinElement be) throws TranslationException {
		List<Node> args = be.getArguments();
		int idx = 0;
		if (args != null) {
			for (Node arg : args) {
				if (arg instanceof ProxyNode) {
					replaceClassesWithInstances(classInstanceMap, ((ProxyNode)arg).getProxyFor());
				}
				else if (arg instanceof NamedNode && 
						(((NamedNode)arg).getNodeType().equals(NodeType.ClassNode) ||
						((NamedNode)arg).getNodeType().equals(NodeType.ClassListNode))) {
					NamedNode matchingInst = findInstanceOfRightType(classInstanceMap, (NamedNode)arg);
					if (matchingInst != null) {
						args.set(idx, matchingInst);
					}
				}
				idx++;
			}
		}
	}

	private NamedNode findInstanceOfRightType(Map<NamedNode, NamedNode> classInstanceMap, NamedNode arg) {
		if (classInstanceMap != null) {
			if (classInstanceMap.containsKey(arg)) {
				return classInstanceMap.get(arg);
			}
			NamedNode msc = findMatchingSubclass(classInstanceMap, arg);	
			return msc;
		}
		return null;
	}

	private NamedNode findMatchingSubclass(Map<NamedNode, NamedNode> classInstanceMap, NamedNode arg) {
		OntClass cls = getTheJenaModel().getOntClass(arg.getURI());
		if (cls != null) {
			ExtendedIterator<OntClass> scitr = cls.listSubClasses(true);
			while (scitr.hasNext()) {
				OntClass sc = scitr.next();
				NamedNode scnn = new NamedNode(sc.getURI());
				scnn.setNodeType(NodeType.ClassNode);
				if (classInstanceMap.containsKey(scnn)) {
					scitr.close();
					return classInstanceMap.get(scnn);
				}
				else {
					NamedNode other = findMatchingSubclass(classInstanceMap, scnn);
					if (other != null) {
						scitr.close();
						return other;
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to replace class subject and object in a TripleElement with the first variable of the same type (class)
	 * @param variables
	 * @param tr
	 * @throws TranslationException 
	 */
	private void replaceClassesWithInstances(Map<NamedNode, NamedNode> classInstanceMap, 
			TripleElement tr) throws TranslationException {
		if (tr.getPredicate().getURI().equals(RDF.type.getURI()) || 
				tr.getPredicate().getURI().equals(RDFS.subClassOf.getURI())) {
			return;
		}
		if (tr.getSubject() instanceof NamedNode) {  // && ((NamedNode)tr.getSubject()).getContext() == null) {
			if (((NamedNode)tr.getSubject()).getNodeType().equals(NodeType.ClassNode) ||
					((NamedNode)tr.getSubject()).getNodeType().equals(NodeType.ClassListNode)) {
				NamedNode matchingInst = findInstanceOfRightType(classInstanceMap, (NamedNode)tr.getSubject());
				if (matchingInst != null) {
					tr.setSubject(matchingInst);
				}
			}
		}
		if (tr.getObject() instanceof NamedNode) {
			if (((NamedNode)tr.getObject()).getNodeType().equals(NodeType.ClassNode) ||
					((NamedNode)tr.getObject()).getNodeType().equals(NodeType.ClassListNode)) {
				NamedNode matchingInst = findInstanceOfRightType(classInstanceMap, (NamedNode)tr.getObject());
				if (matchingInst != null) {
					tr.setObject(matchingInst);
				}
			}
		}
	}
	/**
	 * Method to replace a class argument to a BuiltinElement with the first variable of the same type (class)
	 * @param variables
	 * @param be
	 * @throws TranslationException 
	 */
	private boolean replaceClassesWithVariables(List<VariableNode> variables, 
			BuiltinElement be, boolean useOnlyClassesWithContext) throws TranslationException {
		boolean newVarCreated = false;
		List<Node> args = be.getArguments();
		int idx = 0;
		if (args != null) {
			for (Node arg : args) {
				if (arg instanceof ProxyNode) {
					newVarCreated = replaceClassesWithVariables(variables, ((ProxyNode)arg).getProxyFor(), useOnlyClassesWithContext);
				}
				else if (arg instanceof NamedNode && (!useOnlyClassesWithContext || ((NamedNode)arg).getContext() == null) &&
						(((NamedNode)arg).getNodeType().equals(NodeType.ClassNode) ||
						((NamedNode)arg).getNodeType().equals(NodeType.ClassListNode))) {
					VariableNode matchingVar = findVariableOfRightType(variables, (NamedNode)arg, !useOnlyClassesWithContext);
					if (matchingVar == null) {
						matchingVar = new VariableNode(getNewVar());
						matchingVar.setNamespace(getModelProcessor().getModelNamespace());
						matchingVar.setPrefix(getModelProcessor().getModelAlias());
						matchingVar.setType(arg);
						variables.add(matchingVar);
						newVarCreated = true;
					}
					args.set(idx, matchingVar);
				}
				idx++;
			}
		}
		return newVarCreated;
	}

	/**
	 * Method to replace class subject and object in a TripleElement with the first variable of the same type (class)
	 * @param variables
	 * @param tr
	 * @throws TranslationException 
	 */
	private boolean replaceClassesWithVariables(List<VariableNode> variables, 
			TripleElement tr, boolean matchOnSubclasses) throws TranslationException {
		boolean newVarCreated = false;
		if (tr.getPredicate().getURI().equals(RDF.type.getURI()) || 
				tr.getPredicate().getURI().equals(RDFS.subClassOf.getURI())) {
			return newVarCreated;
		}
		if (tr.getSubject() instanceof NamedNode) {  // && ((NamedNode)tr.getSubject()).getContext() == null) {
			if (((NamedNode)tr.getSubject()).getNodeType().equals(NodeType.ClassNode) ||
					((NamedNode)tr.getSubject()).getNodeType().equals(NodeType.ClassListNode)) {
				VariableNode matchingVar = findVariableOfRightType(variables, (NamedNode)tr.getSubject(), matchOnSubclasses);
				if (matchingVar == null && matchOnSubclasses) {
					// see if there is already a variable of a superclass that can be revised to be this class and used
					VariableNode superclassVar = findSuperclassVariable(variables, (NamedNode)tr.getSubject(), matchOnSubclasses);
					if (superclassVar != null) {
						superclassVar.changeType((NamedNode)tr.getSubject());
						matchingVar = superclassVar;
					}
					else {
						matchingVar = new VariableNode(getNewVar());
						matchingVar.setNamespace(getModelProcessor().getModelNamespace());
						matchingVar.setPrefix(getModelProcessor().getModelAlias());
						matchingVar.setType(((NamedNode)tr.getSubject()));
						variables.add(matchingVar);
						newVarCreated = true;
					}
				}
				if (matchingVar != null) {
					tr.setSubject(matchingVar);
				}
			}
		}
		if (tr.getObject() instanceof NamedNode) {
			if (((NamedNode)tr.getObject()).getNodeType().equals(NodeType.ClassNode) ||
					((NamedNode)tr.getObject()).getNodeType().equals(NodeType.ClassListNode)) {
				VariableNode matchingVar = findVariableOfRightType(variables, (NamedNode)tr.getObject(), matchOnSubclasses);
				if (matchingVar != null && tr.getSubject().equals(matchingVar)) {
					// this is the definition of an existing variable
					return newVarCreated;
				}
				if (matchingVar == null && matchOnSubclasses) {
					// see if there is already a variable of a superclass that can be revised to be this class and used
					VariableNode superclassVar = findSuperclassVariable(variables, (NamedNode)tr.getObject(), matchOnSubclasses);
					if (superclassVar != null) {
						superclassVar.changeType((NamedNode)tr.getSubject());
						matchingVar = superclassVar;
					}
					else {
						matchingVar = new VariableNode(getNewVar());
						matchingVar.setNamespace(getModelProcessor().getModelNamespace());
						matchingVar.setPrefix(getModelProcessor().getModelAlias());
						matchingVar.setType(((NamedNode)tr.getObject()));
						variables.add(matchingVar);
					}
				}
				if (matchingVar != null) {
					tr.setObject(matchingVar);
				}
			}
		}
		return newVarCreated;
	}

	private VariableNode findVariableOfRightType(List<VariableNode> variables, 
			NamedNode nn, boolean matchOnSubclasses) {
		String classUri = nn.getURI();
		if (variables != null) {
			for (VariableNode v : variables) {
				if (v.getType() != null && v.getType().getURI().equals(classUri)) {
					return v;
				}
			}
			if (matchOnSubclasses) {
				OntClass cls = getTheJenaModel().getOntClass(classUri);
				VariableNode subclassV = findVariableOfRIghtTypeInSubclass(cls, variables);
				if (subclassV != null) {
					return subclassV;
				}
			}
		}
		return null;
	}
	
	private VariableNode findVariableOfRIghtTypeInSubclass(OntClass cls, List<VariableNode> variables) {
		if (cls != null) {
			ExtendedIterator<OntClass> scitr = cls.listSubClasses();
			while (scitr.hasNext()) {
				OntClass sc = scitr.next();
				for (VariableNode v : variables) {
					if (sc.isURIResource() && sc.getURI().equals(v.getType().getURI())) {
						scitr.close();
						return v;
					}
				}
				VariableNode lowerV = findVariableOfRIghtTypeInSubclass(sc, variables);
				if (lowerV != null) {
					return lowerV;
				}
			}	
		}
		return null;
	}

	private VariableNode findSuperclassVariable(List<VariableNode> variables, NamedNode nn,
			boolean matchOnSubclasses) {
		// Note: this model is not an inferred model so transitive closure over class hierarchy cannot be assumed
		String classUri = nn.getURI();
		if (variables != null) {
			for (VariableNode v : variables) {
				OntClass cls = getTheJenaModel().getOntClass(classUri);
				if (cls != null && v.getType() != null) {
					if (findSuperclassVariable(v, cls)) {
						return v;
					}
				}
			}
		}
		return null;
	}

	private boolean findSuperclassVariable(VariableNode v, OntClass cls) {
		ExtendedIterator<OntClass> scitr = cls.listSuperClasses(true);
		while (scitr.hasNext()) {
			OntClass sc = scitr.next();
			if (sc.isURIResource() && sc.getURI().equals(v.getType().getURI())) {
				scitr.close();
				return true;
			}
			else {
				if (findSuperclassVariable(v, sc)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Method to expand the missing patterns in a set of GraphPatternElements
	 * @param gpes
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected void expandMissingPatterns(List<GraphPatternElement> gpes) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (gpes != null) {
			for (int i = gpes.size() - 1; i >= 0; i--) {
				List<GraphPatternElement> expansion = null;
				GraphPatternElement gpe = gpes.get(i);
				if (gpe instanceof Junction) {
					expansion = expandMissingPatterns(gpes, i, (Junction)gpe);
				}
				else if (gpe instanceof TripleElement) {
					expansion = expandMissingPatterns(gpes, i, (TripleElement)gpe);
				}
				else if (gpe instanceof BuiltinElement) {
					expansion = expandMissingPatterns(gpes, i, (BuiltinElement)gpe);
				}
				if (expansion != null) {
					for (int j = 0; j < expansion.size(); j++) {
						if (j == 0) {
							gpes.set(i, expansion.get(j));
						}
						else {
							gpes.add(i + 1, expansion.get(j));
						}
					}
				}
			}
		}
	}
	
	/**
	 * Method to expand the missing patterns in a particular GraphPatternElement in the context of the set of GraphPatternElements
	 * @param gpes
	 * @param gpesIdx
	 * @param gpe
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private List<GraphPatternElement> expandMissingPatterns(List<GraphPatternElement> gpes, int gpesIdx, GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<GraphPatternElement> results = null;
		if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			if (args != null) {
				for (int i = 0; i < args.size(); i++) {
					Node arg = args.get(i);
					ProxyNode replacement = expandMissingPatterns(gpes, gpesIdx, arg);
					if(replacement != null) {
						args.set(i, replacement);
					}
				}
				if (((BuiltinElement)gpe).getFuncType().equals(BuiltinType.Not)) {
					if (args.size() == 1) {
						// this should always be true
						if (args.get(0) instanceof ProxyNode && ((ProxyNode)args.get(0)).getProxyFor() instanceof TripleElement) {
							((TripleElement)((ProxyNode)args.get(0)).getProxyFor()).setType(TripleModifierType.Not);
							replaceGraphPatternElement(gpes, gpe, ((ProxyNode)args.get(0)).getProxyFor());
						}
					}
				}
			}
		}
		else if (gpe instanceof TripleElement) {
			Node subj = ((TripleElement) gpe).getSubject();
			if (subj instanceof NamedNode) {
				if (getMissingTripleByResource(getResourceFromNamedNode(((NamedNode)subj))) != null) {
					List<TripleElement> mps = getMissingTripleByResource(getResourceFromNamedNode(((NamedNode)subj)));
					((NamedNode)subj).setMissingPatterns(null);
					results = new ArrayList<GraphPatternElement>();
					results.addAll(mps);
					results.add(gpe);
				}
			}
			else if (subj instanceof ProxyNode) {
				expandMissingPatterns(gpes, gpesIdx, subj);
			}
			Node pred = ((TripleElement) gpe).getPredicate();
			if (pred instanceof NamedNode) {
				if (getMissingTripleByResource(getPropertyFromNamedNode(((NamedNode)pred))) != null) {
					List<TripleElement> mps = getMissingTripleByResource(getPropertyFromNamedNode(((NamedNode)pred)));
					if (((NamedNode)pred).getMissingPatterns() == null) {
						((NamedNode)pred).setMissingPatterns(mps);
					}
					if (results == null) {
						results = new ArrayList<GraphPatternElement>();
					}
					results.addAll(mps);
					results.add(gpe);
				}
			}
		}
		else if (gpe instanceof Junction) {
			 Object lhs = ((Junction)gpe).getLhs();
			 Object rhs = ((Junction)gpe).getRhs();
			 if (lhs instanceof Node) {
				 expandMissingPatterns(gpes, gpesIdx, (Node)lhs);
			 }
			 if (rhs instanceof Node) {
				 expandMissingPatterns(gpes, gpesIdx, (Node)rhs);
			 }
		}
		return results;
	}
	
	/**
	 * Method to expand the missing patterns associated with a particular Node in a particular GraphPatternElement in the context of a set of GraphPatternElements
	 * @param gpes
	 * @param gpesIdx
	 * @param arg
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected ProxyNode expandMissingPatterns(List<GraphPatternElement> gpes, int gpesIdx, Node arg) throws InvalidNameException, InvalidTypeException, TranslationException {
		ProxyNode replacement = null;
		if (arg instanceof ProxyNode) {
			List<GraphPatternElement> results = expandMissingPatterns(gpes, gpesIdx, (GraphPatternElement)((ProxyNode)arg).getProxyFor());
			if (results != null) {
				((ProxyNode)arg).setProxyFor(listToAnd(results).get(0));
			}
			if (((ProxyNode)arg).getProxyFor() instanceof BuiltinElement) {
				BuiltinElement be = (BuiltinElement) ((ProxyNode)arg).getProxyFor();
				if (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign)) {
					List<Node> args = be.getArguments();
					if (args.size() == 2) {
						// this should always be true
						if (args.get(0) instanceof ProxyNode && ((ProxyNode)args.get(0)).getProxyFor() instanceof TripleElement && 
								((TripleElement)((ProxyNode)args.get(0)).getProxyFor()).getObject() == null && 
								args.get(1) instanceof NamedNode) {
							((TripleElement)((ProxyNode)args.get(0)).getProxyFor()).setObject(SadlModelProcessor.nodeCheck(args.get(1)));
							((ProxyNode)arg).setProxyFor(((ProxyNode)args.get(0)).getProxyFor());
							if (be.getFuncType().equals(BuiltinType.Assign)) {
								((TripleElement)((ProxyNode)args.get(0)).getProxyFor()).setType(TripleModifierType.Assignment);
							}
						}
					}
				}
			}
		}
		else if (arg instanceof NamedNode) {
			if (((NamedNode)arg).getMissingTripleReplacement() != null) {
				replacement = ((NamedNode)arg).getMissingTripleReplacement();
				// As the replacement triple is being added explicitly to the graph patterns, remove it from the node
				((NamedNode)arg).setMissingTripleReplacement(null);
				Object pf = replacement.getProxyFor();
				if (pf instanceof GraphPatternElement) {
					List<GraphPatternElement> results = expandMissingPatterns(gpes, gpesIdx, (GraphPatternElement)pf);
					if (results != null) {
						replacement.setProxyFor(listToAnd(results).get(0));
					}
				}
			}
			if (getMissingTripleByResource(getPropertyFromNamedNode(((NamedNode)arg))) != null) {
				List<TripleElement> mps = getMissingTripleByResource(getPropertyFromNamedNode(((NamedNode)arg)));
				if (((NamedNode)arg).getMissingPatterns() == null) {
					((NamedNode)arg).setMissingPatterns(mps);
				}
				List<GraphPatternElement> retgpes = new ArrayList<GraphPatternElement>();
				retgpes.addAll(mps);
				if (replacement != null) {
					retgpes.add((GraphPatternElement) replacement.getProxyFor());
					replacement.setProxyFor(listToAnd(retgpes).get(0));
				}
				else {
					replacement = (ProxyNode) SadlModelProcessor.nodeCheck(retgpes.size() == 1 ? retgpes.get(0) : listToAnd(retgpes).get(0));
				}
				((NamedNode)arg).setMissingPatterns(null);
			}
		}
		return replacement;
	}
	
	private boolean replaceGraphPatternElement(List<GraphPatternElement> gpes, GraphPatternElement gpe,
			GraphPatternElement newGpe) throws TranslationException {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement thisGpe = gpes.get(i);	
			if (thisGpe.equals(gpe)) {
				int idx = gpes.indexOf(gpe);
				gpes.set(idx, newGpe);
				return true;
			}
			else if (thisGpe instanceof Junction) {
				Object lhs = ((Junction)thisGpe).getLhs();
				Object rhs = ((Junction)thisGpe).getRhs();
				if (!(lhs instanceof Node)) {
					throw new TranslationException("LHS of Junction should be a Node");
				}
				if (!(rhs instanceof Node)) {
					throw new TranslationException("RHS of Junction should be a Node");
				}
				if (replaceGraphPatternElement((ProxyNode)lhs, gpe, newGpe)) {
					return true;
				}
				if (replaceGraphPatternElement((ProxyNode)rhs, gpe, newGpe)) {
					return true;
				}
			}
		}
		
		return false;
	}

	private boolean replaceGraphPatternElement(ProxyNode pn, GraphPatternElement gpe, GraphPatternElement newGpe) {
		if (pn.getProxyFor().equals(gpe)) {
			pn.setProxyFor(newGpe);
			return true;
		}
		return false;
	}

	/**
	 * Method to take an ontology model and a requirement and find and add any missing triples to the
	 * conditions, the conclusions, and the variable definitions, using any local restrictions in the
	 * context or the requirement and the ontology to inform the search
	 * @param model -- the ontology model
	 * @param req -- the rquirement
	 * @return -- true if successful else false (false includes if it has already been done for this requirement
	 * @throws CircularDependencyException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 * @throws InvalidNameException
	 * @throws MultiplePathsFoundException 
	 * @throws PathFindingException 
	 */
	public boolean addMissingTriplePatterns(OntModel model, Rule rule) throws CircularDependencyException, InvalidTypeException, TranslationException, InvalidNameException, PathFindingException, MultiplePathsFoundException {
		if (!rule.isMissingPatternsAdded()) {
			PathFinder pf = findReplacementTriplesAndPotentialMissingPaths(model, rule);
			Map<Resource, Map<Resource, DirectedPath>> solns = pf.getSolutions();
			if (solns != null) {
				Iterator<org.apache.jena.rdf.model.Resource> ksitr = solns.keySet().iterator();
				while (ksitr.hasNext()) {
					Resource key = ksitr.next();
					Map<Resource, DirectedPath> soln = solns.get(key);
					Iterator<Resource> ksitr2 = soln.keySet().iterator();
					while (ksitr2.hasNext()) {
						try {
							assignMissingPattern(pf, key, soln.get(ksitr2.next()));
						} catch (CloneNotSupportedException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
				applyMissingPatternsToAllOccurrencesOfNamedNode(rule);
			}
			rule.setMissingPatternsAdded(true);
			setPreviousAddMissingTriplePatternsReturnValue(rule, true);
			return true;
		}
		return getPreviousAddMissingTriplePatternsReturnValue(rule);
	}
	
	/**
	 * Method to get the returned value of a previous call to addMissingTriplePatterns for a given CtxRequirement
	 * @param rule
	 * @return
	 */
	protected boolean getPreviousAddMissingTriplePatternsReturnValue(Rule rule) {
		if (addMissingTriplePatternsReturnValueByReqName != null && 
				addMissingTriplePatternsReturnValueByReqName.containsKey(rule.getUri())) {
			return addMissingTriplePatternsReturnValueByReqName.get(rule.getUri());
		}
		return false;
	}
	
	/**
	 * Method to set the returned value of a call to addMissingTriplePatterns for a given CtxRequirement
	 * @param rule
	 * @param retVal
	 */
	protected void setPreviousAddMissingTriplePatternsReturnValue(Rule rule, boolean retVal) {
		if (addMissingTriplePatternsReturnValueByReqName == null) {
			addMissingTriplePatternsReturnValueByReqName = new HashMap<String, Boolean>();
		}
		addMissingTriplePatternsReturnValueByReqName.put(rule.getUri(), retVal);
	}

	/**
	 * Method to add the requisite missing patterns to all occurrences of a NamedNode.
	 * @param req
	 * @throws TranslationException
	 */
	private void applyMissingPatternsToAllOccurrencesOfNamedNode(Rule rule) throws TranslationException {
		applyMissingPatternsToGraphPatternElements(rule.getGivens());
		applyMissingPatternsToGraphPatternElements(rule.getIfs());
		applyMissingPatternsToGraphPatternElements(rule.getThens());
	}

	/**
	 * Method to apply missing patterns to a list of GraphPatternElements
	 * @param gpes
	 * @throws TranslationException
	 */
	private void applyMissingPatternsToGraphPatternElements(List<GraphPatternElement> gpes) throws TranslationException {
		if(gpes == null) {
			return;
		}
		for (GraphPatternElement gpe : gpes) {
			applyMissingPatternsToGraphPatternElement(gpe);
		}
	}

	/**
	 * Method to apply missing patterns to a single GraphPatternElement
	 * @param gpe
	 * @throws TranslationException
	 */
	protected void applyMissingPatternsToGraphPatternElement(GraphPatternElement gpe) throws TranslationException {
		if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getArguments() != null) {
			for (Node arg : ((BuiltinElement)gpe).getArguments()) {
				applyMissingPatternsToNode(gpe, arg);
			}
		}
		else if (gpe instanceof TripleElement) {
			applyMissingPatternsToNode(gpe, ((TripleElement)gpe).getSubject());
			applyMissingPatternsToNode(gpe, ((TripleElement)gpe).getPredicate());
			applyMissingPatternsToNode(gpe, ((TripleElement)gpe).getObject());
		}
		else if (gpe instanceof Junction) {
			Object lhs = ((Junction)gpe).getLhs();
			if (lhs instanceof Node) {
				applyMissingPatternsToNode(gpe, (Node)lhs);
			}
			Object rhs = ((Junction)gpe).getRhs();
			if (rhs instanceof Node) {
				applyMissingPatternsToNode(gpe, (Node) rhs);
			}
		}
		
	}

	/**
	 * Method to apply missing patterns to a single Node in the context of a GraphPatternElement
	 * @param gpe
	 * @param node
	 * @throws TranslationException
	 */
	private void applyMissingPatternsToNode(GraphPatternElement gpe, Node node) throws TranslationException {
		if (node instanceof VariableNode) {
			List<Node> defns = ((VariableNode)node).getDefinitions();
			if (defns != null) {
				for (Node defn : defns) {
					if (defn instanceof ProxyNode && ((ProxyNode)defn).getProxyFor() instanceof GraphPatternElement) {
						applyMissingPatternsToVariableDefinition(node, (GraphPatternElement) ((ProxyNode)defn).getProxyFor());
					}
					else {
						continue;
					}
				}
			}
		}
		else if (node instanceof NamedNode) {
			if (((NamedNode)node).getMissingPatterns() == null) {
				List<TripleElement> mtrs = null;
				if (((NamedNode)node).getMissingTripleReplacement() != null) {
					Node effectiveNode = ((TripleElement)((NamedNode)node).getMissingTripleReplacement().getProxyFor()).getSubject();
					mtrs = getMissingTripleByResource(getResourceFromNamedNode((NamedNode)effectiveNode));
				}
				else {
					mtrs = getMissingTripleByResource(getResourceFromNamedNode((NamedNode)node));					
				}
				if (mtrs != null) {
					for (TripleElement tr : mtrs) {
						if (gpe == null || !tr.equals(gpe)) {
							((NamedNode)node).addMissingPattern(tr);
							addNamedNodeToCleanOfMissingPatternsWhenCooked((NamedNode)node);
						}
					}
				}
			}
			else {
				int i = 0;	// should these be removed?
			}
		}
		else if (node instanceof ProxyNode) {
			applyMissingPatternsToGraphPatternElement((GraphPatternElement) ((ProxyNode)node).getProxyFor());
		}
		checkMissingTripleSubjectObjectAlignment(node);
	}

	/**
	 * Method to retrieve registered missing patterns by the Resource of the NamedNode to which they apply
	 * @param rsrc
	 * @return
	 */
	protected List<TripleElement> getMissingTripleByResource(Resource rsrc) {
		if (missingTriplesByResource != null) {
			return missingTriplesByResource.get(rsrc);
		}
		return null;
	}

	/**
	 * Method to apply missing patterns to a VariableNode's GraphPatternElement definition
	 * @param node
	 * @param defn
	 * @throws TranslationException
	 */
	protected void applyMissingPatternsToVariableDefinition(Node node, GraphPatternElement defn) throws TranslationException {
		if (defn instanceof BuiltinElement && ((BuiltinElement)defn).getArguments() != null) {
			for (Node arg : ((BuiltinElement)defn).getArguments()) {
				if (!node.equals(arg)) {
					applyMissingPatternsToVariableDefinition(node, arg);
				}
			}
		}
		else if (defn instanceof TripleElement) {
			if (!node.equals(((TripleElement)defn).getSubject())) {
				applyMissingPatternsToVariableDefinition(node, ((TripleElement)defn).getSubject());
			}
			if (!node.equals(((TripleElement)defn).getPredicate())) {
				applyMissingPatternsToVariableDefinition(node, ((TripleElement)defn).getPredicate());
			}
			if (!node.equals(((TripleElement)defn).getObject())) {
				applyMissingPatternsToVariableDefinition(node, ((TripleElement)defn).getObject());
			}
		}
		else if (defn instanceof Junction) {
			Object lhs = ((Junction)defn).getLhs();
			if (lhs instanceof Node && !node.equals(lhs)) {
				applyMissingPatternsToVariableDefinition(node, (Node) lhs);
			}
			Object rhs = ((Junction)defn).getRhs();
			if (rhs instanceof Node && !node.equals(rhs)) {
				applyMissingPatternsToVariableDefinition(node, (Node) rhs);
			}
		}
	}
	
	/**
	 * Method to apply missing patterns to a VariableNode's Node definition
	 * @param node
	 * @param defnPart
	 * @throws TranslationException
	 */
	private void applyMissingPatternsToVariableDefinition(Node node, Node defnPart) throws TranslationException {
		if (defnPart instanceof ProxyNode) {
			applyMissingPatternsToVariableDefinition(node, (GraphPatternElement) ((ProxyNode)defnPart).getProxyFor());
		}
		else {
			applyMissingPatternsToNode(null, defnPart);
		}
	}

	protected OntModel getTheJenaModel() {
		return theJenaModel;
	}

	/**
	 * Entry method for recursive calls to assignMissingPattern_Recursive
	 * @param pf 
	 * @param directedPath
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 * @throws CloneNotSupportedException 
	 */
	protected void assignMissingPattern(PathFinder pf, Resource key, DirectedPath directedPath) throws InvalidNameException, InvalidTypeException, TranslationException, CloneNotSupportedException {
		DirectedPath lastPath = directedPath.getLastDirectedPathInChain();
		if (lastPath.getObject() != null) {
			NamedNode theNode = getNamedNodeFromResourceMap((Resource) lastPath.getObject());
			List<Node> theReplacements = pf.getReplacements(theNode);
			if (theReplacements != null) {
				for (Node aReplacement : theReplacements) {
					if (aReplacement instanceof NamedNode) {
						assignMissingPatternsToNamedNode(pf, (NamedNode) aReplacement, directedPath);
						checkMissingTripleSubjectObjectAlignment(aReplacement);
					}
				}
			}
			else {
				assignMissingPatternsToNamedNode(pf, theNode, directedPath);
				checkMissingTripleSubjectObjectAlignment(theNode);
			}
		}
	}
	
	/**
	 * Method to check that missing triples are properly ordered
	 * @param node
	 */
	protected void checkMissingTripleSubjectObjectAlignment(Node node) {
		if (node instanceof NamedNode) {
			NamedNode nn = (NamedNode) node;
			List<TripleElement> mps = nn.getMissingPatterns();
			if (mps != null) {
				Node lastObj = null;
				TripleElement lastTr = null;
				for (TripleElement tr : mps) {
					Node thisSubj = tr.getSubject();
					if (lastObj != null && !thisSubj.equals(lastObj) ) {
						System.err.println("Missing triple object-subject mismatch: " + lastTr.toString() + " --> " + tr.toString());
					}
					lastObj = tr.getObject();
					lastTr = tr;
				}
				ProxyNode mtr = nn.getMissingTripleReplacement();
				if (mtr != null) {
					GraphPatternElement mtrgpe = (GraphPatternElement) mtr.getProxyFor();
					if (mtrgpe instanceof TripleElement) {
						Node thisSubj = ((TripleElement)mtrgpe).getSubject();
						if (lastObj != null && !thisSubj.equals(lastObj) ) {
							System.err.println("Missing triple object-subject mismatch: " + lastTr.toString() + " --> " + mtrgpe.toString());
						}
					}
				}
			}
		}
	}

	/**
	 * Method to remove missing triples from all NamedNodes to which they have been added
	 * after cooking is completed.
	 */
	protected void cleanMissingPatternsFromNamedNodes() {
		List<NamedNode> nntc = getNamedNodesToCleanOfMissingPatternsWhenCooked();
		if (nntc != null) {
			for (NamedNode nn : nntc) {
				nn.setMissingTripleReplacement(null);
				nn.setMissingPatterns(null);
			}
		}
	}

	/**
	 * Method to assign a missing pattern, expressed as a DirectedPath, to a NamedNode 
	 * @param pf
	 * @param nnAttachTo
	 * @param directedPath
	 * @throws TranslationException
	 * @throws CloneNotSupportedException
	 */
	private void assignMissingPatternsToNamedNode(PathFinder pf, NamedNode nnAttachTo, DirectedPath directedPath) throws TranslationException, CloneNotSupportedException {
		org.apache.jena.rdf.model.Resource un = directedPath.getSubject();
		NamedNode unn = (NamedNode) getNamedNodeFromResourceMap(un).clone();
		unn.setMissingPatterns(null);
		org.apache.jena.rdf.model.Resource ln = directedPath.getObject();
		NamedNode lnn = (NamedNode) getNamedNodeFromResourceMap(ln).clone();
		lnn.setMissingPatterns(null);
		Object prop = directedPath.getConnection();
		NamedNode pnn;
		if (prop instanceof Property) {
			pnn = getNamedNodeFromResourceMap((Property)prop);
			if (directedPath.getExistingGraphPattern() != null) {
				GraphPatternElement container = directedPath.getExistingGraphPattern();
				nnAttachTo.addMissingPattern((TripleElement) container);
				addNamedNodeToCleanOfMissingPatternsWhenCooked(nnAttachTo);
				registerMissingPatternByResource(getResourceFromNamedNode(nnAttachTo), (TripleElement)container);
			}
			else if (!pnn.getURI().equals(RDFS.subClassOf.getURI())){
				// subClassOf triples are not explicitly included in the missing triples (not ever? not when they are both root nodes....)
				TripleElement newtr = new TripleElement(unn, pnn, lnn);
				newtr.setSourceType(TripleSourceType.MissingPropertyTriple);
				nnAttachTo.addMissingPattern(newtr);
				addNamedNodeToCleanOfMissingPatternsWhenCooked(nnAttachTo);
				registerMissingPatternByResource(getResourceFromNamedNode(nnAttachTo), newtr);
				if (directedPath.getNext() != null) {
					for (DirectedPath lowerDp : directedPath.getNext()) {
						assignMissingPatternsToNamedNode(pf, nnAttachTo, lowerDp);
					}
				}
			}
		}
	}

	/**
	 * Method to register missing patterns by the Resource of the NamedNode to which they apply
	 * @param resourceFromNamedNode
	 * @param tr
	 */
	protected void registerMissingPatternByResource(Resource resourceFromNamedNode, TripleElement tr) {
		if (missingTriplesByResource == null) {
			List<TripleElement> trs = new ArrayList<TripleElement>();
			trs.add(tr);
			missingTriplesByResource = new HashMap<Resource, List<TripleElement>>();
			missingTriplesByResource.put(resourceFromNamedNode, trs);
		}
		else if (missingTriplesByResource.containsKey(resourceFromNamedNode)) {
			List<TripleElement> lst = missingTriplesByResource.get(resourceFromNamedNode);
			lst.add(tr);
		}
		else {
			List<TripleElement> trs = new ArrayList<TripleElement>();
			trs.add(tr);
			missingTriplesByResource.put(resourceFromNamedNode, trs);
		}
	}
	
	/**
	 * Method to find the replacement TripleElements (for properties not in a property chain)
	 * and a set of possible missing paths in a CtxRequirement.
	 * Note: this method is public for testing purposes only. It should not be called directly otherwise.
	 * To add replacement triples and missing triples to a CtxRequirement, call addMissingTriplePatterns.
	 * @param model -- the ontology model
	 * @param rule -- the Rule
	 * @return -- a map of InvertedTreePathSteps keyed by Jena ontology resource
	 * @throws MultiplePathsFoundException 
	 * @throws PathFindingException 
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws CircularDependencyException 
	 * @throws InvalidNameException 
	 */
	public PathFinder findReplacementTriplesAndPotentialMissingPaths(OntModel model,
			Rule rule) throws CircularDependencyException, InvalidTypeException, TranslationException, PathFindingException, MultiplePathsFoundException, InvalidNameException {
		PathFinder thePathFinder = null;
		logger.debug("Entering findReplacementTriplesAndPotentialMissingPaths\n{}\n", 
				rule.toDescriptiveString());
		resetForNewStructure();
		if (!rule.isMissingPatternsAdded()) {
			thePathFinder = new PathFinder(this, model);
			thePathFinder.findMissingGraphPatterns(rule);
		}
		return thePathFinder;
	}

	protected void setTheJenaModel(OntModel theJenaModel) {
		this.theJenaModel = theJenaModel;
	}

	@Override
	public boolean graphPatternElementMustBeInConclusions(GraphPatternElement gpe) {
		if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getFuncName().equals("assign")) {
			return true;
		}
		return false;
	}

	/** 
	 * Method to return the type of element returned by a list element extraction built-in
	 * @param bi
	 * @return
	 */
	public NamedNode listElementIdentifierListType(BuiltinElement bi) {
		if (bi.getFuncName().equals("lastElement") ||
				bi.getFuncName().equals("firstElement") ||
				bi.getFuncName().equals("elementBefore") ||
				bi.getFuncName().equals("elementAfter") ||
				bi.getFuncName().equals("elementInList") ||
				bi.getFuncName().equals("sublist")) {
			Node listArg = bi.getArguments().get(0);
			if (listArg instanceof NamedNode) {
				return (NamedNode) listArg;
			}
			else if (listArg instanceof ProxyNode) {
				Object pf = ((ProxyNode)listArg).getProxyFor();
				if (pf instanceof TripleElement) {
					Node pred = ((TripleElement) pf).getPredicate();
					if (pred instanceof NamedNode) {
						Property p = theJenaModel.getProperty(((NamedNode)pred).toFullyQualifiedString());
						try {
							ConceptName pcn = getModelProcessor().namedNodeToConceptName((NamedNode)pred);
							TypeCheckInfo tci = getModelValidator().getTypeInfoFromRange(pcn, p, null);
							Node lsttype = tci.getTypeCheckType();
							if (lsttype instanceof NamedNode) {
								return (NamedNode) lsttype;
							}
						} catch (DontTypeCheckException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (InvalidTypeException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (TranslationException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (InvalidNameException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			}
			return null;
		}
		return null;
	}

	@Override
	public NamedNode getAnchoringNode(Object semanticConstruct) {
		// TODO Auto-generated method stub
		return null;
	}

	/**
	 * Method to obtain a Jena Resource from a NamedNode while caching
	 * the NamedNode in a Map so that it can be retrieved by Resource. This is
	 * needed because it is difficult or impossible to retrieve all of the 
	 * information in the original NamedNode from the Jena OntModel Resource.
	 * @param theNode
	 * @return
	 * @throws TranslationException 
	 */
	public Resource getResourceFromNamedNode(NamedNode theNode) throws TranslationException {
		Resource rsrc = null;
		if(theNode == null) {
			return null;
		}
		if (getModelProcessor().isProperty(theNode)) {
			rsrc = getTheJenaModel().getProperty(theNode.toFullyQualifiedString());
		}
		else {
			rsrc = getTheJenaModel().getResource(theNode.toFullyQualifiedString());
		}
		if (!resourceToNamedNodeMap.containsKey(rsrc) ) {
			resourceToNamedNodeMap.put(rsrc, theNode);
		}
		return rsrc;
	}

	/**
	 * Method to obtain a Jena Property from a NamedNode while caching
	 * the NamedNode in a Map so that it can be retrieved by Properpty. This is
	 * needed because it is difficult or impossible to retrieve all of the 
	 * information in the original NamedNode from the Jena OntModel Property.
	 * @param theNode
	 * @return
	 */
	public Property getPropertyFromNamedNode(NamedNode theNode) throws TranslationException {
		Property prop = getTheJenaModel().getProperty(theNode.toFullyQualifiedString());
		if (!resourceToNamedNodeMap.containsKey(prop)) {
			resourceToNamedNodeMap.put(prop, theNode);
		}
		return prop;
	}

	/**
	 * Method to retrieve a NamedNode from the cache by Jena Resource
	 * @param rsrc
	 * @return
	 * @throws TranslationException
	 */
	public NamedNode getNamedNodeFromResourceMap(Resource rsrc) throws TranslationException {
		if (resourceToNamedNodeMap.containsKey(rsrc)) {
			return resourceToNamedNodeMap.get(rsrc);
		}
		// some Resources will have come directly from the Ontology as missing patterns are identified
		return jenaResourceToNamedNode(rsrc);
	}

	/**
	 * Method to retrieve a NamedNode that corresponds to a Jena Resource.
	 * Note that this will not necessarily return the one from which the Resource was identified.
	 * @param un
	 * @return
	 * @throws TranslationException 
	 */
	public NamedNode jenaResourceToNamedNode(org.apache.jena.rdf.model.Resource un) throws TranslationException {
		NamedNode nn = null;
		if (un != null) {
			if (un.isURIResource()) {
				NodeType ntype = null;
				if (un instanceof Property) {
					if (un.canAs(DatatypeProperty.class)) {
						ntype = NodeType.DataTypeProperty; 
					}
					else if (un.canAs(ObjectProperty.class)) {
						ntype = NodeType.ObjectProperty;
					}
					else {
						ntype = NodeType.PropertyNode;
					}
				}
				else if (un.canAs(Individual.class)&& !un.canAs(OntClass.class)) {
					ntype = NodeType.InstanceNode;
				}
				else if (un.canAs(OntClass.class)) {
					ntype = NodeType.ClassNode;
				}
				String uri = un.getURI();
				if (uri != null) {
					nn = new NamedNode(uri, ntype);
				}
			}
			else {
				if (getModelProcessor().isTypedListSubclass(un)) {
					nn = getModelProcessor().getTypedListType(un);
				}
			}
		}
		return nn;
	} 

	/**
	 * Method to get the NamedNodes that have missing patterns so they can be removed when 
	 * requirement is fully cooked.
	 * 
	 * @return
	 */
	protected List<NamedNode> getNamedNodesToCleanOfMissingPatternsWhenCooked() {
		return namedNodesToCleanOfMissingPatternsWhenCooked;
	}

	/**
	 * Method to record that a NamedNode has missing patterns so they can be removed when
	 * requirement if fully cooked. 
	 * @param namedNodeToClean
	 */
	protected void addNamedNodeToCleanOfMissingPatternsWhenCooked(NamedNode namedNodeToClean) {
		if (namedNodesToCleanOfMissingPatternsWhenCooked == null) {
			namedNodesToCleanOfMissingPatternsWhenCooked = new ArrayList<NamedNode>();
		}
		namedNodesToCleanOfMissingPatternsWhenCooked.add(namedNodeToClean);
	}

	/** Method to determine if a list operation needs an argument added
	 * 
	 * @param bi
	 * @return
	 */
	public boolean returnVariableArgumentNeeded(BuiltinElement bi) {
		if (bi.getFuncName().equals("lastElement")) {
			if (bi.getArguments().size() < 2) {
				return true;
			}
		}
		else if (bi.getFuncName().equals("firstElement")) {
			if (bi.getArguments().size() < 2) {
				return true;
			}
		}
		else if (bi.getFuncName().equals("elementBefore")) {
			if (bi.getArguments().size() < 3) {
				return true;
			}
		}
		else if (bi.getFuncName().equals("elementAfter")) {
			if (bi.getArguments().size() < 3) {
				return true;
			}
		}
		else if (bi.getFuncName().equals("elementInList")) {
			if (bi.getArguments().size() < 3) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Initialization method; make sure nothing is left over from a previous requirement
	 */
	protected void resetForNewStructure() {
		resourceToNamedNodeMap.clear();
		retiredProxyNodes.clear();
	}
	
	@Override
	public void reset() {
		resetForNewStructure();
		if (addMissingTriplePatternsReturnValueByReqName != null) {
			addMissingTriplePatternsReturnValueByReqName.clear();
		}
	}

	/**
	 * Method to remove an unnecessary BuiltinElement of type "is" (comparison or assignment) which has a
	 * TripleElement with null object on the left and a concrete value on the right that cana be moved into
	 * the TripleElement as object.
	 * @param gpes
	 */
	protected void removeUnnecessaryIsAroundTriple(List<GraphPatternElement> gpes) {
		for (int i = gpes.size() - 1; i >= 0; i--) {
			GraphPatternElement gpe = gpes.get(i);
			TripleElement resultingTriple = removeUnnecessaryIsAroundTriple(gpe);
			if (resultingTriple != null) {
				gpes.set(i, resultingTriple);
			}
		}
		
	}

	/**
	 * Method to do the detailed work of removing an unnecessary "is" built-in 
	 * @param gpe
	 * @return
	 */
	private TripleElement removeUnnecessaryIsAroundTriple(GraphPatternElement gpe) {
		if (gpe instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) gpe;
			if (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign)) {
				if ((be.getArguments().get(1) instanceof Literal || be.getArguments().get(1) instanceof ConstantNode || 
						(be.getArguments().get(1) instanceof NamedNode && ((NamedNode)be.getArguments().get(1)).getNodeType().equals(NodeType.InstanceNode))) &&
						be.getArguments().get(0) instanceof ProxyNode && ((ProxyNode)be.getArguments().get(0)).getProxyFor() instanceof TripleElement && 
						((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject() == null) {
					((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setObject(be.getArguments().get(1));
					return (TripleElement) ((ProxyNode)be.getArguments().get(0)).getProxyFor();
				}
			}
			else if (be.getArguments() != null && be.getArguments().size() > 0) {
				for (int i = 0; i < be.getArguments().size(); i++) {
					Node arg = be.getArguments().get(i);
					if (arg instanceof ProxyNode && ((ProxyNode)arg).getProxyFor() instanceof BuiltinElement) {
						TripleElement resultingTriple = removeUnnecessaryIsAroundTriple((GraphPatternElement)((ProxyNode)arg).getProxyFor());
						if (resultingTriple != null) {
							((ProxyNode)arg).setProxyFor(resultingTriple);
						}
					}
				}
			}
		}
		return null;
	}

}	
