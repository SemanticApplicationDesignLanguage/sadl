 /************************************************************************
 * Copyright Â© 2007-2017 - General Electric Company, All Rights Reserved
 *
 * Project: SADL
 *
 * Description: The Semantic Application Design Language (SADL) is a
 * language for building semantic models and expressing rules that
 * capture additional domain knowledge. The SADL-IDE (integrated
 * development environment) is a set of Eclipse plug-ins that
 * support the editing and testing of semantic models using the
 * SADL language.
 *
 * This software is distributed "AS-IS" without ANY WARRANTIES
 * and licensed under the Eclipse Public License - v 1.0
 * which is available at http://www.eclipse.org/org/documents/epl-v10.php
 *
 ***********************************************************************/

 package com.ge.research.sadl.jena;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.nodemodel.INode;
import org.eclipse.xtext.nodemodel.impl.CompositeNodeWithSemanticElement;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils;
import org.eclipse.xtext.resource.XtextResource;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ge.research.sadl.jena.JenaBasedSadlModelValidator.TypeCheckInfo;
import com.ge.research.sadl.model.ConceptName;
import com.ge.research.sadl.model.ConceptName.ConceptType;
import com.ge.research.sadl.model.gp.BuiltinElement;
import com.ge.research.sadl.model.gp.BuiltinElement.BuiltinType;
import com.ge.research.sadl.model.gp.ConstantNode;
import com.ge.research.sadl.model.gp.GraphPatternElement;
import com.ge.research.sadl.model.gp.Junction;
import com.ge.research.sadl.model.gp.Junction.JunctionType;
import com.ge.research.sadl.model.gp.Literal;
import com.ge.research.sadl.model.gp.NamedNode;
import com.ge.research.sadl.model.gp.NamedNode.NodeType;
import com.ge.research.sadl.model.gp.Node;
import com.ge.research.sadl.model.gp.ProxyNode;
import com.ge.research.sadl.model.gp.RDFTypeNode;
import com.ge.research.sadl.model.gp.Rule;
import com.ge.research.sadl.model.gp.Test;
import com.ge.research.sadl.model.gp.Test.ComparisonType;
import com.ge.research.sadl.model.gp.TripleElement;
import com.ge.research.sadl.model.gp.TripleElement.TripleModifierType;
import com.ge.research.sadl.model.gp.TripleElement.TripleSourceType;
import com.ge.research.sadl.model.gp.VariableNode;
import com.ge.research.sadl.processing.SadlConstants;
import com.ge.research.sadl.processing.SadlModelProcessor;
import com.ge.research.sadl.reasoner.CircularDependencyException;
import com.ge.research.sadl.reasoner.InvalidNameException;
import com.ge.research.sadl.reasoner.InvalidTypeException;
import com.ge.research.sadl.reasoner.TranslationException;
import com.ge.research.sadl.reasoner.utils.SadlUtils;
import com.ge.research.sadl.sADL.Expression;
import com.ge.research.sadl.sADL.TestStatement;
import com.hp.hpl.jena.ontology.OntClass;
import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.StmtIterator;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * This class translates the output generated by parsing SADL queries, 
 * rules, and tests into what is called the SADL Intermediate Form (IF).  
 * The parser output is in the form of parse trees whose nodes are 
 * instances of the class Expression or of one of its subclasses.
 * The IF uses the Java classes in the Graph Patterns package 
 * (com.ge.research.sadl.model.gp). In the IF, each query or 
 * rule part (given, if, or then) or test phrase consists of 
 * a list of graph pattern elements.  The graph pattern element 
 * can be a triple pattern or it can be a built-in.  This 
 * Intermediate Form is passed to the reasoner-specific translator 
 * to generate rules and queries in an optimized form and format 
 * for the target reasoner.
 * 
 * One of the primary contributions of SADL to the modeling process is
 * its English-like syntax. The translation accomplished by this class
 * goes from this English-like syntax to the IF. Among other things, this
 * involves the generation of "missing" variables to provide the 
 * connectives between the individual graph pattern elements in a list.
 * 
 * The translation process "walks" the Expression parse tree. At the 
 * leaves of this parse tree are ExplicitValues, IntervalValues, 
 * ValueTables, or built-ins. At each node higher in the parse tree, 
 * if returning to the node represents the completion of a graph pattern 
 * element then that element is placed in the list at the appropriate 
 * location and if necessary a variable (Node) is identified to connect 
 * this new graph pattern element to other graph pattern elements 
 * in the list.
 * 
 * 10/2011:
 * The approach of adding variables as the translation proceeds, bottom-up,
 * has issues as looking bottom up one can't always tell the context and
 * therefore make the right decision. Therefore the strategy is changed to 
 * use a ProxyNode to encapsulate the lower-level constructs to replicate
 * the parse tree but in the IF structures. Then the expansion of ProxyNodes
 * can occur with a knowledge of context for proper decisioning. For example,
 * no information is available to know whether a rule built-in has zero, one,
 * or more output variables. However, usage will show that either the built-in
 * is used within a higher-level built-in or triple, in which case it must 
 * generate an output other than boolean so in expand ProxyNodes it will be
 * property handled by adding a generated variable if a specified variable
 * was not given, which variable is also placed in
 * the higher-level construct. In the future built-ins might be allowed to 
 * return multiple values but that would require a construct such as
 * 
 * 	x,y,z is someBuiltin(input1, input2, ..)
 * 
 * This extension of the grammar would provide the necessary information 
 * about the number of output variables to add, but only with the contextual
 * knowledge of the whole statement.
 * 
 * 
 * @author crapo
 *
 */
public class IntermediateFormTranslator implements I_IntermediateFormTranslator {
    protected static final Logger logger = LoggerFactory.getLogger(IntermediateFormTranslator.class);
    private int vNum = 0;	// used to create unique variables
    private List<IFTranslationError> errors = null;
    private Object target = null;	// the instance of Rule, Query, or Test into which we are trying to put the translation
    private Object encapsulatingTarget = null;	// when a query is in a test
    private GraphPatternElement firstOfPhrase = null;
    
    private List<ConceptName> namedNodes = null;
    private boolean collectNamedNodes = false;
    private List<String> userDefinedVariables = new ArrayList<String>();
    private OntModel theJenaModel = null;
    private JenaBasedSadlModelProcessor modelProcessor = null;
    
	private List<VariableNode> cruleVariablesTypeOutput = null;		// list of crule variables that have had type statements output (only do so once)

	/**
     * The constructor takes a ModelManager argument
     * @param ontModel 
     * @param modmgr
     */
    public IntermediateFormTranslator(OntModel ontModel) {
    	setTheJenaModel(ontModel);
    }
    
	/**
     * The constructor takes a ModelManager argument
     * @param ontModel 
     * @param modmgr
     */
    public IntermediateFormTranslator(JenaBasedSadlModelProcessor processor, OntModel ontModel) {
    	setModelProcessor(processor);
    	setTheJenaModel(ontModel);
    }
    
    // the target can be a Test, a Query, or a Rule instance
    /* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setTarget(java.lang.Object)
	 */
    @Override
	public void setTarget(Object _target) {
    	target = _target;
    }
    
	@Override
	public Object getTarget() {
		return target;
	}
	
	/**
	 * Reset the translator for a new translation task
	 */
	protected void resetIFTranslator() {
		vNum = 0;
		if (errors != null) {
			errors.clear();
		}
		setTarget(null);
		encapsulatingTarget = null;
		setFirstOfPhrase(null);
	}
	
	/**
	 * Returns the bottom triple whose subject was replaced.
	 * @param pattern
	 * @param proxyFor
	 * @param assignedNode
	 * @return
	 */
	private TripleElement assignNullSubjectInProxies(TripleElement pattern,
			TripleElement proxyFor, Node assignedNode) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
//				((ProxyNode)pattern.getSubject()).setReplacementNode(assignedNode);
				if (((TripleElement)proxy).getSubject() == null) {
					// this is the bottom of the recursion
					((TripleElement)proxy).setSubject(assignedNode);
					return (TripleElement) proxy;
				}
				else {
					// recurse down
					TripleElement bottom = assignNullSubjectInProxies(((TripleElement)proxy), proxyFor, assignedNode);
					// make the proxy next and reassign this subject as assignedNode
					((ProxyNode)((TripleElement)proxy).getSubject()).setReplacementNode(assignedNode);
					((TripleElement)proxy).setSubject(assignedNode);
					if (bottom.getNext() == null) {
						bottom.setNext(pattern);
					}
					return bottom;
				}
			}
		}
		return null;
	}

	private TripleElement getProxyWithNullSubject(TripleElement pattern) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
				if (((TripleElement)proxy).getSubject() == null) {
					return (TripleElement)proxy;
				}
				else {
					return getProxyWithNullSubject(((TripleElement)proxy));
				}
			}
		}
		return null;
	}

	private boolean isComparisonViaBuiltin(Object robj, Object lobj) {
		if (robj instanceof TripleElement && lobj instanceof Node &&
				((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (isComparisonBuiltin(be.getFuncName()) && be.getArguments().size() == 1) {
				return true;
			}
		}
		return false;
	}

	private boolean isModifiedTripleViaBuitin(Object robj) {
		if (robj instanceof TripleElement && ((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (((TripleElement)robj).getPredicate() instanceof RDFTypeNode) {
				if (isModifiedTriple(be.getFuncType())) {
					Node subj = ((TripleElement)robj).getSubject();
					Node arg = (be.getArguments() != null && be.getArguments().size() > 0) ? be.getArguments().get(0) : null;
					if (subj == null && arg == null) {
						return true;
					}
					if (subj != null && arg != null && subj.equals(arg)) {
						return true;
					}
				}
			}
			else {
				if (isModifiedTriple(be.getFuncType()) && ((TripleElement)robj).getObject().equals(be.getArguments().get(0))) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasCommonVariableSubject(Object robj) {
		if (robj instanceof TripleElement && 
				(((TripleElement)robj).getSubject() instanceof VariableNode && 
						(((TripleElement)robj).getSourceType().equals(TripleSourceType.SPV)) ||
						((TripleElement)robj).getSourceType().equals(TripleSourceType.ITC))) {
			VariableNode subjvar = (VariableNode) ((TripleElement)robj).getSubject();
			Object trel = robj;
			while (trel != null && trel instanceof TripleElement) {
				if (!(trel instanceof TripleElement) || 
						(((TripleElement)trel).getSubject() != null &&!(((TripleElement)trel).getSubject().equals(subjvar)))) {
					return false;
				}
				trel = ((TripleElement)trel).getNext();
			}
			if (trel == null) {
				return true;
			}
		}
		return false;
	}

	public static boolean isModifiedTriple(BuiltinType type) {
		if (type.equals(BuiltinType.Not) || type.equals(BuiltinType.NotEqual) || type.equals(BuiltinType.Only)||  type.equals(BuiltinType.NotOnly)) {
			return true;
		}
		return false;
	}
	
	public String getSourceGrammarText(EObject po) {
		Object r = po.eResource();
		if (r instanceof XtextResource) {
			INode root = ((XtextResource) r).getParseResult().getRootNode();
	        for(INode node : root.getAsTreeIterable()) {   
	        	if (node instanceof CompositeNodeWithSemanticElement) {
	        		EObject semElt = ((CompositeNodeWithSemanticElement)node).getSemanticElement();
	        		if (semElt.equals(po)) {
	        			// this is the one!
	        			String txt = NodeModelUtils.getTokenText(node);
	   					return txt.trim();
	        		}
	        	}
	        }
			org.eclipse.emf.common.util.TreeIterator<EObject> titr = po.eAllContents();
			while (titr.hasNext()) {
				EObject el = titr.next();
// TODO what's supposed to happen here?
				int i = 0;
			}
		}
		return null;
	}

	/**
	 * This method fills in missing information in a NamedNode: 
	 * the prefix, the namespace, the type
	 * 
	 * @param namedNode
	 * @return
	 * @throws InvalidNameException 
	 */
	protected Node validateNode(Node node) throws InvalidNameException {
		if (node instanceof NamedNode) {
			if (!((NamedNode)node).isValidated()) {
				if (node instanceof VariableNode) {
					((VariableNode) node).setNodeType(NodeType.VariableNode);
					userDefinedVariables.add(((NamedNode) node).getName());
				}
				else if (node instanceof RDFTypeNode) {
					((RDFTypeNode) node).setNodeType(NodeType.PropertyNode);
				}
				else {
					ConceptName cname = null;
					ConceptType ctype = null;
					String name = ((NamedNode)node).toString(); //getName();
					if (name == null) {
						throw new InvalidNameException("A NamedNode has a null name! Did ResourceByName resolution fail?");
					}
				    int colon = name.indexOf(':');
					if (colon > 0 && colon < name.length() - 1) {
						String pfx = name.substring(0, colon);
				        ((NamedNode)node).setPrefix(pfx);
				        String lname = name.substring(colon + 1);
				        ((NamedNode)node).setName(lname);
//				        cname = modelManager.validateConceptName(new ConceptName(pfx, lname));
				    }
				    else {
//				    	cname = modelManager.validateConceptName(new ConceptName(name));
				    }
			        ctype = cname.getType();
			        ((NamedNode)node).setNamespace(cname.getNamespace());
			        ((NamedNode)node).setPrefix(cname.getPrefix());
			    	if (ctype.equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)) {
//			    		modelManager.addToVariableNamesCache(cname);
			    		node = new VariableNode(((NamedNode)node).getName());
			    		userDefinedVariables.add(((NamedNode) node).getName());
			    	}
			    	else if (ctype.equals(ConceptType.ANNOTATIONPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.DATATYPEPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.OBJECTPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.ONTCLASS)){
			    		((NamedNode)node).setNodeType(NodeType.ClassNode);
			    	}
			    	else if (ctype.equals(ConceptType.INDIVIDUAL)){
			    		((NamedNode)node).setNodeType(NodeType.InstanceNode);
			    	}
			    	else {
			    		logger.error("Unexpected ConceptType: " + ctype.toString());
				    	addError(new IFTranslationError("Unexpected ConceptType: " + ctype.toString()));
			    	}
			    	if (isCollectNamedNodes()) {
			    		if (namedNodes == null) {
			    			namedNodes = new ArrayList<ConceptName>();
			    		}
			    		if (!namedNodes.contains(cname)) {
			    			namedNodes.add(cname);
			    		}
			    	}
				}
				((NamedNode)node).setValidated(true);
			}
		}
		return node;
	}
	
	private void addError(IFTranslationError error) {
		if (errors == null) {
			errors = new ArrayList<IFTranslationError>();
		}
		errors.add(error);
	}

	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#getErrors()
	 */
	@Override
	public List<IFTranslationError> getErrors() {
		return errors;
	}
	
	private GraphPatternElement createBinaryBuiltin(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (lobj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(lobj));
		}
		if (robj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(robj));
		}
		return builtin;
	}
	
	private Junction createJunction(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		Junction junction = new Junction();
		junction.setJunctionName(name);
		junction.setLhs(SadlModelProcessor.nodeCheck(lobj));
		junction.setRhs(SadlModelProcessor.nodeCheck(robj));
		return junction;
	}

	private Object createUnaryBuiltin(Expression sexpr, String name, Object sobj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (sobj instanceof Literal && BuiltinType.getType(name).equals(BuiltinType.Minus)) {
			Object theVal = ((Literal)sobj).getValue();
			if (theVal instanceof Integer) {
				theVal = ((Integer)theVal) * -1;
			}
			else if (theVal instanceof Long) {
				theVal = ((Long)theVal) * -1;
			}
			else if (theVal instanceof Float) {
				theVal = ((Float)theVal) * -1;
			}
			else if (theVal instanceof Double) {
				theVal = ((Double)theVal) * -1;
			}
			((Literal)sobj).setValue(theVal);
			((Literal)sobj).setOriginalText("-" + ((Literal)sobj).getOriginalText());
			return sobj;
		}
		if (sobj instanceof Junction) {
			// If the junction has two literal values, apply the op to both of them.
			Junction junc = (Junction) sobj;
			Object lhs = junc.getLhs();
			Object rhs = junc.getRhs();
			if (lhs instanceof Literal && rhs instanceof Literal) {
				lhs = createUnaryBuiltin(sexpr, name, lhs);
				rhs = createUnaryBuiltin(sexpr, name, rhs);
				junc.setLhs(SadlModelProcessor.nodeCheck(lhs));
				junc.setRhs(SadlModelProcessor.nodeCheck(rhs));
			}
			return junc;
		}
		if (BuiltinType.getType(name).equals(BuiltinType.Equal)) {
			if (sobj instanceof BuiltinElement) {
				if (isComparisonBuiltin(((BuiltinElement)sobj).getFuncName())) {
					// this is a "is <comparison>"--translates to <comparsion> (ignore is)
					return sobj;
				}
			}
			else if (sobj instanceof Literal || sobj instanceof NamedNode) {
				// an "=" interval value of a value is just the value
				return sobj;
			}
		}
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (isModifiedTriple(builtin.getFuncType())) {
			if (sobj instanceof TripleElement) {
				((TripleElement)sobj).setType(getModelProcessor().getTripleModifierType(builtin.getFuncType()));
				return sobj;
			}
		}
		if (sobj != null) {
			builtin.addArgument(SadlModelProcessor.nodeCheck(sobj));
		}
		return builtin;
	}

	private TripleElement addGraphPatternElementAtEnd(GraphPatternElement head, Node subject, Node predicate, Node object, TripleSourceType sourceType) {
		TripleElement newTriple = new TripleElement();
		newTriple.setSubject(subject);
		newTriple.setPredicate(predicate);
		newTriple.setObject(object);
		newTriple.setSourceType(sourceType);
		return newTriple;
	}
	
	private GraphPatternElement addGraphPatternElementAtEnd(GraphPatternElement head, GraphPatternElement newTail) {
		if (head != null) {
			GraphPatternElement lastElement = getLastGraphPatternElement(head);
			lastElement.setNext(newTail);
		}
		else {
			head = newTail;
		}
		return head;
	}
	
	private GraphPatternElement getLastGraphPatternElement(GraphPatternElement pattern) {
		while (pattern.getNext() != null) {
			pattern = pattern.getNext();
		}
		return pattern;
	}
	
	/**
	 * Method to find all of the variables in a graph pattern that might be the implied select variables of a query
	 * @param pattern
	 * @return
	 */
	public Set<VariableNode> getSelectVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = getUnboundVariables(patterns);

		// If we don't find an unreferenced variable, see if the pattern defines
		// a typed b node and get its variable.
		if (vars.isEmpty()) {
			for (int i = 0; i < patterns.size(); i++) {
				GraphPatternElement pattern = patterns.get(i);
				Set<VariableNode> moreVars = getSelectVariables(pattern);
				if (moreVars != null && moreVars.size() > 0) {
					vars.addAll(moreVars);
				}
			}
		}
		return vars;
	}
	
	public Set<VariableNode> getSelectVariables(GraphPatternElement pattern) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();
		if (pattern instanceof TripleElement) {
			TripleElement triple = (TripleElement) pattern;
			if (triple.getSubject() instanceof VariableNode &&
					triple.getPredicate() instanceof RDFTypeNode) {
				VariableNode var = (VariableNode) triple.getSubject();
				vars.add(var);
			}
			else if (triple.getSubject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getSubject()));
			}
			else if (triple.getObject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getObject()));
			}
			else if (triple.getPredicate() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getPredicate()));
			}
		}
		else if (pattern instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)pattern).getArguments();
			if (args != null) {
				// right now we have no mechanism to know which variables are unbound so
				//	assume the last one is
				// TODO
				Node arg = args.get(args.size() - 1);
				if (arg instanceof VariableNode) {
					vars.add((VariableNode) arg);
				}
			}
		}
		else if (pattern instanceof Junction) {
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			if (lhs instanceof GraphPatternElement) {
				Set<VariableNode> lhsvars = getSelectVariables((GraphPatternElement) lhs);
				if (lhsvars != null) {
					vars.addAll(lhsvars);
				}
			}
			if (rhs instanceof GraphPatternElement) {
				Set<VariableNode> rhsvars = getSelectVariables((GraphPatternElement) rhs);
				if (rhsvars != null) {
					vars.addAll(rhsvars);
				}
			}
		}
		return vars;
	}

	private Set<VariableNode> getUnboundVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();

		// We need to find any unreferenced variables in the pattern.
		for (int i = 0; i < patterns.size(); i++) {
			GraphPatternElement gpe = patterns.get(i);
			if (gpe instanceof TripleElement) {
				// Check the object of each triple to see if it has a variable
				// node with zero references.
				TripleElement triple = (TripleElement) gpe;
				Node subjNode = triple.getSubject();
				if (subjNode instanceof VariableNode) {
					VariableNode var = (VariableNode) subjNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (subjNode instanceof NamedNode && ((NamedNode)subjNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)subjNode).getName()));
				}
				Node objNode = triple.getObject();
				if (objNode instanceof VariableNode) {
					VariableNode var = (VariableNode) objNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (objNode instanceof NamedNode && ((NamedNode)objNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)objNode).getName()));
				}
			}
			else if (gpe instanceof BuiltinElement) {
				// Check the arguments of each builtin to see if it has a 
				// variable node with zero references.
				BuiltinElement builtin = (BuiltinElement) gpe;
				for (Node argument : builtin.getArguments()) {
					if (argument instanceof VariableNode) {
						VariableNode var = (VariableNode) argument;
						if (var.getNumReferences() == 0) {
							vars.add(var);
						}
					}
				}
			}
		}

		return vars; 
	}

	/**
	 * This method flattens out GraphPatternElement linked lists into a regular List
	 * @param test
	 * @param object 
	 */
	public void postProcessTest(Test test, TestStatement object) {
		try {
			Object lhs = test.getLhs();
			if (lhs instanceof List<?> && ((List<?>)lhs).size() > 0) {
				if (((List<?>)lhs).get(0) instanceof GraphPatternElement) {
					flattenLinkedList((List<GraphPatternElement>)lhs);
				}
				if (lhs instanceof List<?>) {
					if (((List<?>)lhs).size() == 1) {
						lhs = ((List<?>)lhs).get(0);
						test.setLhs(lhs);
					}
					else if (((List<?>)lhs).size() == 2 && ((List<?>)lhs).get(1) instanceof BuiltinElement &&
							((BuiltinElement)((List<?>)lhs).get(1)).isCreatedFromInterval()) {
						test.setLhs(((List<?>)lhs).get(0));
						test.setCompName(((BuiltinElement)((List<?>)lhs).get(1)).getFuncType());
						test.setRhs(((BuiltinElement)((List<?>)lhs).get(1)).getArguments().get(1));
					}
				}
			}
			else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
				boolean done = false;
				if ((((GraphPatternElement)lhs).getNext() instanceof  BuiltinElement)) {
					// there is a builtin next
					BuiltinElement be = (BuiltinElement) ((GraphPatternElement)lhs).getNext();
					if (isComparisonBuiltin(be.getFuncName())) {
						((GraphPatternElement)lhs).setNext(null);
						if (be.getArguments().size() > 1) {
							if (be.getArguments().get(0) instanceof VariableNode) {
								test.setRhs(be.getArguments().get(1));
							}
							else {
								// this is of the form V is P of S so comparison must be reversed
								reverseBuiltinComparisonDirection(be);
								test.setRhs(be.getArguments().get(0));
							}
						}
						else {
							addError(new IFTranslationError("A BuiltinElement in a Test is a comparison (" + be.getFuncName() + ") but has less than two arguemnts (" + be.toString() + ")"));
						}
						test.setCompName(be.getFuncName());
						done = true;
					}
				}
				if (!done) {
					List<GraphPatternElement> newLhs = new ArrayList<GraphPatternElement>();
					newLhs.add((GraphPatternElement) lhs);
					test.setLhs(flattenLinkedList(newLhs));
				}
			}
			else if (lhs instanceof BuiltinElement && isModifiedTriple(((BuiltinElement)lhs).getFuncType())) {
				List<Node> args = ((BuiltinElement)lhs).getArguments();
				if (args != null && args.size() == 2) {
					test.setLhs(args.get(1));
					test.setRhs(args.get(0));
					test.setCompName(((BuiltinElement)lhs).getFuncName());
				}
			}
			if (test.getRhs() instanceof ProxyNode) {
				test.setRhs(((ProxyNode)test.getRhs()).getProxyFor());
			}
			Object rhs = test.getRhs();
			if (rhs instanceof List<?> && ((List<?>)rhs).size() > 0) {
				if (((List<?>)rhs).get(0) instanceof GraphPatternElement) {
					flattenLinkedList((List<GraphPatternElement>)rhs);
				}
			}
			else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
				boolean done = false;
				if ((((GraphPatternElement)rhs).getNext() instanceof BuiltinElement)) {
					BuiltinElement be = (BuiltinElement) ((GraphPatternElement)rhs).getNext();
					if (isComparisonBuiltin(be.getFuncName())) {
						((GraphPatternElement)rhs).setNext(null);
						test.setLhs(be.getArguments().get(1));
						test.setCompName(be.getFuncName());
						done = true;
					}
				}
				if (!done) {
					List<GraphPatternElement> newRhs = new ArrayList<GraphPatternElement>();
					newRhs.add((GraphPatternElement) rhs);
					test.setRhs(flattenLinkedList(newRhs));
				}
			}
	
			if (test.getLhs() instanceof ProxyNode) {
				test.setLhs(((ProxyNode)test.getLhs()).getProxyFor());
			}
			if (test.getCompType() != null && test.getCompType().equals(ComparisonType.Eq) 
					&& test.getLhs() != null && test.getRhs() != null 
					&& test.getLhs() instanceof NamedNode && test.getRhs() instanceof List<?>) {
				if (test.getRhsVariables() != null && test.getRhsVariables().size() == 1) {
					String rhsvar = test.getRhsVariables().get(0).getName();
					List<?> rhslist = (List<?>) test.getRhs();
					boolean allPass = true;
					for (int i = 0; i < rhslist.size(); i++) {
						Object anrhs = rhslist.get(i);
						if (!(anrhs instanceof TripleElement)) {
							allPass = false;
							break;
						}
						else {
							Node subj = ((TripleElement)anrhs).getSubject();
							if (!(subj instanceof VariableNode) || !(((VariableNode)subj).getName().equals(rhsvar))) {
								allPass = false;
								break;
							}
						}
					}
					if (allPass) {
						for (int i = 0; i < rhslist.size(); i++) {
							TripleElement triple = (TripleElement) rhslist.get(i);
							triple.setSubject((Node) test.getLhs());
						}
						test.setLhs(test.getRhs());
						test.setRhs(null);
						test.setRhsVariables(null);
						test.setCompName((String)null);
					}
				}
			}
			
			// this is a validity checking section
			TripleElement singleTriple = null;
			if (test.getLhs() instanceof TripleElement && test.getRhs() == null && ((TripleElement)test.getLhs()).getNext() == null) {
				singleTriple = (TripleElement) test.getLhs();
			}
			else if (test.getRhs() instanceof TripleElement && test.getLhs() == null && ((TripleElement)test.getRhs()).getNext() == null) {
				singleTriple = (TripleElement) test.getRhs();
			}
			if (singleTriple != null) {
				// a single triple test should not have any variables in it
				if (singleTriple.getSubject() instanceof VariableNode || 
						singleTriple.getPredicate() instanceof VariableNode ||
						singleTriple.getObject() instanceof VariableNode) {
					addError(new IFTranslationError("Test is a single triple to be matched; should not contain variables.", object));
				}
				else {
					try {
	//					modelManager.validateStatement(singleTriple.getSubject(), singleTriple.getPredicate(), singleTriple.getObject());
					}
					catch (Throwable t) {
						// try to validate but don't do anything on Exception
					}
				}
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
	}

	public static void reverseBuiltinComparisonDirection(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<=");
		}
	}

	public static void builtinComparisonComplement(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<=");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<");
		}
	}

	public static boolean isComparisonBuiltin(String builtinName) {
		ComparisonType[] types = ComparisonType.values();
		for (ComparisonType type : types) {
			if (type.matches(builtinName)) {
				return true;
			}
		}
		return false;
	}

	public Rule postProcessRule(Rule rule, EObject object) {
		clearCruleVariableTypedOutput();
		try {
			// do this first so that the arguments don't change before these are applied
			addImpliedAndExpandedProperties(rule);
			// now do this before any null subjects that are the same variable get replaced with different variables.
			addMissingCommonVariables(rule);
			// now add other missing patterns, if needed
//			addMissingTriplePatterns(rule);
		} catch (InvalidNameException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (InvalidTypeException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		} catch (TranslationException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		// convert givens linked list to array; expand conjunctions
		List<GraphPatternElement> givens = flattenRuleJunctions(rule.getGivens());
		if (givens != null) {
			Object results;
			try {
				results = expandProxyNodes(givens, false, true);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					rule.setGivens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		else {
			retiredProxyNodes.clear();
		}
		
		// convert ifs linked list to array; expand conjunctions
		List<GraphPatternElement> ifs = flattenRuleJunctions(rule.getIfs());
		if (ifs != null) {
			Object results;
			try {
				results = expandProxyNodes(ifs, false, false);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					rule.setIfs((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		// now process conclusions
		List<GraphPatternElement> thens = flattenRuleJunctions(rule.getThens());
		if (thens != null) {
			Object results;
			try {
				results = expandProxyNodes(thens, true, false);
				if (results instanceof List<?>) {
					if (((List<?>)results).size() == 1 && ((List<?>)results).get(0) instanceof Junction) {
						results = junctionToList((Junction) ((List<?>)results).get(0));
					}
					for (int i = 0; i < ((List<?>)results).size(); i++) {
						GraphPatternElement tgpe = (GraphPatternElement) ((List<?>)results).get(i);
						results = moveEmbeddedGPEsToIfs(rule, (List<?>) results, tgpe);
					}
					rule.setThens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 		
		}
		try {
			removeDuplicateElements(rule);
		} catch (InvalidNameException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (InvalidTypeException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (TranslationException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return rule;
	}
	
	private void addMissingCommonVariables(Rule rule) throws TranslationException {
		// Find triples with null subjects
		List<TripleElement> nullSubjects = null;
		if (rule.getGivens() != null) {
			nullSubjects = getNullSubjectTriples(rule.getGivens(), nullSubjects);
		}
		if (rule.getIfs() != null) {
			nullSubjects = getNullSubjectTriples(rule.getIfs(), nullSubjects);
		}
		if (rule.getThens() != null) {
			nullSubjects = getNullSubjectTriples(rule.getThens(), nullSubjects);
		}
		if (nullSubjects != null) {
			Map<NamedNode,List<Resource>> cache = new HashMap<NamedNode, List<Resource>>();
			for (int i = 0; i < nullSubjects.size(); i++) {
				Node prop = nullSubjects.get(i).getPredicate();
				if (prop instanceof NamedNode) {
					Property p = getTheJenaModel().getProperty(((NamedNode)prop).toFullyQualifiedString());
					StmtIterator dmnitr = getTheJenaModel().listStatements(p, RDFS.domain, (RDFNode)null);
					if (dmnitr.hasNext()) {
						List<Resource> dmnclses = new ArrayList<Resource>();
						while (dmnitr.hasNext()) {
							RDFNode dmn = dmnitr.nextStatement().getObject();
							if (dmn.isURIResource()) {
								dmnclses.add((Resource) dmn);
							}
							else {
								throw new TranslationException("Unhandled case");
							}
						}
						cache.put((NamedNode)prop, dmnclses);
					}
				}
			}
			for (int i = 0; i < nullSubjects.size(); i++) {
				List<Resource> dmns1 = cache.get(nullSubjects.get(i).getPredicate());
				for (int j = i +1; j < nullSubjects.size(); j++) {
					boolean matched = false;
					List<Resource> dmns2 = cache.get(nullSubjects.get(j).getPredicate());
					for (int k = 0; k < dmns2.size(); k++) {
						Resource dmn2 = dmns2.get(k);
						if (dmns1.contains(dmn2)) {
							// there's a match--connect them
							VariableNode cmnvar = new VariableNode(getNewVar());
							nullSubjects.get(i).setSubject(cmnvar);
							nullSubjects.get(j).setSubject(cmnvar);
							matched = true;
							break;
						}
						else if (dmn2.canAs(OntClass.class)) {
							for (int l = 0; l < dmns1.size(); l++) {
								Resource dmn1 = dmns1.get(l);
								if (dmn1.canAs(OntClass.class)) {
									if (SadlUtils.classIsSuperClassOf(dmn1.as(OntClass.class), dmn2.as(OntClass.class))) {
										VariableNode cmnvar = new VariableNode(getNewVar());
										nullSubjects.get(i).setSubject(cmnvar);
										nullSubjects.get(j).setSubject(cmnvar);
										matched = true;
										break;
									}
									else if (SadlUtils.classIsSuperClassOf(dmn2.as(OntClass.class), dmn1.as(OntClass.class))) {
										VariableNode cmnvar = new VariableNode(getNewVar());
										nullSubjects.get(i).setSubject(cmnvar);
										nullSubjects.get(j).setSubject(cmnvar);
										matched = true;
										break;
									}
								}
							}
						}
					}
					if (matched) {
						continue;
					}
				}
			}

		}
	}

	private List<TripleElement> getNullSubjectTriples(List<GraphPatternElement> gpes,
			List<TripleElement> nullSubjects) {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			nullSubjects = getNullSubjectTriples(nullSubjects, gpe);
		}
		return nullSubjects;
	}

	private List<TripleElement> getNullSubjectTriples(List<TripleElement> nullSubjects, GraphPatternElement gpe) {
		if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject() == null) {
			if (nullSubjects == null) {
				nullSubjects = new ArrayList<TripleElement>();
			}
			nullSubjects.add((TripleElement) gpe);
		}
		else {
			if (gpe instanceof TripleElement && ((TripleElement)gpe).getSubject() instanceof ProxyNode) {
				nullSubjects = getNullSubjectTriples(nullSubjects, (GraphPatternElement)((ProxyNode)((TripleElement)gpe).getSubject()).getProxyFor());
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int i = 0; args != null && i < args.size(); i++) {
					if (args.get(i) instanceof ProxyNode) {
						nullSubjects = getNullSubjectTriples(nullSubjects, (GraphPatternElement)((ProxyNode)args.get(i)).getProxyFor());
					}
				}
			}
		}
		return nullSubjects;
	}

	private Rule addImpliedAndExpandedProperties(Rule rule) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean clearPreviouslyRetired = true;	// must clear on first call
		List<GraphPatternElement> gvns = rule.getGivens();
		if (gvns != null) {
			addImpliedAndExpandedProperties(gvns);
			clearPreviouslyRetired = false;
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (ifs != null) {
			addImpliedAndExpandedProperties(ifs);
			clearPreviouslyRetired = false;
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (thens != null) {
			addImpliedAndExpandedProperties(thens);
		}
		return rule;
	}

	protected void addImpliedAndExpandedProperties(List<GraphPatternElement> fgpes) throws InvalidNameException, InvalidTypeException, TranslationException {
//		List<GraphPatternElement> fgpes = flattenLinkedList(gpes);
		for (int i = 0; i < fgpes.size(); i++) {
			GraphPatternElement gpeback = addImpliedAndExpandedProperties(fgpes.get(i));
			fgpes.set(i, gpeback);
		}
	}

	private GraphPatternElement addImpliedAndExpandedProperties(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean processed = false;
		if (gpe.getLeftImpliedPropertyUsed() != null) {
			applyLeftImpliedProperty(gpe);
			processed = true;
		}
		else if (gpe.getRightImpliedPropertyUsed() != null) {
			applyRightImpliedProperty(gpe);
			processed = true;
		}
		if (gpe.getExpandedPropertiesToBeUsed() != null) {
			gpe = applyExpandedProperties(gpe);
			processed = true;
		}
		if (!processed) {
			if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int i = 0; args != null && i < args.size(); i++ ) {
					Node arg = args.get(i);
					if (arg instanceof ProxyNode) {
						GraphPatternElement gpeback = addImpliedAndExpandedProperties((GraphPatternElement)((ProxyNode)arg).getProxyFor());
						((ProxyNode)arg).setProxyFor(gpeback);
					}
				}
			}
		}
		return gpe;
	}

	private void applyLeftImpliedProperty(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		NamedNode lip = gpe.getLeftImpliedPropertyUsed();
		if (gpe instanceof BuiltinElement) {
			if (((BuiltinElement)gpe).getArguments() == null || ((BuiltinElement)gpe).getArguments().size() != 2) {
				throw new TranslationException("Implied properties can't be applied to a BuiltinElement with other than 2 arguments");
			}
			Node arg0 = ((BuiltinElement)gpe).getArguments().get(0);
			if (arg0 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg0))) {
				TripleElement newTriple = singlePropertyToTriple((NamedNode)arg0);
				arg0 = SadlModelProcessor.nodeCheck(newTriple);
			}
			TripleElement newTriple = new TripleElement(arg0, lip, null);
			arg0 = SadlModelProcessor.nodeCheck(newTriple);
			((BuiltinElement)gpe).getArguments().set(0, arg0);	
			for (int i = 0; i < ((BuiltinElement)gpe).getArguments().size(); i++) {
				Node agi = ((BuiltinElement)gpe).getArguments().get(i);
				if (agi instanceof ProxyNode && ((ProxyNode)agi).getProxyFor() instanceof BuiltinElement) {
					addImpliedAndExpandedProperties((BuiltinElement)((ProxyNode)agi).getProxyFor());
				}
			}
			((BuiltinElement)gpe).setLeftImpliedPropertyUsed(null);
		}
		else if (gpe instanceof TripleElement) {
			TripleElement newTriple = new TripleElement(((TripleElement)gpe).getSubject(), ((TripleElement)gpe).getPredicate(), null);
			((TripleElement)gpe).setSubject(SadlModelProcessor.nodeCheck(newTriple));
			((TripleElement)gpe).setPredicate(lip);
			gpe.setRightImpliedPropertyUsed(null);
		}
		else {
			throw new TranslationException("Unexpected GraphPatternElement (" + gpe.getClass().getCanonicalName() + ") encountered applying implied property");
		}
	}

	private void applyRightImpliedProperty(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		NamedNode rip = gpe.getRightImpliedPropertyUsed();
		if (gpe instanceof BuiltinElement) {
			if (((BuiltinElement)gpe).getArguments() == null || ((BuiltinElement)gpe).getArguments().size() != 2) {
				throw new TranslationException("Implied properties can't be applied to a BuiltinElement with other than 2 arguments");
			}
			Node arg1 = ((BuiltinElement)gpe).getArguments().get(1);
			if (arg1 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg1))) {
				TripleElement newTriple = singlePropertyToTriple((NamedNode)arg1);
				arg1 = SadlModelProcessor.nodeCheck(newTriple);
			}
			TripleElement newTriple = new TripleElement(arg1, rip, null);
			arg1 = SadlModelProcessor.nodeCheck(newTriple);
			((BuiltinElement)gpe).getArguments().set(1, arg1);			
			for (int i = 0; i < ((BuiltinElement)gpe).getArguments().size(); i++) {
				Node agi = ((BuiltinElement)gpe).getArguments().get(i);
				if (agi instanceof ProxyNode && ((ProxyNode)agi).getProxyFor() instanceof BuiltinElement) {
					addImpliedAndExpandedProperties((BuiltinElement)((ProxyNode)agi).getProxyFor());
				}
			}
			gpe.setRightImpliedPropertyUsed(null);
		}
		else if (gpe instanceof TripleElement) {
			Node objNode = ((TripleElement)gpe).getObject();
			TripleElement newTriple = new TripleElement(objNode, rip, null);
			((TripleElement)gpe).setObject(SadlModelProcessor.nodeCheck(newTriple));
			gpe.setRightImpliedPropertyUsed(null);
		}
		else {
			throw new TranslationException("Unexpected GraphPatternElement (" + gpe.getClass().getCanonicalName() + ") encountered applying implied property");
		}
	}

	private GraphPatternElement applyExpandedProperties(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<NamedNode> eps = gpe.getExpandedPropertiesToBeUsed();
		List<GraphPatternElement> junctionMembers = null;
		JunctionType jcttype = JunctionType.Conj;
		if (gpe instanceof BuiltinElement && eps.size() > 1) {
			if (((BuiltinElement)gpe).getFuncType().equals(BuiltinType.NotEqual)) {
				if (((BuiltinElement)gpe).getFuncName().equals("assign")) {
					throw new TranslationException("Can't have disjunction in assignment");
				}
				jcttype = JunctionType.Disj;
			}
			junctionMembers = new ArrayList<GraphPatternElement>();
		}
		
		if (gpe instanceof BuiltinElement) {
			if (((BuiltinElement)gpe).getArguments() == null || ((BuiltinElement)gpe).getArguments().size() != 2) {
				throw new TranslationException("Expanded properties can't be applied to a BuiltinElement with other than 2 arguments");
			}
			int expPropCntr = 0;
			List<Node> originalArgs = new ArrayList<Node>();
			for (NamedNode ep : eps) {
				BuiltinElement workingGpe = (BuiltinElement) gpe;
				if (expPropCntr == 0) {
					for (int i = 0; i < ((BuiltinElement)workingGpe).getArguments().size(); i++) {
						Node agi = ((BuiltinElement)workingGpe).getArguments().get(i);
						if (agi instanceof ProxyNode && ((ProxyNode)agi).getProxyFor() instanceof BuiltinElement) {
							addImpliedAndExpandedProperties((BuiltinElement)((ProxyNode)agi).getProxyFor());
						}
						originalArgs.add(agi);
					}
				}
				else {
					workingGpe = new BuiltinElement();
					workingGpe.setFuncName(((BuiltinElement) gpe).getFuncName());
					workingGpe.setFuncType(((BuiltinElement) gpe).getFuncType());
					for (int i = 0; i < ((BuiltinElement) gpe).getArguments().size(); i++) {
						workingGpe.addArgument(originalArgs.get(i));
					}
				}
				Node arg0 = ((BuiltinElement)workingGpe).getArguments().get(0);
				if (arg0 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg0))) {
					TripleElement newTriple = singlePropertyToTriple((NamedNode)arg0);
					arg0 = SadlModelProcessor.nodeCheck(newTriple);
				}
				TripleElement newTriple1 = new TripleElement(arg0, ep, null);
				arg0 = SadlModelProcessor.nodeCheck(newTriple1);
				((BuiltinElement)workingGpe).getArguments().set(0, arg0);			

				Node arg1 = ((BuiltinElement)workingGpe).getArguments().get(1);
				if (arg1 instanceof NamedNode && getModelProcessor().isProperty(((NamedNode)arg1))) {
					TripleElement newTriple = singlePropertyToTriple((NamedNode)arg1);
					arg1 = SadlModelProcessor.nodeCheck(newTriple);
				}
				TripleElement newTriple2 = new TripleElement(arg1, ep, null);
				arg1 = SadlModelProcessor.nodeCheck(newTriple2);
				((BuiltinElement)workingGpe).getArguments().set(1, arg1);	
				
				((BuiltinElement)workingGpe).setExpandedPropertiesToBeUsed(null);
				if (junctionMembers != null) {
					junctionMembers.add(workingGpe);
				}
				expPropCntr++;
			}
			if (junctionMembers != null) {
				if (jcttype.equals(JunctionType.Conj)) {
					gpe = (GraphPatternElement) listToAnd(junctionMembers).get(0);
				}
				else {
					gpe = listToOr(junctionMembers);
				}
			}
		}
		else if (gpe instanceof TripleElement) {
			Node objNode = ((TripleElement)gpe).getObject();
			if (!(objNode instanceof ConstantNode && ((ConstantNode)objNode).getName().equals(SadlConstants.CONSTANT_NONE))) {		
				int i = 0;
			}
		}
		else {
			// expanded properties can only apply to equality/inequality and assignment, so no other GraphPatternElement type should be encountered
			throw new TranslationException("Unexpeced non-BuiltinElement has expanded properties");
		}
		gpe.setExpandedPropertiesToBeUsed(null);
		return gpe;
	}

	private TripleElement singlePropertyToTriple(NamedNode prop) {
		VariableNode nvar = null; //new VariableNode(getNewVar());
		TripleElement newTriple = new TripleElement(nvar, prop, null);
		return newTriple;
	}

	private List<NamedNode> getNamedNodeList(List<NamedNode> found, GraphPatternElement gpe) {
		if (gpe instanceof TripleElement) {
			found = addNamedNode(found, ((TripleElement)gpe).getSubject());
			found = addNamedNode(found, ((TripleElement)gpe).getObject());
		}
		else if (gpe instanceof BuiltinElement) {
			if (((BuiltinElement)gpe).getArguments() != null) {
				for (int i = 0; i < ((BuiltinElement)gpe).getArguments().size(); i++) {
					found = addNamedNode(found, ((BuiltinElement)gpe).getArguments().get(i));
				}
			}
		}
		else if (gpe instanceof Junction) {
			Object lhs = ((Junction)gpe).getLhs();
			if (lhs instanceof Node) {
				found = addNamedNode(found, (Node) lhs);
			}
			Object rhs = ((Junction)gpe).getRhs();
			if (rhs instanceof Node) {
				found = addNamedNode(found, (Node) rhs);
			}
		}
		return found;
	}

	private List<NamedNode> addNamedNode(List<NamedNode> found, Node node) {
		if (node instanceof NamedNode && !(node instanceof VariableNode)) {
			if (found == null) found = new ArrayList<NamedNode>();
			found.add((NamedNode)node);
		}
		return found;
	}

	private List<GraphPatternElement> decorateCRuleVariables(List<GraphPatternElement> gpes, boolean isRuleThen) {
		for (int i = 0; i < gpes.size(); i++) {
			Object premise = gpes.get(i);
			if (premise instanceof BuiltinElement) {
				if (((BuiltinElement)premise).getArguments() != null) {
					for (Node n: ((BuiltinElement)premise).getArguments()) {
						if (n instanceof VariableNode && ((VariableNode)n).isCRulesVariable() && ((VariableNode)n).getType() != null && !isCruleVariableInTypeOutput((VariableNode) n)) {
							TripleElement newTypeTriple = new TripleElement(n, new RDFTypeNode(), ((VariableNode)n).getType());
							gpes.add(++i, newTypeTriple);
							addCruleVariableToTypeOutput((VariableNode) n);
							if (!isRuleThen) {
								try {
									i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) n);
								} catch (TranslationException e) {
									// TODO Auto-generated catch block
									e.printStackTrace();
								}
							}
						}
					}
				}
			}
			else if (premise instanceof TripleElement) {
				try {
					TripleElement gpe = (TripleElement) premise;
					Node subj = gpe.getSubject();
					Node obj = gpe.getObject();
					if (subj instanceof VariableNode && ((VariableNode)subj).isCRulesVariable() && ((VariableNode)subj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) subj)) {
						TripleElement newTypeTriple = new TripleElement(subj, new RDFTypeNode(), ((VariableNode)subj).getType());
						gpes.add(i++, newTypeTriple);
						addCruleVariableToTypeOutput((VariableNode) subj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) subj);
						}
					}
					if (obj instanceof VariableNode && ((VariableNode)obj).isCRulesVariable() && ((VariableNode)obj).getType() != null && !isCruleVariableInTypeOutput((VariableNode) obj)) {
						TripleElement newTypeTriple = new TripleElement(obj, new RDFTypeNode(), ((VariableNode)obj).getType());
						gpes.add(++i, newTypeTriple);
						addCruleVariableToTypeOutput((VariableNode) obj);
						if (!isRuleThen) {
							i = addNotEqualsBuiltinsForNewCruleVariable(gpes, i, (VariableNode) obj);
						}
					}
				} catch (TranslationException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		return gpes;
	}

	private List<GraphPatternElement> flattenRuleJunctions(List<GraphPatternElement> lst) {
		if (lst == null) return null;
		List<GraphPatternElement> results = new ArrayList<GraphPatternElement>();
		for (int i = 0; i < lst.size(); i++) {
			GraphPatternElement gpe = lst.get(i);
			if (gpe instanceof Junction) {
				if (((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					try {
						results.addAll(flattenRuleJunction((Junction) gpe));
					} catch (TranslationException e) {
						addError(new IFTranslationError(e.getMessage(), e));
					}
				}
				else {
//					addError(new IFTranslationError("Disjunction not supported in rules at this time"));
					// leave this error checking for the final translations step--some rules may support disjunction
					results.add(gpe);
				}
			}
//			else if (gpe instanceof BuiltinElement && 
//					((BuiltinElement)gpe).getFuncName() != null && ((BuiltinElement)gpe).getFuncName().equals("and")) {
//				List<Node> args = ((BuiltinElement)gpe).getArguments();
//				for (int j = 0; j <= args.size(); j++) {
//					Node nj = args.get(j);
//				}
//			}
			else {
				results.add(gpe);
			}
		}
		return results;
	}

	private List<GraphPatternElement> flattenRuleJunction(Junction jct) throws TranslationException {
		List<GraphPatternElement>results = new ArrayList<GraphPatternElement>();
		if (!jct.getJunctionType().equals(JunctionType.Conj)) {
//			addError(new IFTranslationError("Disjunction not supported in rules at this time"));
			// this is up to the target translator to decide, not the Intermediate Form Translator
			results.add(jct);
			return results;
		}
		Object lhs = jct.getLhs();
		if (lhs instanceof ProxyNode) {
			lhs = ((ProxyNode)lhs).getProxyFor();
		}
		if (lhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)lhs));
		}
		else if (lhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) lhs);
		}
		else if (lhs instanceof List<?>) {
			for (int i = 0; i < ((List<?>)lhs).size(); i++) {
				results.add((GraphPatternElement) ((List<?>)lhs).get(i));
			}
		}
		else {
			throw new TranslationException("Encountered non-GraphPatternElement during rule translation");
		}
		Object rhs = jct.getRhs();
		if (rhs instanceof ProxyNode) {
			rhs = ((ProxyNode)rhs).getProxyFor();
		}
		if (rhs instanceof Junction) {
			results.addAll(flattenRuleJunction((Junction)rhs));
		}
		else if (rhs instanceof GraphPatternElement) {
			results.add((GraphPatternElement)rhs);
		}
		else if (rhs instanceof List<?>) {
			for (int i = 0; i < ((List<?>)rhs).size(); i++) {
				results.add((GraphPatternElement) ((List<?>)rhs).get(i));
			}
		}
		else {
			throw new TranslationException("Encountered non-GraphPatternElement during rule translation");
		}
		return results;
	}

	/**
	 * Method to remove GPE's with isEmbedded true from thens to ifs
	 * 
	 * @param rule
	 * @param results
	 * @param tgpe
	 * @return
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private List<?> moveEmbeddedGPEsToIfs(Rule rule, List<?> results,
			GraphPatternElement tgpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (tgpe.isEmbedded()) {
			results.remove(tgpe);
			rule.getIfs().add(tgpe);			
		}
		else {
			if (tgpe instanceof Junction) {
				int idx = results.indexOf(tgpe);
				GraphPatternElement newtgpe = moveEmbeddedFromJunction(rule, (Junction)tgpe);
				if (newtgpe == null) {
					results.remove(idx);
				}
				else if (newtgpe != tgpe) {
					((List<GraphPatternElement>)results).set(idx, newtgpe);
				}
			}
		}
		return results;
	}

	/**
	 * Method to move all embedded GPEs in a Junction to the rule ifs and return whatever should be put in 
	 * the Junction's place or null if nothing.
	 * 
	 * @param rule
	 * @param tgpe
	 * @return
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private GraphPatternElement moveEmbeddedFromJunction(Rule rule,
			Junction tgpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean lhsRemoved = false;
		boolean rhsRemoved = false;
		Object lhs = ((Junction)tgpe).getLhs();
		Object rhs = ((Junction)tgpe).getRhs();
		if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) lhs);
			lhsRemoved = true;
		}
		else if (lhs instanceof Junction) {
			lhs = moveEmbeddedFromJunction(rule, (Junction) lhs);
		}
		if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) rhs);
			rhsRemoved = true;
		}
		else if (rhs instanceof Junction) {
			rhs = moveEmbeddedFromJunction(rule, (Junction) rhs);
		}
		if (lhsRemoved && rhsRemoved) {
			return null;
		}
		if (lhsRemoved) {
			return (GraphPatternElement) rhs;
		}
		if (rhsRemoved) {
			return (GraphPatternElement) lhs;
		}
		tgpe.setLhs(SadlModelProcessor.nodeCheck(lhs));
		tgpe.setRhs(SadlModelProcessor.nodeCheck(rhs));
		return tgpe;
	}

	/**
	 * This Map keeps track of the ProxyNodes that have been retired by GraphPatternElements, allowing the retired
	 * ProxyNode and its associated variable to be reused when that GraphPatternElement is revisited in another ProxyNode.
	 */
	private Map<GraphPatternElement, ProxyNode> retiredProxyNodes = new HashMap<GraphPatternElement, ProxyNode>();
	
	/**
	 * Top-level method for expanding ProxyNodes
	 * 
	 * @param pattern
	 * @param clearPreviousRetired TODO
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object expandProxyNodes(Object pattern, boolean isRuleThen, boolean clearPreviousRetired) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (clearPreviousRetired) {
			retiredProxyNodes.clear();
		}
		List<GraphPatternElement> patterns = new ArrayList<GraphPatternElement>();
		if (pattern instanceof List<?>) {
			for (int i = 0; i < ((List<?>)pattern).size(); i++) {
				expandProxyNodes(patterns, ((List<?>)pattern).get(i), isRuleThen);
			}
		}
		else {
			Object result = expandProxyNodes(patterns, pattern, isRuleThen);
			if (patterns.size() == 0) {
				return result;
			}
		}
		if (patterns.size() > 0) {
			patterns = decorateCRuleVariables((List<GraphPatternElement>) patterns, isRuleThen);
			if (!(getTarget() instanceof Test) && patterns.size() > 1) {
				patterns = listToAnd(patterns);
			}
		}
		return patterns;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#listToAnd(java.util.List)
	 */
	@Override
	public List<GraphPatternElement> listToAnd(
			List<GraphPatternElement> patterns) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (patterns == null || patterns.size() == 0) {
			return null;
		}
		if (patterns.size() == 1) {
			return patterns;
		}
		GraphPatternElement lhs = patterns.remove(0);
		if (lhs instanceof List<?>) {
			lhs = listToAnd((List<GraphPatternElement>) lhs).get(0);
		}
		Junction jand = new Junction();
		jand.setJunctionName("and");
		jand.setLhs(SadlModelProcessor.nodeCheck(lhs));
		if (patterns.size() > 1) {
			patterns = listToAnd(patterns);
		}
		GraphPatternElement rhs = patterns.get(0);
		if (rhs instanceof List<?>) {
			rhs = listToAnd((List<GraphPatternElement>) rhs).get(0);
		}
		jand.setRhs(SadlModelProcessor.nodeCheck(rhs));
		patterns.set(0, jand);
		return patterns;
	}

	private GraphPatternElement listToOr(List<GraphPatternElement> patterns) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (patterns == null || patterns.size() == 0) {
			return null;
		}
		if (patterns.size() == 1) {
			return patterns.get(0);
		}
		GraphPatternElement lhs = patterns.remove(0);
		Junction jor = new Junction();
		jor.setJunctionName("or");
		jor.setLhs(SadlModelProcessor.nodeCheck(lhs));
		GraphPatternElement rhs = listToOr(patterns);
		jor.setRhs(SadlModelProcessor.nodeCheck(rhs));
		return jor;
	}

	/**
	 * Second-level method for expanding ProxyNodes--this one has a list of the results passed in as an argument
	 * @param patterns
	 * @param pattern
	 * @param isRuleThen 
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, Object pattern, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (pattern instanceof ProxyNode) {
			return expandProxyNodes(patterns, ((ProxyNode)pattern).getProxyFor(), isRuleThen);
		}
		if (pattern instanceof TripleElement) {
			return expandProxyNodes(patterns,(TripleElement)pattern, isRuleThen);
		}
		else if (pattern instanceof BuiltinElement) {
			return expandProxyNodes(patterns, (BuiltinElement)pattern, isRuleThen);
		}
		else if (pattern instanceof Literal) {
			return pattern;
		}
		else if (pattern instanceof Junction) {
			Object retval = null;
			// remember what we have so far and create a new pattern list for each side of the Junction
			List<GraphPatternElement> existingPatterns = patterns;
			List<GraphPatternElement> lhsPatterns = new ArrayList<GraphPatternElement>();
			List<GraphPatternElement> rhsPatterns = new ArrayList<GraphPatternElement>();
			
			// get the two sides
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			
			// at least handle the interesting special case where they  are literals
			
			if (lhs instanceof Literal) {
				BuiltinElement lhsbe = new BuiltinElement();
				lhsbe.setFuncName("==");
				lhsbe.setCreatedFromInterval(true);
				lhsbe.addArgument(SadlModelProcessor.nodeCheck(lhs));
				((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhsbe));
			}
			else {
				expandProxyNodes(lhsPatterns, lhs, isRuleThen);
				if (lhsPatterns.size() == 1) {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhsPatterns.get(0)));
				}
				else if (lhsPatterns.size() < 1) {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(lhs));
				}
				else {
					((Junction)pattern).setLhs(SadlModelProcessor.nodeCheck(listToAnd(lhsPatterns).get(0)));
	//				throw new TranslationException("LHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			
			if (rhs instanceof Literal) {
				BuiltinElement rhsbe = new BuiltinElement();
				rhsbe.setFuncName("==");
				rhsbe.setCreatedFromInterval(true);
				rhsbe.addArgument(SadlModelProcessor.nodeCheck(rhs));
				retval = SadlModelProcessor.nodeCheck(rhsbe);
				((Junction)pattern).setRhs(retval);
			}
			else {
				retval = expandProxyNodes(rhsPatterns, rhs, isRuleThen);
				if (rhsPatterns.size() == 1) {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(rhsPatterns.get(0)));
				}
				else if (rhsPatterns.size() < 1) {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(rhs));
				}
				else {
					((Junction)pattern).setRhs(SadlModelProcessor.nodeCheck(listToAnd(rhsPatterns).get(0)));
	//				throw new TranslationException("RHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			patterns = existingPatterns;
			patterns.add((Junction)pattern);
			return retval;
		}
		return patterns;
	}
	
	/**
	 * If a triple has a null, fill it with a variable (search the patterns list first to avoid duplicates), 
	 *  add the triple to the patterns list, and return the variable. The variable also replaces the proxy node 
	 *  that contained this triple.
	 * @param patterns
	 * @param te
	 * @param expType
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, TripleElement te, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(te);
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		Node subj = te.getSubject();
		if (subj instanceof ProxyNode) {
			if (retiredNode != null) {
				subj = returnNode = retiredNode;
			}
			else if (((ProxyNode)subj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)subj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)subj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)subj).getProxyFor(), (ProxyNode) subj);
				}
				subj = returnNode = ((ProxyNode)subj).getReplacementNode();
			}
			else {
				Object realSubj = ((ProxyNode)subj).getProxyFor();
				Object subjNode = expandProxyNodes(patterns, realSubj, isRuleThen);
				if (subjNode == null && realSubj instanceof TripleElement) {
					if (((TripleElement)realSubj).getObject() instanceof VariableNode) {
						subjNode = ((TripleElement)realSubj).getObject();
					}
					else if (te.getSourceType() != null && te.getSourceType().equals(TripleSourceType.SPV)) {
						subjNode = ((TripleElement)realSubj).getSubject();
					}
				}
				((ProxyNode)subj).setReplacementNode(SadlModelProcessor.nodeCheck(subjNode));
				retiredProxyNodes.put((GraphPatternElement) realSubj, (ProxyNode)subj);
				subj = SadlModelProcessor.nodeCheck(subjNode);
				if (realSubj instanceof TripleElement && ((TripleElement)realSubj).getSourceType() != null && 
						((TripleElement)realSubj).getSourceType().equals(TripleSourceType.ITC)) {
					returnNode = subj;
				}
			}
			te.setSubject(subj);
			patterns.add(te);
		}
		else if (subj == null) {
			// this is a triple with a need for a variable for subject
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), te.getObject(), true);
			te.setSubject(returnNode);
			// TODO when this is nested the triple (te) needs to be inserted before the returnNode is used
			patterns.add(te);
		}
		Node obj = te.getObject();
		if (obj instanceof ProxyNode) {
			int initialPatternLength = patterns == null ? 0 : patterns.size();
			if (retiredNode != null) {
				obj = returnNode = retiredNode;
			}
			else if (((ProxyNode)obj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)obj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)obj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)obj).getProxyFor(), (ProxyNode) obj);
				}
				obj = returnNode = ((ProxyNode)obj).getReplacementNode();
			}
			else {
				Object realObj = ((ProxyNode)obj).getProxyFor();
				List<GraphPatternElement> rememberedPatterns = null;
				if (realObj instanceof BuiltinElement && isRuleThen) {
					rememberedPatterns = patterns;
					patterns = new ArrayList<GraphPatternElement>();
				}
				Object objNode = expandProxyNodes(patterns, realObj, isRuleThen);
				if (objNode == null && ((ProxyNode)obj).getReplacementNode() != null) {
					// This can happen because the proxy node gets processed but not returned
					objNode = ((ProxyNode)obj).getReplacementNode();
				}
				if (objNode == null && (realObj instanceof BuiltinElement 
						|| (realObj instanceof Junction && ((Junction)realObj).getLhs() instanceof BuiltinElement 
								&& ((Junction)realObj).getRhs() instanceof BuiltinElement))) {
					List<BuiltinElement> builtins = new ArrayList<BuiltinElement>();
					Node newNode = null;
					if (realObj instanceof BuiltinElement) {
						builtins.add((BuiltinElement)realObj);
						newNode = getVariableNode((BuiltinElement)realObj);
					}
					else {
						builtins.add((BuiltinElement)((Junction)realObj).getLhs());
						newNode = getVariableNode(builtins.get(0));
						builtins.add((BuiltinElement)((Junction)realObj).getRhs());
					}
					for (int i = 0; i < builtins.size(); i++) {
						BuiltinElement bi = builtins.get(i);
						if (bi.isCreatedFromInterval()) {
							bi.addArgument(0, newNode);
						}
						else {
							bi.addArgument(newNode);
						}
					}
					objNode = newNode;
					if (isRuleThen) {
						addToPremises(patterns);
						patterns = rememberedPatterns;
					}
				}
				if (objNode == null) {
					addError(new IFTranslationError("Translation to Intermediate Form failed: " + te.toString()));
				}
				((ProxyNode)obj).setReplacementNode(SadlModelProcessor.nodeCheck(objNode));
// TODO this has a problem, run on 	TestSadlIde/Sandbox/UnionClassInRule.sadl			
				retiredProxyNodes.put((GraphPatternElement) ((ProxyNode)obj).getProxyFor(), (ProxyNode)obj);
				obj = SadlModelProcessor.nodeCheck(objNode);
			}
			te.setObject(obj);
			if (!patterns.contains(te)) {
				if (getTarget() instanceof Rule) {
					patterns.add(te);
				}
				else {
					patterns.add(Math.max(0, initialPatternLength - 1), te);
				}
			}
		}
		else if (obj == null) {
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), obj, false);
			te.setObject(returnNode);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
		}

		if (te.getNext() != null) {
			GraphPatternElement nextGpe = te.getNext();
			te.setNext(null);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			Object nextResult = expandProxyNodes(patterns, nextGpe, isRuleThen);
			// TODO we don't need to do anything with this, right?
		}
	
		// Special case: a pivot triple ( something type something): return the subject
		if (te instanceof TripleElement && (((TripleElement)te).getPredicate()) instanceof RDFTypeNode) {
			// this is an embedded type triple; only the subject can be a subject of the higher-level pattern
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			return ((TripleElement)te).getSubject();
		}

		// This is to make sure that complete, self-contained triple elements are still added to the output
		if (!patterns.contains(te)) {
			patterns.add(te);
		}
		if (retiredNode != null) {
			return retiredNode;
		}
		return returnNode;
	}
	
	/**
	 * This method is currently just a placeholder for finding variables for reuse in built-in patterns.
	 * Currently it just creates a new variable with a new name.
	 * @param bltin
	 * @return
	 */
	protected VariableNode getVariableNode(BuiltinElement bltin) {
		if (getTarget() != null) {
			
		}
		return new VariableNode(getNewVar());
	}
	
	/**
	 * This method looks in the clauses of a Rule to see if there is already a triple matching the given pattern. If there is
	 * a new variable of the same name is created (to make sure the count is right) and returned. If not a rule or no match
	 * a new variable (new name) is created and returned.
	 * @param subject
	 * @param predicate
	 * @param object
	 * @param varIsSubject 
	 * @return
	 */
	protected VariableNode getVariableNode(Node subject, Node predicate, Node object, boolean varIsSubject) {
		VariableNode var = findVariableInTargetForReuse(subject, predicate, object);
		if (var != null) {
//			return new VariableNode(var.getName());
			return var;
		}
		if (predicate != null) {
			var = new VariableNode(getNewVar());
			Property prop = this.getTheJenaModel().getProperty(predicate.toFullyQualifiedString());
			try {
				ConceptName propcn = new ConceptName(predicate.toFullyQualifiedString());
				propcn.setType(ConceptType.RDFPROPERTY);  	// assume the most general
				if (varIsSubject) {
					// type is domain
					TypeCheckInfo dtci = getModelValidator().getTypeInfoFromDomain(propcn, prop, null);
					if (dtci != null && dtci.getTypeCheckType() != null) {
						Node tcitype = dtci.getTypeCheckType();
						if (tcitype instanceof NamedNode) {
							NamedNode defn;
							defn = new NamedNode(((NamedNode)tcitype).toFullyQualifiedString(), ((NamedNode)tcitype).getNodeType());
							var.setType(modelProcessor.validateNode(defn));
						}
						else {
							addError(new IFTranslationError("Domain type did not return a ConceptName."));
						}
					}
				}
				else {
					// type is range
					TypeCheckInfo dtci;
					dtci = getModelValidator().getTypeInfoFromRange(propcn, prop, null);
					if (dtci != null && dtci.getTypeCheckType() != null) {
						Node tcitype = dtci.getTypeCheckType();
						if (tcitype instanceof NamedNode) {
							NamedNode defn;
							defn = new NamedNode(((NamedNode)tcitype).toFullyQualifiedString(), ((NamedNode)tcitype).getNodeType());
							var.setType(modelProcessor.validateNode(defn));
						}
						else {
							addError(new IFTranslationError("Range type did not return a ConceptName."));
						}
					}
				}

			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (DontTypeCheckException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
		return var;
	}
	
	protected VariableNode findVariableInTargetForReuse(Node subject, Node predicate, Node object) {
		// Note: when we find a match we still create a new VariableNode with the same name in order to have the right reference counts for the new VariableNode
		if (getTarget() instanceof Rule) {
			VariableNode var = findVariableInTripleForReuse(((Rule)getTarget()).getGivens(), subject, predicate, object);
			if (var != null) {
				return var;
			}
			var = findVariableInTripleForReuse(((Rule)getTarget()).getIfs(), subject, predicate, object);
			if (var != null) {
				return var;
			}
			var = findVariableInTripleForReuse(((Rule)getTarget()).getThens(), subject, predicate, object);
			if (var != null) {
				return var;
			}
		}
		return null;
	}

	private JenaBasedSadlModelValidator getModelValidator() throws TranslationException {
		if (getModelProcessor() != null) {
			return getModelProcessor().getModelValidator();
		}
		return null;
	}

	/**
	 * Supporting method for the method above (getVariableNode(Node, Node, Node))
	 * @param gpes
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode findVariableInTripleForReuse(List<GraphPatternElement> gpes, Node subject, Node predicate, Node object) {
		if (gpes != null) {
			Iterator<GraphPatternElement> itr = gpes.iterator();
			while (itr.hasNext()) {
				GraphPatternElement gpe = itr.next();
				VariableNode var = findVariableInTargetForReuse(gpe, subject, predicate, object);
				if (var != null) {
					return var;
				}
			}
		}
		return null;
	}
	
	
	private VariableNode findVariableInTargetForReuse(GraphPatternElement gpe, Node subject, Node predicate, Node object) {
		while (gpe != null) {
			if (gpe instanceof TripleElement) {
				VariableNode var = findVariableInTripleForReuse((TripleElement)gpe, subject, predicate, object);
				if (var != null) {
					return var;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				if (args != null) {
					for (Node arg: args) {
						if (arg instanceof ProxyNode && ((ProxyNode)arg).getProxyFor() instanceof GraphPatternElement) {
							VariableNode var = findVariableInTargetForReuse((GraphPatternElement)((ProxyNode)arg).getProxyFor(), subject, predicate, object);
							if (var != null) {
								return var;
							}
						}
					}
				}
			}
			else if (gpe instanceof Junction) {
				Object lhs = ((Junction)gpe).getLhs();
				if (lhs instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)lhs, subject, predicate, object);
					if (var != null) {
						return var;
					}
				}
				Object rhs = ((Junction)gpe).getRhs();
				if (rhs instanceof GraphPatternElement) {
					VariableNode var = findVariableInTargetForReuse((GraphPatternElement)rhs, subject, predicate, object);
					if (var != null) {
						return var;
					}
				}
			}
			gpe = gpe.getNext();
		}
		return null;
	}

	protected VariableNode findVariableInTripleForReuse(TripleElement tr, Node subject, Node predicate, Node object) {
		Node tsn = tr.getSubject();
		Node tpn = tr.getPredicate();
		Node ton = tr.getObject();
		if (subject == null && tsn instanceof VariableNode) {
			if (predicate != null && predicate.equals(tpn) && object != null && object.equals(ton)) {
				return (VariableNode) tsn;
			}
		}
		if (predicate == null && tpn instanceof VariableNode) {
			if (subject != null && subject.equals(tsn) && object != null && object.equals(ton)) {
				return (VariableNode) tpn;
			}
		}
		if (object == null && ton instanceof VariableNode) {
			if (subject != null && subject.equals(tsn) && predicate != null && predicate.equals(tpn)) {
				return (VariableNode) ton;
			}
		}
		return null;
	}
	
	protected String getNewVar() {
		String proposedName = "v" + vNum;
		while (userDefinedVariables.contains(proposedName)
//				||
//				!modelManager.getConceptType(proposedName).equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)
		) {
			vNum++;
			proposedName = "v" + vNum;
		}
		vNum++;
		return proposedName;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setStartingVariableNumber(int)
	 */
	@Override
	public void setStartingVariableNumber(int vn) {
		vNum = vn;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#getVariableNumber()
	 */
	@Override
	public int getVariableNumber() {
		return vNum;
	}
	
	private Node findMatchingElementInRetiredProxyNodes(GraphPatternElement ge) {
		if (retiredProxyNodes != null) {
			if (retiredProxyNodes.get(ge) != null) {
				return retiredProxyNodes.get(ge);
			}
			else {
				if (ge instanceof TripleElement && !(((TripleElement)ge).getPredicate() instanceof RDFTypeNode)) {
					TripleElement te = (TripleElement) ge;
					Iterator<GraphPatternElement> itr = retiredProxyNodes.keySet().iterator();
					while (itr.hasNext()) {
						GraphPatternElement gpe = itr.next();
						if (gpe instanceof TripleElement && !(((TripleElement)gpe).getPredicate() instanceof RDFTypeNode)) {
							if ((te.getSubject() == null || te.getSubject().equals(((TripleElement)gpe).getSubject()))
									&& (te.getPredicate() == null || te.getPredicate().equals(((TripleElement)gpe).getPredicate()))
									&& (te.getObject() == null || te.getObject().equals(((TripleElement)gpe).getObject()))) {
								ProxyNode pn = retiredProxyNodes.get(gpe);
								return pn.getReplacementNode();
							}
						}
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to handle BuiltinElements--if the 
	 * @param patterns
	 * @param be
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected Object expandProxyNodes(List<GraphPatternElement> patterns, BuiltinElement be, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		int patternsSize = patterns != null ? patterns.size() : 0;
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(be);
		if (isRuleThen && (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign))
				&& be.getArguments() != null && be.getArguments().size() == 2
				&& be.getArguments().get(0) instanceof ProxyNode && be.getArguments().get(1) instanceof ProxyNode) {
			ProxyNode arg1PN = (ProxyNode) be.getArguments().get(0);
			ProxyNode arg2PN = (ProxyNode) be.getArguments().get(1);
			Object realArgForThen = arg1PN.getProxyFor();
			Object realArgForIfs = arg2PN.getProxyFor();
			int tripleWithObjectNullCount = 0;
			if (realArgForThen instanceof TripleElement && realArgForIfs instanceof TripleElement) {
//				// args can be TripleElement only if both are and objects are both null
				if (((TripleElement)realArgForThen).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (((TripleElement)realArgForIfs).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (tripleWithObjectNullCount == 1) {
					addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + be.toString() + "); try separating rule elements with ands."));

				}
			}
			List<GraphPatternElement> moveToIfts = new ArrayList<GraphPatternElement>();
			Object finalIfsVar = expandProxyNodes(moveToIfts, realArgForIfs, false);
			if (finalIfsVar == null && realArgForIfs instanceof BuiltinElement) {
				Node newNode = getVariableNode((BuiltinElement)realArgForIfs);
				((BuiltinElement)realArgForIfs).addArgument(newNode);
				finalIfsVar = newNode;
				((ProxyNode)arg1PN).setReplacementNode(SadlModelProcessor.nodeCheck(finalIfsVar));
				retiredProxyNodes.put((GraphPatternElement) realArgForIfs, arg1PN);
			}
			if (realArgForThen instanceof TripleElement && ((TripleElement)realArgForThen).getObject() == null) {
				Object finalThensVar = expandProxyNodes(patterns, realArgForThen, isRuleThen);
				((TripleElement)realArgForThen).setObject(SadlModelProcessor.nodeCheck(finalIfsVar));
				if (!patterns.contains((TripleElement)realArgForThen)) {
					patterns.add((TripleElement)realArgForThen);
				}
				if (be.getFuncName().equals("assign")) {
					((TripleElement)realArgForThen).setType(TripleModifierType.Assignment);
				}
			}
			else if (realArgForThen instanceof BuiltinElement && ((BuiltinElement)realArgForThen).getArguments() != null) {
				if (((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1) == null) {
					((BuiltinElement)realArgForThen).getArguments().set(((BuiltinElement)realArgForThen).getArguments().size() - 1, SadlModelProcessor.nodeCheck(finalIfsVar));
				}
				else if (((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1) instanceof ProxyNode &&
						((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor() instanceof TripleElement &&
						((TripleElement)((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor()).getObject() == null) {
					((TripleElement)((ProxyNode)((BuiltinElement)realArgForThen).getArguments().get(((BuiltinElement)realArgForThen).getArguments().size() - 1)).getProxyFor()).setObject(SadlModelProcessor.nodeCheck(finalIfsVar));
				}
				else {
					throw new TranslationException("Unhandled condition, LHS of Equal in Then isn't a BuiltinElement that needs an argument: " + realArgForThen.toString());
				}
			}
			else if (realArgForThen instanceof Junction) {
				List<GraphPatternElement> lst = junctionToList((Junction)realArgForThen);
				GraphPatternElement last = lst.remove(lst.size() - 1);
				moveToIfts.addAll(lst);
				patterns.add(last);
			}
			else if (realArgForThen instanceof GraphPatternElement){
				moveToIfts.add((GraphPatternElement) realArgForThen);
			}
			if (!addToPremises(moveToIfts)) {
				patterns.addAll(patternsSize, moveToIfts);
			}
			return null;
		}
		else if (getTarget() instanceof Rule && (be.getFuncType().equals(BuiltinType.Equal) || be.getFuncType().equals(BuiltinType.Assign))) {
			if (be.getArguments().size() == 2) {  // this should always be true
				if (be.getArguments().get(0) instanceof VariableNode && be.getArguments().get(1) instanceof ProxyNode) {
					Object realArg2 = ((ProxyNode)be.getArguments().get(1)).getProxyFor();
					if (realArg2 instanceof BuiltinElement) {
						((BuiltinElement)realArg2).addArgument(be.getArguments().get(0)); // the variable goes to return from arg 2 builtin and this builtin goes away
						return expandProxyNodes(patterns, realArg2, isRuleThen);
					}
					else if (realArg2 instanceof TripleElement && ((TripleElement)realArg2).getObject() == null) {
						((TripleElement)realArg2).setObject(be.getArguments().get(0));  // the variable goes to the object of the arg 2 triple and this builtin  goes away
						return expandProxyNodes(patterns, realArg2, isRuleThen);
					}
				}
				else if ((be.getArguments().get(1) instanceof Literal || be.getArguments().get(1) instanceof ConstantNode || 
						(be.getArguments().get(1) instanceof NamedNode && ((NamedNode)be.getArguments().get(1)).getNodeType().equals(NodeType.InstanceNode))) && 
						be.getArguments().get(0) instanceof ProxyNode && 
						((ProxyNode)be.getArguments().get(0)).getProxyFor() instanceof TripleElement &&
						((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).getObject() == null) {
					((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()).setObject(be.getArguments().get(1));
					patterns.add(((TripleElement)((ProxyNode)be.getArguments().get(0)).getProxyFor()));
					return null;
				}
			}
		}
		
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		List<Node> args = be.getArguments();
		for (int i = 0; args != null && i < args.size(); i++) {
			Node arg = args.get(i);
			if (arg == null) {
				VariableNode var = new VariableNode(getNewVar());
				args.set(i, var);
				returnNode = var;
			}
			else if (arg instanceof ProxyNode) {
				if (retiredNode != null) {
					args.set(i, retiredNode);
				}
				else {
					Object realArg = ((ProxyNode)arg).getProxyFor();
					Object argNode = expandProxyNodes(patterns, realArg, isRuleThen);
					if (argNode == null) {
						if (realArg instanceof BuiltinElement) {
							if (be.getFuncType().equals(BuiltinType.Not)) {
								// don't put in an intermediate variable for negation of a builtin--if needed the language-specific translator will need to do that
								// the call above to expandProxyNodes might have put the argNode into the patterns; if so remove it
								if (patterns.get(patterns.size() - 1).equals(realArg)) {
									patterns.remove(patterns.size() - 1);
								}
							}
							else if (((BuiltinElement)realArg).getArguments() != null &&
									getModelProcessor().isBuiltinMissingArgument(((BuiltinElement)realArg).getFuncName(), ((BuiltinElement)realArg).getArguments().size())){
								Node newNode = getVariableNode((BuiltinElement)realArg);
								((BuiltinElement)realArg).addArgument(newNode);
								argNode = newNode;
								((ProxyNode)arg).setReplacementNode(SadlModelProcessor.nodeCheck(argNode));
								retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
								args.set(i, SadlModelProcessor.nodeCheck(argNode));
							}
						}
						else if (realArg instanceof TripleElement) {
							// don't do anything--keep proxy if triple, negate triple if "not" builtin
							if (patterns.get(patterns.size() - 1).equals(realArg)) {
								if (be.getFuncType().equals(BuiltinType.Not)) {
									((TripleElement)realArg).setType(TripleModifierType.Not);
									return realArg;	// "not" is a unary operator, so it is safe to assume this is the only argument
								}
								else if (be.getFuncName().equals(JenaBasedSadlModelProcessor.THERE_EXISTS) && ((TripleElement)realArg).getSubject() instanceof VariableNode){
									be.getArguments().set(0, ((TripleElement)realArg).getSubject());
									patterns.add(patterns.size() - 1, be);
									return null;
								}
							}
						}
						else if (realArg instanceof Junction) {
							patterns.remove(patterns.size() - 1);
						}
						else {
							throw new TranslationException("Unexpected real argument");
						}
					}
					else {
						((ProxyNode)arg).setReplacementNode(SadlModelProcessor.nodeCheck(argNode));
						if (realArg instanceof GraphPatternElement) {
							retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
						}
						else {
							throw new TranslationException("Expected GraphPatternElement in ProxyNode but got " + realArg.getClass().getCanonicalName());
						}
						args.set(i, SadlModelProcessor.nodeCheck(argNode));
					}
				}
			}
		}
		if (be.getFuncName().equals(JenaBasedSadlModelProcessor.THERE_EXISTS)) {
			if (patterns.size() == 0) {
				patterns.add(be);
			}
			else {
				patterns.add(patterns.size() - 1, be);
			}
			returnNode = be.getArguments().get(0);
		}
		else {
			removeArgsFromPatterns(patterns, be);
			patterns.add(be);
		}
		return returnNode;
	}

	private Object applyExpandedAndImpliedProperties(List<GraphPatternElement> patterns, BuiltinElement be,
			Object realArgForThen, List<GraphPatternElement> moveToIfts, Object finalIfsVar)
			throws TranslationException, InvalidNameException, InvalidTypeException {
		if (be.getExpandedPropertiesToBeUsed() != null) {
			// create a new VariableNode of the same type as finalIfsVar
			VariableNode thereExistsVar = getVariableNode(be);
			thereExistsVar.setType(((VariableNode)finalIfsVar).getType());
			((TripleElement)realArgForThen).setObject(thereExistsVar);
			BuiltinElement thereExistsBe = new BuiltinElement();
			thereExistsBe.setFuncName(JenaBasedSadlModelProcessor.THERE_EXISTS);
			thereExistsBe.addArgument(thereExistsVar);
			patterns.add(patterns.size() - 1, thereExistsBe);
			for (NamedNode ep: be.getExpandedPropertiesToBeUsed()) {
				VariableNode newVar = null;
				boolean createTriple = false;
				if (finalIfsVar instanceof Node) {
					newVar = findVariableInTargetForReuse((Node)finalIfsVar, ep, null);	
					if (newVar == null) {
						createTriple = true;
						newVar = getVariableNode(be);
					}
				}
				TripleElement epTriple = new TripleElement(SadlModelProcessor.nodeCheck(thereExistsVar), ep, newVar);
				patterns.add(epTriple);
				if (createTriple) {
					TripleElement epTriple2 = new TripleElement(SadlModelProcessor.nodeCheck(finalIfsVar), ep, newVar);
					moveToIfts.add(epTriple2);
				}
			}
		}
		else if (be.getLeftImpliedPropertyUsed() != null) {
			VariableNode newVar = null;
			boolean createTriple = false;
			if (finalIfsVar instanceof Node) {
				newVar = findVariableInTargetForReuse((Node) finalIfsVar, be.getLeftImpliedPropertyUsed(), null);
				if (newVar == null) {
					createTriple = true;
					newVar = getVariableNode((Node) finalIfsVar, be.getLeftImpliedPropertyUsed(), null, false);
				}
			}
			if (createTriple) {
				TripleElement epTriple = new TripleElement(SadlModelProcessor.nodeCheck(finalIfsVar), SadlModelProcessor.nodeCheck(be.getLeftImpliedPropertyUsed()), newVar);
				patterns.add(epTriple);
			}
			return newVar;
		}
		else if (be.getRightImpliedPropertyUsed() != null) {
			VariableNode newVar = null;
			boolean createTriple = false;
			if (finalIfsVar instanceof Node) {
				newVar = findVariableInTargetForReuse((Node)finalIfsVar, be.getRightImpliedPropertyUsed(), null);
				if (newVar == null) {
					createTriple = true;
					newVar =getVariableNode((Node) finalIfsVar, be.getRightImpliedPropertyUsed(), null, false);
				}
			}
			if (createTriple) {
				TripleElement epTriple = new TripleElement(SadlModelProcessor.nodeCheck(finalIfsVar), SadlModelProcessor.nodeCheck(be.getRightImpliedPropertyUsed()), newVar);
				moveToIfts.add(epTriple);
			}
			return newVar;
		}
		return null;
	}
	
	private void removeArgsFromPatterns(List<GraphPatternElement> patterns, BuiltinElement be) {
		if (patterns != null && patterns.size() > 0) {
			List<Node> args = be.getArguments();
			if (args != null) {
				for (Node arg:args) {
					Object effectiveArg = arg;
					if (arg instanceof ProxyNode) {
						effectiveArg = ((ProxyNode)arg).getProxyFor();
					}
					if (effectiveArg instanceof GraphPatternElement) {
						if (patterns.contains((GraphPatternElement)effectiveArg)) {
							patterns.remove((GraphPatternElement)effectiveArg);
						}
						if (effectiveArg instanceof BuiltinElement) {
							removeArgsFromPatterns(patterns, (BuiltinElement)effectiveArg);
						}
					}
				}
			}
		}
	}

	/**
	 * Combine the argument elements with the existing Rule Ifs elements
	 * @param moveToIfts
	 * @throws TranslationException 
	 */
	protected boolean addToPremises(List<GraphPatternElement> moveToIfts) throws TranslationException {
		if (getTarget() instanceof Rule) {
			List<GraphPatternElement> ifts = ((Rule)getTarget()).getIfs();
			if (ifts == null) {
				((Rule)getTarget()).setIfs(moveToIfts);
			}
			else {
				ifts.addAll(moveToIfts);
			}
			return true;
		}
		return false;
	}

	/**
	 * This method flattens out the GraphPatternElement List so that there are no
	 * next pointers within the list.
	 * 
	 * @param list - input GraphPatternElement List that may have chained elements inside it
	 * @return - the transformed list
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	private List<GraphPatternElement> flattenLinkedList(List<GraphPatternElement> list) throws InvalidNameException, InvalidTypeException, TranslationException {
		// go backwards through list so that the i index will remain valid
		for (int i = list.size() -1; i >= 0; i--) {
			GraphPatternElement element = list.get(i);
			if (element instanceof Junction) {
				flattenJunction((Junction)element);
			}
			GraphPatternElement nextElement = element.getNext();  // an internal chain
			int j = 0;
			while (nextElement != null) {
				element.setNext(null);
				list.add((1+i+(j++)),nextElement);
				element = nextElement;
				nextElement = element.getNext();
			}
		}
		return list;
	}
	
	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#flattenJunction(com.ge.research.sadl.model.gp.Junction)
	 */
	@Override
	public void flattenJunction(Junction element) throws InvalidNameException, InvalidTypeException, TranslationException {
		Object lhs = element.getLhs();
		if (lhs instanceof Junction) {
			flattenJunction((Junction)lhs);
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			element.setLhs(SadlModelProcessor.nodeCheck(flattenJunctionSide((GraphPatternElement) lhs)));
		}
		Object rhs = element.getRhs();
		if (rhs instanceof Junction) {
			flattenJunction((Junction)rhs);
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			element.setRhs(SadlModelProcessor.nodeCheck(flattenJunctionSide((GraphPatternElement) rhs)));
		}
	}
	
	private Object flattenJunctionSide(GraphPatternElement gpe) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (gpe.getNext() != null) {
			List<GraphPatternElement> lst = new ArrayList<GraphPatternElement>();
			lst.add(gpe);
			lst = flattenLinkedList(lst);
			return lst;
		}
		return gpe;
	}
	
	private void removeDuplicateElements(Rule rule) throws InvalidNameException, InvalidTypeException, TranslationException {
		List<GraphPatternElement> givens = rule.getGivens();
		List<GraphPatternElement> ifs = rule.getIfs();
		List<GraphPatternElement> thens = rule.getThens();
		removeDuplicates(thens, thens, true);		// remove anything duplicated in thens
//		removeDuplicates(thens, ifs, false);			// remove anything in ifs from thens
//		removeDuplicates(thens, givens, false);		// remove anything in givens from thens
		removeDuplicates(ifs, ifs, true);			// remove anything duplicated in ifs
		removeDuplicates(ifs, givens, false);		// remove anything in givens from ifs
		removeDuplicates(givens, givens, true);		// remove anything duplicated in givens
	}
	
	/**
	 * If an element in list1 is also in list2, remove the element from list1
	 * 
	 * @param list1
	 * @param list2
	 * @param bRetainFirst -- true if same lists; if same lists leave first occurance
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 * @throws InvalidNameException 
	 */
	protected int removeDuplicates(List<GraphPatternElement> list1, List<GraphPatternElement> list2, boolean bRetainFirst) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (list1 == null || list2 == null || list1.size() < 1 || list2.size() < 1) {
			return 0;
		}
		List<GraphPatternElement> flatList2 = getAllGPEs(list2);
		int removalCnt = 0;
		List<Integer> toBeRemoved = null;
		for (int idx2 = 0; idx2 < flatList2.size(); idx2++) {
			GraphPatternElement gpeToMatch = flatList2.get(idx2);	// this is the element we are considering for duplicate removals
			boolean foundFirst = false;
			for (int idx1 = 0; idx1 < list1.size(); idx1++) {
				GraphPatternElement gpe = list1.get(idx1);
				if (gpe.equals(gpeToMatch)) {
					if (!bRetainFirst || foundFirst) {
						if (toBeRemoved == null) {
							toBeRemoved = new ArrayList<Integer>();
						}
						if (!toBeRemoved.contains(idx1)) {
							toBeRemoved.add(idx1);
							removalCnt++;
						}
					}
					foundFirst = true;
				}
				else if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					Object[] results = removeJunctionDuplicates((Junction)gpe, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
					GraphPatternElement processedGpe = (GraphPatternElement) results[0];
					foundFirst = ((Boolean)results[1]).booleanValue();
					removalCnt = ((Integer)results[2]).intValue();
					if (!processedGpe.equals(gpe)) {
						list1.set(idx1, processedGpe);
					}
				}
			}
		}
		if (toBeRemoved != null) {
			Collections.sort(toBeRemoved);
			for (int i = (toBeRemoved.size() - 1); i >= 0; i--) {
				list1.remove(toBeRemoved.get(i).intValue());
			}
		}
		return removalCnt;
	}
	
	private Object[] removeJunctionDuplicates(Junction gpe, GraphPatternElement gpeToMatch, boolean bRetainFirst, boolean foundFirst, int removalCnt) throws InvalidNameException, InvalidTypeException, TranslationException {
		boolean lhsDuplicate = false;
		boolean rhsDuplicate = false;
		Object lhs = gpe.getLhs();
		if (lhs.equals(gpeToMatch)) {
			if(!bRetainFirst || foundFirst){
				lhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] lhsResults = removeJunctionDuplicates((Junction)lhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newLhs = (GraphPatternElement) lhsResults[0];
			foundFirst = ((Boolean)lhsResults[1]).booleanValue();
			removalCnt = ((Integer)lhsResults[2]).intValue();
			if (!newLhs.equals(lhs)) {
				gpe.setLhs(SadlModelProcessor.nodeCheck(newLhs));
			}
		}
		Object rhs = gpe.getRhs();
		if (rhs != null && rhs.equals(gpeToMatch)) {
			if (!bRetainFirst || foundFirst) {
				rhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] rhsResults = removeJunctionDuplicates((Junction)rhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newrhs = (GraphPatternElement) rhsResults[0];
			foundFirst = ((Boolean)rhsResults[1]).booleanValue();
			removalCnt = ((Integer)rhsResults[2]).intValue();
			if (!newrhs.equals(rhs)) {
				gpe.setRhs(SadlModelProcessor.nodeCheck(newrhs));
			}
		}
		Object[] results = new Object[3];
		if (lhsDuplicate) {
			results[0] = gpe.getRhs();
		}
		else if (rhsDuplicate) {
			results[0] = gpe.getLhs();
		}
		else {
			results[0] = gpe;
		}
		results[1] = new Boolean(foundFirst);
		results[2] = new Integer(removalCnt);
		return results;
	}

	private List<GraphPatternElement> getAllGPEs(List<GraphPatternElement> list) throws TranslationException {
		List<GraphPatternElement> results = null;
		for (int i = 0; list != null && i < list.size(); i++) {
			GraphPatternElement gpe = list.get(i);
			if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
				if (results != null) {
					results.addAll(junctionToList((Junction) gpe));
				}
				else {
					results = junctionToList((Junction) gpe);
				}
			}
			else {
				if (results == null) {
					results = new ArrayList<GraphPatternElement>();
				}
				results.add(gpe);
			}
		}
		if (results != null) {
			return results;
		}
		return list;
	}
	
	/**
	 * Method to convert a Junction to a List<GraphPatternElement>. Note that this method will either handle
	 * conjunction or disjunction at the top level but once the type is set the other type will not be converted
	 * to a list as if both were converted the results would be non-functional.
	 * @param gpe
	 * @return
	 * @throws TranslationException 
	 */
	public static List<GraphPatternElement> junctionToList(Junction gpe) throws TranslationException {
		if (gpe.getJunctionType().equals(JunctionType.Disj)) {
			return disjunctionToList(gpe);
		}
		boolean lhsGpe = true;
		boolean rhsGpe = true;
		List<GraphPatternElement> results = null;
		Object lhs = gpe.getLhs();
		if (lhs instanceof ProxyNode) lhs = ((ProxyNode)lhs).getProxyFor();
		if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			results = junctionToList((Junction)lhs);
		}
		else if (lhs instanceof GraphPatternElement) {
			results = new ArrayList<GraphPatternElement>();
			results.add((GraphPatternElement) lhs);
		}
		else {
			lhsGpe = false;
		}
		Object rhs = gpe.getRhs();
		if (rhs instanceof ProxyNode) rhs = ((ProxyNode)rhs).getProxyFor();
		if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			if (results != null) {
				results.addAll(junctionToList((Junction)rhs));
			}
			else {
				results = junctionToList((Junction)rhs);
			}
		}
		else if (rhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) rhs);
		}
		else {
			rhsGpe = false;
		}
		if (!lhsGpe && !rhsGpe) {
			results = new ArrayList<GraphPatternElement>();
			results.add(gpe);	// give it back unchanged
		}
		else if ((lhsGpe && !rhsGpe) || (!lhsGpe && rhsGpe)) {
			throw new TranslationException("junctionToList called on junction with a fix of a GrpahPatternElement and a non-GraphPatternElement; this is not handled.");
		}
		return results;
	}
	

	public static List<GraphPatternElement> disjunctionToList(Junction gpe) throws TranslationException {
		if (!gpe.getJunctionType().equals(JunctionType.Disj)) {
			throw new TranslationException("disjunctionToList called for Junction which is not disjunction");
		}
		List<GraphPatternElement> results = new ArrayList<GraphPatternElement>(1);
		Object lhs = gpe.getLhs();
		if (lhs instanceof ProxyNode) {
			if (((ProxyNode)lhs).getProxyFor() instanceof Junction) {
				List<GraphPatternElement> lgpe = junctionToList((Junction) ((ProxyNode)lhs).getProxyFor());
				if (lgpe.size() == 1) {
					((ProxyNode)lhs).setProxyFor(lgpe.get(0));
					results.add(gpe);
				}
				else {
					results.addAll(lgpe);
				}
			}
		}
		Object rhs = gpe.getRhs();
		if (rhs instanceof ProxyNode) {
			if (((ProxyNode)rhs).getProxyFor() instanceof Junction) {
				List<GraphPatternElement> rgpe = junctionToList((Junction) ((ProxyNode)rhs).getProxyFor());
				if (rgpe.size() == 1) {
					((ProxyNode)rhs).setProxyFor(rgpe.get(0));
					results.add(gpe);
				}
				else {
					results.addAll(rgpe);
				}
			}
		}
		
		return results;
	}

	/**
	 * This method returns true only if all variables in the element are bound in other rule elements
	 * 
	 * @param rule
	 * @param gpe
	 * @return
	 */
	private boolean allElementVariablesBound(Rule rule,
			GraphPatternElement gpe) {
		if (gpe instanceof TripleElement) {
			Node subject = ((TripleElement)gpe).getSubject();
			if ((subject instanceof VariableNode || subject instanceof NamedNode)
					&& !variableIsBound(rule, gpe, subject)) {
				return false;
			}
			Node object = ((TripleElement)gpe).getObject();
			if ((object instanceof VariableNode || object instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, object)) {
				return false;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			for (int i = 0; args != null && i < args.size(); i++) {
				Node arg = args.get(i);
				if ((arg instanceof VariableNode || arg instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, arg)) {
						return false;
					}
			}
		}
		return true;
	}

	/**
	 * This method returns true if the argument node is bound in some other element of the rule
	 * 
	 * @param rule
	 * @param gpe
	 * @param v
	 * @return
	 */
	public static boolean variableIsBound(Rule rule, GraphPatternElement gpe,
			Node v) {
		if (v instanceof NamedNode) {
			if (((NamedNode)v).getNodeType() != null && !(((NamedNode)v).getNodeType().equals(NodeType.VariableNode))) {
				return true;
			}
		}
		// Variable is bound if it appears in a triple or as the return argument of a built-in
		List<GraphPatternElement> givens = rule.getGivens();
		if (variableIsBoundInOtherElement(givens, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (variableIsBoundInOtherElement(ifs, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (variableIsBoundInOtherElement(thens, 0, gpe, false, true, v)) {
			return true;
		}
		return false;
	}

	/**
	 * This method checks the list of GraphPatternElements to see if the specified variable is bound in these elements
	 * 
	 * @param gpes - list of GraphPatternElements to check
	 * @param startingIndex - where to start in the list
	 * @param gp - the element in which this variable appears 
	 * @param boundIfEqual - use the current element for test?
	 * @param matchMustBeAfter - must the binding be after the current element
	 * @param v - the variable Node being checked
	 * @return - true if the variable is bound else false
	 */
	public static boolean variableIsBoundInOtherElement(List<GraphPatternElement> gpes, int startingIndex, GraphPatternElement gp, 
			boolean boundIfEqual, boolean matchMustBeAfter, Node v) {
		boolean reachedSame = false;
		for (int i = startingIndex; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			while (gpe != null) {
				boolean same = gp == null ? false : gp.equals(gpe);
				if (same) {
					reachedSame = true;
				}
				boolean okToTest = false;
				if (matchMustBeAfter && reachedSame && !same) {
					okToTest = true;
				}
				if (!matchMustBeAfter && (!same || (same && boundIfEqual))) {
					okToTest = true;
				}
				if (okToTest && variableIsBound(gpe, v)) {
					return true;
				}
				gpe = gpe.getNext();
			}
		}
		return false;
	}
	
	private static boolean variableIsBound(GraphPatternElement gpe, Node v) {
		if (gpe instanceof TripleElement) {
			if ((((TripleElement)gpe).getSubject() != null &&((TripleElement)gpe).getSubject().equals(v)) || 
					(((TripleElement)gpe).getObject() != null && ((TripleElement)gpe).getObject().equals(v))) {
				return true;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			// TODO built-ins can actually have more than the last argument as output, but we can only tell this
			//	if we have special knowledge of the builtin. Current SADL grammar doesn't allow this to occur.
			if (args != null && args.get(args.size() - 1) != null && args.get(args.size() - 1).equals(v)) {
				return true;
			}
		}
		else if (gpe instanceof Junction) {
			Object lhsobj = ((Junction)gpe).getLhs();
			if (lhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)lhsobj, v)) {
				return true;
			}
			else if (lhsobj instanceof VariableNode && ((VariableNode)lhsobj).equals(v)) {
				return true;
			}
			Object rhsobj = ((Junction)gpe).getRhs();
			if (rhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)rhsobj, v)) {
				return true;
			}
			else if (rhsobj instanceof VariableNode && ((VariableNode)rhsobj).equals(v)) {
				return true;
			}
		}
		return false;
	}

	private boolean doVariableSubstitution(List<GraphPatternElement> gpes,
			VariableNode v1, VariableNode v2) {
		boolean retval = false;
		for (int i = 0; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
		}
		return retval;
	}

	private boolean doVariableSubstitution(GraphPatternElement gpe, VariableNode v1, VariableNode v2) {
		boolean retval = false;
		do {
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
			gpe = gpe.getNext();
		} while (gpe != null);
		return retval;
	}

	private void setFirstOfPhrase(GraphPatternElement firstOfPhrase) {
		this.firstOfPhrase = firstOfPhrase;
	}

	protected GraphPatternElement getFirstOfPhrase() {
		return firstOfPhrase;
	}

	/* (non-Javadoc)
	 * @see com.ge.research.sadl.jena.I_IntermediateFormTranslator#setEncapsulatingTarget(java.lang.Object)
	 */
	@Override
	public void setEncapsulatingTarget(Object _encapsulatingTarget) {
		encapsulatingTarget = _encapsulatingTarget;
	}

	public boolean isCollectNamedNodes() {
		return collectNamedNodes;
	}

	public void setCollectNamedNodes(boolean collectNamedNodes) {
		this.collectNamedNodes = collectNamedNodes;
	}

	/**
	 * This method can be called only once for a given set of translations; calling it clears the list of ConceptNames
	 * @return
	 */
	public List<ConceptName> getNamedNodes() {
		if (namedNodes != null) {
			List<ConceptName> x = new ArrayList<ConceptName>(namedNodes);
			namedNodes.clear();
			return x;
		}
		return null;
	}

	private void setNamedNodes(List<ConceptName> namedNodes) {
		this.namedNodes = namedNodes;
	}

	private boolean isCruleVariableInTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) return false;
		 return cruleVariablesTypeOutput.contains(cruleVariable);
	}

	private void addCruleVariableToTypeOutput(VariableNode cruleVariable) {
		if (cruleVariablesTypeOutput == null) {
			cruleVariablesTypeOutput = new ArrayList<VariableNode>();
		}
		cruleVariablesTypeOutput.add(cruleVariable);
	}
	
	private void clearCruleVariableTypedOutput() {
		if (cruleVariablesTypeOutput != null) {
			cruleVariablesTypeOutput.clear();
		}
	}

	private int addNotEqualsBuiltinsForNewCruleVariable(List<GraphPatternElement> gpes, int currentIdx, VariableNode node) throws TranslationException {
		if (cruleVariablesTypeOutput == null) {
			throw new TranslationException("This should never happen! Please report.");
		}
		int crvSize = cruleVariablesTypeOutput.size();
		if (!cruleVariablesTypeOutput.get(crvSize - 1).equals(node)) {
			throw new TranslationException("This method should always be called immediately after creating a Crules variable.");
		}
		if (crvSize == 1) {
			return currentIdx;
		}
		for (int i = crvSize - 2; i >= 0; i--) {
			VariableNode otherVar = cruleVariablesTypeOutput.get(i);
			if (otherVar.getType().equals(node.getType())) {
				if (!notEqualAlreadyPresent(gpes, otherVar, node)) {
					BuiltinElement newBi = new BuiltinElement();
					newBi.setFuncName("!=");
					newBi.setFuncType(BuiltinType.NotEqual);
					newBi.addArgument(otherVar);
					newBi.addArgument(node);
					gpes.add(++currentIdx, newBi);
				}
			}
		}
		return currentIdx;
	}

	private boolean notEqualAlreadyPresent(List<GraphPatternElement> gpes, VariableNode var1,
			VariableNode var2) {
		for (int i = 0; i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getFuncType().equals(BuiltinType.NotEqual)) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				int found = 0;
				for (int j =0; args != null && j < args.size(); j++) {
					if (args.get(j).equals(var1)) {
						found++;
					}
					if (args.get(j).equals(var2)) {
						found++;
					}
				}
				if (found == 2) {
					return true;
				}
			}
		}
		return false;
	}

	@Override
	public JenaBasedSadlModelProcessor getModelProcessor() {
		return modelProcessor;
	}

	private void setModelProcessor(JenaBasedSadlModelProcessor modelProcessor) {
		this.modelProcessor = modelProcessor;
	}

	@Override
	public Object cook(Object obj) throws TranslationException, InvalidNameException, InvalidTypeException {
		if (obj instanceof Rule) {
			return cook((Rule)obj);
		}
		resetIFTranslator();
		setStartingVariableNumber(getVariableNumber() + getModelProcessor().getVariableNumber());
		return expandProxyNodes(obj, false, true);
	}
	
	@Override
	public Object cook(Object obj, boolean treatAsConclusion) throws TranslationException, InvalidNameException, InvalidTypeException {
		if (obj instanceof Rule) {
			return cook((Rule)obj);
		}
		resetIFTranslator();
		setStartingVariableNumber(getVariableNumber() + getModelProcessor().getVariableNumber());
		return expandProxyNodes(obj, treatAsConclusion, true);
	}
	
	public Rule cook(Rule rule) {
		try {
			rule = addImpliedAndExpandedProperties(rule);
//			rule = addMissingTriplePatterns(rule);
		} catch (Exception e) {
			addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + e.toString() + ")while 'cooking' IntermediateForm."));
			e.printStackTrace();
		} 
		return rule;
	}

	protected OntModel getTheJenaModel() {
		return theJenaModel;
	}

	protected void setTheJenaModel(OntModel theJenaModel) {
		this.theJenaModel = theJenaModel;
	}

	@Override
	public boolean graphPatternElementMustBeInConclusions(GraphPatternElement gpe) {
		if (gpe instanceof BuiltinElement && ((BuiltinElement)gpe).getFuncName().equals("assign")) {
			return true;
		}
		return false;
	}

	/** 
	 * Method to return the type of element returned by a list element extraction built-in
	 * @param bi
	 * @return
	 */
	public NamedNode listElementIdentifierListType(BuiltinElement bi) {
		if (bi.getFuncName().equals("lastElement") ||
				bi.getFuncName().equals("firstElement") ||
				bi.getFuncName().equals("elementBefore") ||
				bi.getFuncName().equals("elementAfter") ||
				bi.getFuncName().equals("elementInList") ||
				bi.getFuncName().equals("sublist")) {
			Node listArg = bi.getArguments().get(0);
			if (listArg instanceof NamedNode) {
				return (NamedNode) listArg;
			}
			else if (listArg instanceof ProxyNode) {
				Object pf = ((ProxyNode)listArg).getProxyFor();
				if (pf instanceof TripleElement) {
					Node pred = ((TripleElement) pf).getPredicate();
					if (pred instanceof NamedNode) {
						Property p = theJenaModel.getProperty(((NamedNode)pred).toFullyQualifiedString());
						try {
							ConceptName pcn = getModelProcessor().namedNodeToConceptName((NamedNode)pred);
							TypeCheckInfo tci = getModelValidator().getTypeInfoFromRange(pcn, p, null);
							Node lsttype = tci.getTypeCheckType();
							if (lsttype instanceof NamedNode) {
								return (NamedNode) lsttype;
							}
						} catch (DontTypeCheckException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (InvalidTypeException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (TranslationException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						} catch (InvalidNameException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				}
			}
			return null;
		}
		return null;
	}

	@Override
	public void reset() {
		// nothing needed in this class
	}


}	
