package com.naturalsemantics.sadl.sitl.processing;

import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.jena.datatypes.xsd.XSDDatatype;
import org.apache.jena.ontology.Individual;
import org.apache.jena.ontology.OntClass;
import org.apache.jena.ontology.OntResource;
import org.apache.jena.rdf.model.Literal;
import org.apache.jena.rdf.model.Property;
import org.eclipse.core.runtime.OperationCanceledException;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.CheckType;

import com.ge.research.sadl.errorgenerator.generator.SadlErrorMessages;
import com.ge.research.sadl.jena.DontTypeCheckException;
import com.ge.research.sadl.jena.JenaBasedSadlModelProcessor;
import com.ge.research.sadl.jena.JenaProcessorException;
import com.ge.research.sadl.jena.PropertyWithoutRangeException;
import com.ge.research.sadl.jena.JenaBasedSadlModelProcessor.DataDescriptor;
import com.ge.research.sadl.model.CircularDefinitionException;
import com.ge.research.sadl.model.DeclarationExtensions;
import com.ge.research.sadl.model.OntConceptType;
import com.ge.research.sadl.model.gp.GraphPatternElement;
import com.ge.research.sadl.model.gp.NamedNode;
import com.ge.research.sadl.model.gp.Node;
import com.ge.research.sadl.processing.IModelProcessor;
import com.ge.research.sadl.processing.OntModelProvider;
import com.ge.research.sadl.processing.SadlConstants;
import com.ge.research.sadl.processing.ISadlOntologyHelper.Context;
import com.ge.research.sadl.reasoner.InvalidNameException;
import com.ge.research.sadl.reasoner.InvalidTypeException;
import com.ge.research.sadl.reasoner.TranslationException;
import com.ge.research.sadl.processing.ValidationAcceptor;
import com.ge.research.sadl.sADL.Expression;
import com.ge.research.sadl.sADL.SadlInstance;
import com.ge.research.sadl.sADL.SadlModel;
import com.ge.research.sadl.sADL.SadlModelElement;
import com.ge.research.sadl.sADL.SadlParameterDeclaration;
import com.ge.research.sadl.sADL.SadlPrimitiveDataType;
import com.ge.research.sadl.sADL.SadlPropertyInitializer;
import com.ge.research.sadl.sADL.SadlResource;
import com.ge.research.sadl.sADL.SadlSimpleTypeReference;
import com.ge.research.sadl.sADL.SadlTableDeclaration;
import com.ge.research.sadl.sADL.SadlTypeReference;
import com.ge.research.sadl.sADL.SadlValueList;
import com.google.common.base.Stopwatch;
import com.naturalsemantics.sadl.sitl.sITL.EndGroup;
import com.naturalsemantics.sadl.sitl.sITL.Incremental;
import com.naturalsemantics.sadl.sitl.sITL.Infer;
import com.naturalsemantics.sadl.sitl.sITL.Log;
import com.naturalsemantics.sadl.sitl.sITL.StartGroup;
import com.naturalsemantics.sadl.sitl.sITL.Transform;
import com.naturalsemantics.sadl.sitl.sITL.Validate;

public class JenaBasedSitlModelProcessor extends JenaBasedSadlModelProcessor implements IModelProcessor {

	public static final String SITL_TMPL_SERIALIZATION = "sitl-tmpl-serialization";
	
	private HashMap<String, String> variableTypeDeclarations = new HashMap<String, String>();

	@Override
	public void onValidate(Resource resource, ValidationAcceptor issueAcceptor, CheckMode mode,
			ProcessorContext context) {
		Stopwatch stopwatch = Stopwatch.createStarted();
		logger.debug("onValidate called for Resource '" + resource.getURI() + "'");
		if (mode.shouldCheck(CheckType.EXPENSIVE)) {
			// do expensive validation, i.e. those that should only be done when 'validate'
			// action was invoked.
		}
		if (resource.getContents().size() < 1) {
			return;
		}
		setIssueAcceptor(issueAcceptor);
		setProcessorContext(context);
		setCancelIndicator(cancelIndicator);
		setCurrentResource(resource);
		SadlModel model = (SadlModel) resource.getContents().get(0);
		String modelActualUrl = resource.getURI().lastSegment();
		String modelName = model.getBaseUri();
		if (!commonOnValidateStart(resource, context, model, modelActualUrl, modelName)) {
			return;
		}

		StringBuilder sb = new StringBuilder("// This tabular data import template file was generated by the by\n");
		sb.append("// the SADL Import Template Language (SITL) editor in Eclipse.\n\n");
		sb.append("uri \"");
		sb.append(getModelName());
		if (getModelAlias() != null) {
			sb.append("\" alias ");
			sb.append(getModelAlias());
		}
		sb.append(".\n\n");
		
		List<String> imports = getImportsInOrderOfAppearance();
		if (imports !=  null) {
			for (String imprt : imports) {
				sb.append("import \"");
				sb.append(imprt);
				sb.append("\"\n");
			}
		}

		// process rest of parse tree
		List<SadlModelElement> elements = model.getElements();
		if (elements != null) {
			Iterator<SadlModelElement> elitr = elements.iterator();
			while (elitr.hasNext()) {
				// check for cancelation from time to time
				if (context.getCancelIndicator().isCanceled()) {
					throw new OperationCanceledException();
				}
				SadlModelElement element = elitr.next();
				Object meval = processModelElement(element);
				if (meval != null && meval.toString().length() > 0) {
					sb.append(meval.toString());
					sb.append("\n");
				}
			}
		}
		
		// persist the generated template file for a possible generation on save
		OntModelProvider.addPrivateKeyValuePair(model.eResource(), SITL_TMPL_SERIALIZATION, sb.toString());

	}
	
	@Override
	protected Object processModelElement(SadlModelElement element) {
		Object retval = null;
		try {
			if (element instanceof Validate) {
				retval = processSitlValidate((Validate)element);
			}
			else if (element instanceof Transform) {
				retval = processSitlTransform((Transform)element);
			}
			else if (element instanceof Incremental) {
				retval = processSitlIncremental((Incremental)element);
			}
			else if (element instanceof Infer) {
				retval = processSitlInfer((Infer)element);
			}
			else if (element instanceof Log) {
				retval = processSitlLog((Log)element);
			}
			else if (element instanceof StartGroup) {
				retval = processSitlStartGroup((StartGroup)element);
			}
			else if (element instanceof EndGroup) {
				retval = processSitlEndGroup((EndGroup)element);
			}
			else {
				retval = super.processModelElement(element);
			}
		}catch (Throwable t) {
			if (logger.isDebugEnabled() || t instanceof NullPointerException) {
				t.printStackTrace();
			}
			addError(t.getMessage(), element);
		}
		return retval;
	}

	private Object processSitlEndGroup(EndGroup element) {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		return "}\n";
	}

	private Object processSitlStartGroup(StartGroup element) {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		return "{\n";
	}

	private Object processSitlLog(Log element) {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		return "log \"" + element.getFileName() + "\".\n";
	}

	private Object processSitlInfer(Infer element) {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		StringBuilder sb = new StringBuilder("infer ");
		if (element.getChunkSize() > 0) {
			sb.append("chunk ");
			sb.append(element.getChunkSize());
			if (element.getThreads() > 0) {
				sb.append(" threads ");
				sb.append(element.getThreads());
			}
		}
		sb.append(".\"");
		return sb.toString();
	}

	private Object processSitlIncremental(Incremental element) {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		return "incremental.\n";
	}

	private Object processSitlTransform(Transform element) throws InvalidNameException, InvalidTypeException, TranslationException {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		Expression expr = element.getExpr();
		Object exprObj = processExpression(expr);
		StringBuilder sb = new StringBuilder("transform ");
		sb.append(exprObj.toString());
		sb.append(".\n");
		return sb.toString();
	}

	private Object processSitlValidate(Validate element) throws InvalidNameException, InvalidTypeException, TranslationException {
//		System.err.println("To do: process " + element.getClass().getCanonicalName());
		Expression expr = element.getExpr();
		String act1 = element.getAct1();
		String act2 = element.getAct2();
		String base = element.getBase(); 
		boolean abort = base == null ? true : false;
		Object exprObj = processExpression(expr);
		StringBuilder sb = new StringBuilder("validate ");
		sb.append(exprObj.toString());
		if (act1 != null) {
			sb.append(" skip");
		}
		if (act2 != null) {
			sb.append(" group");
		}
		if (abort) {
			sb.append(" abort");
		}
		sb.append(".\n");
		return sb.toString();
	}
	
	@Override
	protected Object processSadlInstance(SadlInstance element) throws JenaProcessorException, CircularDefinitionException {

		// this has multiple forms:
		// 1) <name> is a <type> : translates into a validation of the type of the value from the table
		// 2) a <type> <name> ....
		// 3) <name> is a <property> of <instance>
		// 4) <property> of <instance> is <value>
		StringBuilder sb = new StringBuilder();
		SadlTypeReference type = element.getType();
		boolean isList = typeRefIsList(type);
		SadlResource sr = sadlResourceFromSadlInstance(element);
		OntResource subjOR = null;
		String subjNS = null;
		String subjStr = null;
		boolean subjIsVar = false;
		if (sr != null) {
			subjOR = getTheJenaModel().getOntResource(getDeclarationExtensions().getConceptUri(sr));
			subjNS = getDeclarationExtensions().getConceptNamespace(sr);
		}
		else if (type instanceof SadlPrimitiveDataType){
			addError("Don't think this should ever happen", element);
		}
		else if (type instanceof SadlSimpleTypeReference) {
			SadlResource typeSR = ((SadlSimpleTypeReference)type).getType();
			if (typeSR.equals(sr)) {
				// being declared an instance of itself
				addError(getDeclarationExtensions().getConcreteName(sr) + " can't be an instance of itself.", sr);
				return null;
			}
			sr = typeSR;
			subjOR = sadlTypeReferenceToOntResource(type);
			subjNS = subjOR != null && subjOR.isURIResource() ? subjOR.getNameSpace() : null;
		}
		if (subjNS != null && subjNS.equals(getModelNamespace())) {
			subjIsVar = true;
			subjStr = getDeclarationExtensions().getConcreteName(sr, true);
//			addError("Only a variable is allowed in a template. Actual instances must be defined in an imported semantic model.", sr);
		}
		else {
			subjStr = getDeclarationExtensions().getConceptPrefix(sr) + ":" + getDeclarationExtensions().getConcreteName(sr, true);
		}

		if (subjOR != null && sr != null && sr.getAnnotations() != null) {
			addAnnotationsToResource(subjOR, sr.getAnnotations());
		}

		Iterator<SadlPropertyInitializer> itr = element.getPropertyInitializers().iterator();
		while (itr.hasNext()) {
			SadlPropertyInitializer propinit = itr.next();
			SadlResource prop = propinit.getProperty();
			OntConceptType propType = getDeclarationExtensions().getOntConceptType(prop);
			String propUri = getDeclarationExtensions().getConceptUri(prop);
			Property propOR = propUri != null ? getTheJenaModel().getProperty(propUri) : null;
			String propNS = getDeclarationExtensions().getConceptNamespace(prop);
			String propStr = null;
			boolean propIsVar = false;
			if (propNS != null && propNS.equals(getModelNamespace())) {
				propIsVar = true;
				propStr = getDeclarationExtensions().getConcreteName(prop, true);
			}
			else if (propOR != null) {
				propStr = getDeclarationExtensions().getConceptPrefix(prop) + ":" + getDeclarationExtensions().getConcreteName(prop);
			}
			else if (propType.equals(OntConceptType.VARIABLE)) {
				propIsVar = true;
				propStr = getDeclarationExtensions().getConcreteName(prop);
			}
			OntResource objOR = null;
			String objNS = null;
			String objStr = null;
			boolean objIsVar = false;
			EObject val = propinit.getValue();
			if (val == null) {
				val = propinit.getType();
			}
			if (val != null) {
				if (val instanceof SadlResource) {
					if (propinit.getFirstConnective() != null && propinit.getFirstConnective().equals("is")) {
						String valinstUri = getDeclarationExtensions().getConceptUri((SadlResource) val);
						Individual valinst = getTheJenaModel().getIndividual(valinstUri);
						objStr = getDeclarationExtensions().getConceptPrefix(sr) + ":" + getDeclarationExtensions().getConcreteName((SadlResource) val);

					}
					else {
						objOR = getTheJenaModel().getOntResource(getDeclarationExtensions().getConceptUri((SadlResource) val));
						if (objOR != null) {
							objNS = objOR.isURIResource() ? objOR.getNameSpace() : null;
						}
						else {
							objNS = getDeclarationExtensions().getConceptNamespace((SadlResource) val);  // ((SadlResource) val);
							objStr = getDeclarationExtensions().getConceptPrefix(sr) + ":" + getDeclarationExtensions().getConcreteName((SadlResource) val);
						}
						if (objNS != null && objNS.equals(getModelNamespace())) {
							objIsVar = true;
							objStr = getDeclarationExtensions().getConcreteName((SadlResource) val, true);

						}
					}
				}
				else {

				}
			} else {
				addError("no value found", propinit);
			}
			if (subjStr != null && propStr != null && objStr != null) {
				if (subjIsVar) {
					sb.append("<");
					sb.append(subjStr);
					sb.append("> ");
				}
				else {
					sb.append(subjStr);
					sb.append(" ");
				}
				if (propIsVar) {
					sb.append("<");
					sb.append(propStr);
					sb.append("> ");
				}
				else {
					sb.append(propStr);
					sb.append(" ");
				}
				if (objIsVar) {
					sb.append("<");
					sb.append(objStr);
					sb.append(">");
				}
				else {
					sb.append(objStr);
				}
				sb.append(".\n");
			}
		}
		SadlValueList listInitializer = element.getListInitializer();
		if (listInitializer != null) {
			if (listInitializer.getExplicitValues().isEmpty()) {
				addWarning(SadlErrorMessages.EMPTY_LIST_DEFINITION.get(), element);
			} else {

			}
		}
		return sb.toString(); 
	}

	@Override
	public void onGenerate(Resource resource, IFileSystemAccess2 fsa, ProcessorContext context) {
		System.err.println("To do: onGenerate (called for resource " + resource.getURI().toString() + ")");
		URI lastSeg = fsa.getURI(resource.getURI().lastSegment());
		System.err.println("onGenerate fsa URI: " + lastSeg.toString());
	}

	@Override
	public void validate(Context context, SadlResource candidate) {
		System.err.println("To do: validate called for SadlResource " + getDeclarationExtensions().getConceptUri(candidate));
	}

//	@Override
//	public boolean isTypeCheckingErrorDetected() {
//		// TODO Auto-generated method stub
//		return false;
//	}

//	@Override
//	public void clearTypeCheckingErrorDetected() {
//		// TODO Auto-generated method stub
//
//	}

	@Override
	public DeclarationExtensions getDeclarationExtensions() {
		return super.getDeclarationExtensions();
	}

//	@Override
//	public String getDatatypePropertyContentAssistSuggestion(SadlResource sr) {
//		// TODO Auto-generated method stub
//		return null;
//	}

//	@Override
//	public void processExternalModels(String mappingFileFolder, List<String> fileNames) throws IOException {
//		// TODO Auto-generated method stub
//
//	}

	@Override
	public boolean isSupported(String fileExtension) {
		return "sitl".equals(fileExtension);
	}

	private String getVariableTypeDeclaration(String varName) {
		return variableTypeDeclarations.get(varName);
	}

	private void setVariableTypeDeclaration(String varName, String variableTypeDeclaration) {
		this.variableTypeDeclarations.put(varName, variableTypeDeclaration);
	}

}
