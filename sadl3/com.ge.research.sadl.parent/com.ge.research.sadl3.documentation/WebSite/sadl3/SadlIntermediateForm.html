<h1>The SADL Intermediate Form</h1>
<h6>Last revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->02/20/2018<!--webbot bot="Timestamp" endspan i-checksum="12513" --> 
by <a href="mailto:crapo@research.ge.com?subject=Requirements Language">A. W. 
Crapo</a>.</h6>
<h2>Table of Contents</h2>
<ul>
  <li><a href="#Introduction">Introduction</a></li>
  <li><a href="#ClassHierarchy">The Class Hierarchy</a></li>
  <li><a href="#IF1">Introducing the Intermediate Form</a></li>
  <li><a href="#IF2">Functions in the Intermediate Form</a></li>
  <li><a href="#IF3">Other Node Sub-classes in the Intermediate Form</a></li>
  <li><a href="#BI1">BuiltinElements Supporting SADL Grammar Constructs</a></li>
  <li><a href="#BI2">Additional BuiltinElements</a></li>
  <li><a href="#SC1">SADL Commands (SadlCommand)</a></li>
  <li><a href="#SR1">SADL Rules</a></li>
  <li><a href="#Equations">SADL Equations</a></li>
</ul>
<h2><a name="Introduction">Introduction</a></h2>
<p>The SADL Intermediate Form is an in-memory representation used to capture the 
semantics of graph patterns and functions used in SADL rules, queries, and 
tests. This in-memory representation serves several purposes.</p>
<ol>
  <li>It serves as the input to target reasoner-specific translators that then 
  convert rules and queries into the format required by the reasoner. For 
  example, a Jena-based reasoner requires that rules be expressed in Jena Rule 
  language and that queries be expressed in SPARQL. Hence a compatible 
  Jena-based translator will translate the Intermediate Form into Jena Rules and SPARQL queries.</li>
  <li>It serves as the mechanism for capturing and preserving tests and other 
  SADL &quot;commands&quot; during model processing so that they can be processed during 
  inferencing of a SADL model.</li>
  <li>Expressions in the Intermediate Form can be serialized for examination by 
  users (the Expr command).</li>
</ol>
<h2><a name="ClassHierarchy">The Class Hierarchy</a></h2>
<p>The in-memory Intermediate Form consists of three sets of classes related in 
sub-class/super-class hierarchies plus one additional top-level class. The names 
of the first two class hierarchies reflect support for a 
graph model. The &quot;Node&quot; hierarchy represents those concepts that can be nodes 
(and directed edges) in the graph model. The &quot;GraphPatternElement&quot; class 
represents constructs that are built from nodes, e.g., a graph &quot;TripleElement&quot; 
contains a subject (head) node, a directed edge node, and an object or value 
(tail) node. The &quot;SadlCommand&quot; hierarchy captures information about a variety of 
top-level SADL statements that are used to help users test, validate, query, 
use, and maintain their models. SadlCommands are primarily used in the 
development environment rather than becoming part of the delivered knowledge 
base, named queries being an exception. The &quot;Rule&quot; class captures if-then logic 
used by target reasoners and is an important part of most knowledge bases.</p>
<p>These classes are in the <i>com.ge.reasoner.sadl.reasoner-api</i> project, in 
the <i>com.ge.research.sadl.model.gp</i> package.</p>
<ul>
  <li>Node<ul>
    <li>ConstantNode</li>
    <li>KnownNode</li>
    <li>Literal</li>
    <li>NamedNode<ul>
      <li>RDFTypeNode</li>
      <li>VariableNode</li>
    </ul>
    </li>
    <li>ProxyNode</li>
    <li>ValueTableNode</li>
  </ul>
  </li>
  <li>GraphPatternElement<ul>
    <li>BuiltinElement</li>
    <li>Junction</li>
    <li>TripleElement</li>
  </ul>
  </li>
  <li>SadlCommand<ul>
  <li>EndWrite</li>
  <li>Explain</li>
  <li>Print</li>
  <li>Query</li>
  <li>Read</li>
  <li>StartWrite</li>
  <li>Test</li>
</ul>
  </li>
  <li>Rule</li>
  <li>Equation</li>
</ul>
<p>Instances of these classes have serializations to allow one to &quot;see&quot; 
their contents, but the serializations are not meant for persistence. That is, 
there is no parser to recreate the in-memory structure from the serialization. 
In fact, most of them have multiple serializations generated by methods 
indicative of the serialization.</p>
<ul>
  <li>toString() -- generates the most terse serialization containing the names 
  and relationships; names are in qualified name form</li>
  <li>toFullyQualifiedString() -- generates content similar to toString() except 
  that all names are expanded to complete URIs</li>
  <li>toDescriptiveString() -- the most verbose serialization with additional 
  comments in-line, e.g., the type of a variable is displayed after the 
  variable's name</li>
</ul>
<h2><a name="IF1">Introducing the Intermediate Form</a></h2>
<p>Developers will want to look at the actual Java code for the classes of the 
Intermediate Form, which can be seen in the source code repository for SADL3 at
<a href="https://github.com/crapo/sadlos2/tree/master/sadl3/com.ge.research.sadl.parent/com.ge.research.sadl.reasoner-api/src/main/java/com/ge/research/sadl/model/gp">
this location</a>. This document will use the serializations of these classes 
for discussion. These serializations have a predicate logic flavor. For example, 
the serialization of a TripleElement uses the predicate &quot;rdf&quot; and has three 
arguments, the triple's subject, property, and object or value: </p>
<blockquote>
  <p>rdf(&lt;subjectNode&gt;, &lt;propertyNode&gt;, &lt;objectNode&gt;)</p>
</blockquote>
<p>The Intermediate Form is generated from the SADL parse tree and so, like the 
grammar itself, can have nested expressions. For example, </p>
<blockquote>
  <font SIZE="2" COLOR="#800080">
  <p>the</font><font SIZE="2"> </font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2">
  </font><font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#800080">a</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#008000"><b>friend</b></font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#0000ff">Plato</font> </p>
</blockquote>
<p>would create an Intermediate Form with a nested graph pattern, which may be 
visualized as (prefixes omitted from names): </p>
<blockquote>
  <p ALIGN="LEFT">rdf((rdf(Plato, friend, null)), age, null)</p>
</blockquote>
<p>A &quot;null&quot; argument indicates that there is nothing in the parse tree for that 
graph node. Note also that the inner or nested triple pattern is surrounded by 
an extra set of parentheses. This is because the arguments of the &quot;rdf&quot; 
predicate are nodes, but the subject in this case is not a node but another 
triple. The inner TripleElement is therefore wrapped in a ProxyNode, and the 
serialization of that ProxyNode produces the extra parentheses.</p>
<p>The nested triples shown above constitute the &quot;raw&quot; Intermediate Form. If we 
flatten any nesting that has occurred and replace any &quot;null&quot; nodes with variable 
nodes we arrive at the &quot;cooked&quot; Intermediate Form. For this example, cooking 
produces this serialization:</p>
<blockquote>
  <p ALIGN="LEFT">and(rdf(Plato, friend, v2), rdf(v2, age, v3))</p>
</blockquote>
<p>The &quot;and&quot; predicate is the serialization of the conjunctive Junction 
GraphPatternElement subclass. This cooked form reflects the order that is 
required for binding in rules or queries. Given the subject &quot;Plato&quot; and property 
&quot;friend&quot;, the object variable &quot;v2&quot; will be bound to the possible value(s) for 
the triple pattern. Then for each binding of &quot;v2&quot;, the second triple pattern 
with property &quot;age&quot; will cause the object variable &quot;v3&quot; to be bound to the 
value(s) matching that triple pattern.</p>
<h2><a name="IF2">Functions in the Intermediate Form </a></h2>
<p>Consider as another example SADL statement:</p>
<blockquote>
  <font SIZE="2" COLOR="#0000ff">
  <p>Socrates</font><font SIZE="2"> </font><font SIZE="2" COLOR="#800080">has</font><font SIZE="2">
  </font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2"> (</font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2">
  </font><font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#0000ff">Plato</font><font SIZE="2"> + 33)</p>
  </font>
</blockquote>
<p>&nbsp;This raw Intermediate Form of this statement is also nested (prefixes 
again removed):</p>
<blockquote>
  <p ALIGN="LEFT">rdf(Socrates, age, (+((rdf(Plato, age, null)),33)))</p>
</blockquote>
<p>In this expression we see that the object of the first triple pattern is a 
BuiltinElement with name &quot;+&quot; and having 2 arguments, the first a nested triple 
and the second the Literal &quot;33&quot;. Note that the nested triple is again surrounded 
with an extra set of parentheses indicating the presence of a ProxyNode wrapping 
that triple so that it can be an argument for the BuiltinElement whose arguments 
must be Nodes. Note that the &quot;+&quot; BuiltinElement is also wrapped in an extra set 
of parentheses indicating that the BuiltinElement is also wrapped in a ProxyNode 
to allow it to be the object of the first triple.</p>
<p>Cooking the raw Intermediate Form yields the following expression:</p>
<blockquote>
  <p ALIGN="LEFT">and(rdf(Socrates, age, v1), and(rdf(Plato, age, v0), 
  +(v0,33,v1)))</p>
</blockquote>
<p>This statements suggests that an assignment is being made and the order of 
the elements of the expression are not in the order in which evaluation would 
need to occur. Rather the variable &quot;v0&quot; would be bound, then the variable &quot;v1&quot; 
would be bound, and then the assignment of values to the triple &quot;rdf(Socrates, 
age, v1)&quot; using the binding(s) of &quot;v1&quot; would be made. Correct ordering of the 
expression is the job of the translator consuming the Intermediate Form since 
the order is context-dependent. Note that the &quot;+&quot; BuiltinElement has 3 arguments 
in the cooked form. The third argument is the variable which is bound to the 
results of performing the addition on the first two arguments.</p>
<h2><a name="IF3">Other Node Sub-classes in the Intermediate Form</a></h2>
<p>An instance of the Junction class can be conjunctive (&quot;and&quot;) or disjunctive 
(&quot;or&quot;). The KnownNode is a special node corresponding to the &quot;known&quot; keyword in 
the SADL grammar. The exact meaning of &quot;known&quot; is determined by the translator, 
but the general sense is that of &quot;any value&quot; when by itself and &quot;no value 
exists&quot; when negated (&quot;not known&quot;). The ConstantNode captures constants such as 
the mathematical values &quot;PI&quot; and &quot;e&quot;. It is also used for the keyword &quot;None&quot;, 
whose meaning is also determined by the translator although the general sense is 
that of not being and thereby similar to &quot;not known&quot;.</p>
<p>The RDFTypeNode captures the ontology property &quot;rdf:type&quot;, which is the 
relationship between an instance and a class to which that instance belongs. In 
SADL this relationship is represented by &quot;is a&quot;. Note that this is distinctly 
different from the subclass-superclass relationship, &quot;rdfs:subClassOf&quot; and &quot;is a 
type of&quot; in SADL.</p>
<p>We encountered variable nodes in the examples above. A variable node has a 
name, either supplied by the user or created to be unique by the model 
processor. In the examples above, all variable names were created by the model 
processor as variables were implicit in the SADL statements and were only needed 
to flatten the Intermediate Form during cooking, also known as ProxyNode 
expansion.</p>
<h2><a name="BI1">BuiltinElements Supporting SADL Grammar Constructs</a></h2>
<p>There are a number of SADL grammar constructs that generate BuiltinElements 
when parsed and processed by the model processor. These include the following. 
After each is the form of the BuiltinElement in raw form. Note that the cooked 
form of functions (built-ins that return a non-boolean value) will include an 
additional variable argument to which the returned value will be assigned.</p>
<ul>
  <li>Junctive Keywords<ul>
    <li>and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>Equality/Inequality/Assignment Keywords<ul>
    <li>is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is 
    (&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>is not&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not(is(&lt;arg1&gt;, &lt;arg2&gt;))</li>
    <li>==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
    <li>!=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not(is(&lt;arg1&gt;, 
    &lt;arg2&gt;))</li>
  </ul>
  </li>
  <li>Comparison Keywords<ul>
    <li>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    &lt;(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>&lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;=(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
    <li>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    &gt;(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>&gt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;=(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>Math Operation Keywords<ul>
    <li>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    +(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    -(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    *(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    /(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    %(&lt;arg1&gt;, &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>List Operation Keywords<ul>
    <li>element before &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementBefore(&lt;list&gt;,&lt;element&gt;)</li>
    <li>element after &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementAfter(&lt;list&gt;,&lt;element&gt;)</li>
    <li>element &lt;n&gt; of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementInList(&lt;list&gt;,&lt;n&gt;)</li>
    <li>first element of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    firstElement(&lt;list&gt;)</li>
    <li>last element of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    lastElement(&lt;list&gt;)</li>
    <li>length of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    length(&lt;list&gt;)</li>
    <li>count of &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    count(&lt;list&gt;, &lt;element&gt;)</li>
    <li>index of &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    index(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;list&gt; contains &lt;element&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    contains(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;list&gt; does not contain &lt;element&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    not(contains(&lt;list&gt;, &lt;element&gt;))</li>
    <li>&lt;element&gt; is unique in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    unique(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;element&gt; is not unique in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    not(unique(&lt;list&gt;, &lt;element))</li>
    <li>the sublist of &lt;list&gt; matching &lt;conditions&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    sublist(&lt;list&gt;,&lt;condition&gt;)</li>
  </ul>
  </li>
  <li>Quantification Keywords<ul>
  <li>there exists a &lt;type&gt; with &lt;prop&gt; &lt;val&gt; ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
  and(thereExists(&lt;typedVariable of &lt;type&gt;&gt;),rdf(&lt;typedVarible&gt;, &lt;prop&gt;, &lt;val&gt;))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  </li>
</ul>
  </li>
</ul>
<h2><a name="BI2">Additional BuiltinElements</a></h2>
<p>Additional BuiltinElements can come from two sources. The first is directly 
from the modeler via Equation and External statements. These statements add to 
the set of functions that can be used in SADL expressions and properly processed 
into BuiltinElements in the Intermediate Form. The second source is from the 
selected reasoner/translator pair. The definitions of additional built-in 
functions known to the reasoner/translator, e.g., the trig functions like &quot;sin&quot;, 
&quot;cos&quot;, etc., will be supplied to the model processor and will be persisted in 
SADL External statements in the SadlBuiltinFunctions.sadl file in the project's 
ImplicitModel folder. These may or may not come with a complete signature 
indicating the number and type of arguments and the type returned by the 
function, depending upon the reasoner/translator selected.</p>
<h2><a name="SC1">SADL Commands (SadlCommand class)</a></h2>
<p>The SadlCommand class is the abstract root class for capturing the results of 
parsing a number of top-level SADL grammar constructs that are useful in 
testing, debugging, using, and maintaining a SADL ontology. SadlCommand 
subclasses include:</p>
<ul>
  <li>Query -- the SADL &quot;Ask&quot; statement contains a graph pattern to be used to 
  retrieve matching nodes and/or edges from the knowledge graph. A Query can be 
  given a name, allowing it to be reused by reference elsewhere in the knowledge 
  base.</li>
  <li>Test -- the SADL &quot;Test&quot; statement contains an expression which can be 
  evaluated to be true (test passes) or false (test fails). Normally the test 
  contains some type of graph pattern to be matched in the knowledge graph and 
  the expected results.</li>
  <li>Print -- the SADL &quot;Print&quot; statement can be used to output information 
  after reasoning over the model. The output can be a specified string, the 
  serialization of the &quot;deductions&quot; model (those triples which were inferred), 
  or the serialization of the entire knowledge base.</li>
  <li>Read -- the SADL &quot;Read&quot; statement can be used to ingest additional triples 
  into the knowledge base prior to inferencing. The inputs can come from an OWL 
  file or they can come from a tabular data file converted to graph triples via 
  a template file.</li>
  <li>StartWrite -- the SADL &quot;Write&quot; statement causes the output of the 
  following SadlCommands (up to the EndWrite) to be written to the specified 
  file.</li>
  <li>EndWrite -- this terminates the SADL &quot;Write&quot; command (with a closing '}')</li>
  <li>Explain -- the SADL &quot;Explain&quot; statement may be used as a debugging aid. It 
  has two forms. 1) Followed by an expression, and depending upon the 
  capabilities of the selected reasoner, the expression will be evaluated to 
  determine if it is true in the knowledge base and if so, why. In other words, 
  it provides the derivation of the expression. 2) Followed by &quot;Rule&quot; and the 
  name of a Rule, the premises of the Rule will be tested sequentially against 
  the knowledge base and all content matching that premise and all preceding 
  premises will be displayed. This is useful in determining why a Rule did not 
  &quot;fire&quot;. Note that the selected reasoner will control the amount of information 
  provided by this command.</li>
</ul>
<h2><a name="SR1">SADL Rules</a></h2>
<p>The SADL &quot;Rule&quot; statement captures a set of conditions which must be 
satisfied for the rule to &quot;fire&quot; and a set of TripleElements to be inserted into 
the knowledge base and/or a set of BuiltinElements to be executed if the rule 
does &quot;fire&quot;. SADL Rules have unique names and those names can be referenced else 
where in models, e.g., in a Query. Rules are an important mechanism for 
capturing knowledge and are translated into a form that can be processed by the 
target reasoner. They form part of a deployed knowledge base.</p>
<h2><a name="Equations">SADL Equations</a></h2>
<p>The SADL &quot;Equation&quot; and the SADL &quot;External&quot; statements both result in an 
Equation in the Intermediate Form. In either case, the name must be unique 
within the namespace. The signature of the Equation is captured as VariableNode 
instances containing both the name and the type of the arguments. In the case of 
a SADL &quot;Equation&quot; statement, the body is also capture as GraphPatternElements.</p>
