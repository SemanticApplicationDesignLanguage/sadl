<html>

<head>
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Foundational Concepts</title>

</head>

<body>

<h1>Foundational Concepts</h1>

<h5>Last revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->07/03/2017<!--webbot bot="Timestamp" endspan i-checksum="12553" -->. 
Send comments to <a href="mailto:crapo@research.ge.com?subject=SADL 3">mailto:crapo@research.ge.com</a>.</h5>
<h3>Table of Contents</h3>
<ul>
  <li><a href="#Identity">Identity, Namespace, and Names (or Lack of Names)</a></li>
  <li><a href="#Sets">Sets and Members (AKA Classes and Instances)</a><ul>
    <li><a href="#Hierarchies">Class Hierarchies</a></li>
    <li><a href="#ClassVsInstance">When Is Something a Class, When Is It an Instance?</a></li>
  </ul>
  </li>
  <li><a href="#Properties">Characteristics, Relationships, and Properties</a></li>
  <li><a href="#Graphs">Graph Models, Graph Patterns, and Graph Query Languages</a></li>
</ul>
<h2><a name="Identity">Identity, Namespace, and Names (or Lack of Names)</a></h2>
<p><i>Identity</i> in necessary for communication, formal or informal. In other words, 
the concepts that are defined in our ontology are only useful and usable if I 
can distinguish one from another. This ability to distinguish one concept from 
all others we will refer to as establishing identity.</p>
<p>Our modeling approach is based on “standards” used in the World Wide Web as 
defined by the World Wide Web Consortium (W3C). Identity on the Web is 
established by a <i>Universal Resource Identifier</i> (URI). If two things have the 
same URI they are not two things—they are the same thing. Period. Note that the 
inverse is not true. Just because there are two URIs, it is not necessarily the 
case that there are two different things. In fact, it is not unusual for 
different modelers to create their own unique identifier for the same concept. 
There is, as we shall see, a way of stating that two URIs identify the same 
concept.</p>
<p>Fortunately, Web standards provide more than just a syntax for identifiers (URIs). 
They also provide the concept of an <i>XML namespace</i>. A namespace is a set of names 
and is itself identified by a URI. All the names in a namespace share the 
namespace’s URI and are distinguished from one another by a <i>local name</i> or 
fragment. The namespace URI is like a family surname and the local name is like 
a given name, except that in our case there cannot be duplication of given 
names. This means that names (local names) only need to be unique within the 
namespace. Again, by analogy, it’s fine to have a person named <i>John</i> in the 
<i>Adams</i> 
namespace and a person named <i>John</i> in the <i>Kennedy</i> namespace. The problem of 
establishing unique identifiers is not eliminated, but it is made much easier.</p>
<p>Extending our example to fit URI syntax, the URIs for our two namespaces 
might be:</p>
<ul>
  <li><i>http://family.org/famous/family/Adams</i></li>
  <li><i>http://family.org/
famous/family/Kennedy</i></li>
</ul>
<p>Using the local name <i>John</i>, we can now construct the URIs for each person and 
include some other people too:</p>
<ul>
  <li><i>http://family.org/famous/family/Adams#John</i></li>
  <li><i>http://family.org/famous/family/Kennedy#John</i></li>
  <li><i>http://family.org/famous/family/Adams#Abigail</i></li>
  <li><i>http://family.org/famous/family/Kennedy#Jacqueline</i></li>
</ul>
<p>So far we have for each person listed  1) a URI establishing identity, and 2) 
a [local] name by which they are known in the namespace (family). URIs tend to 
not be very human-reader-friendly, so we introduce one more way of referring to 
something—the <i>qualified name </i>or <i>qname</i>. Suppose that we gave a nickname to each 
namespace. We’ll call the first <i>adams</i> and the second <i>kennedy</i>. This isn’t a 
valid global approach, but in a limited context, as long as this mapping from 
namespace URI to nick name is shared by all parties concerned and is unique, we could refer to 
persons by their qname:</p>
<ul>
  <li><i>adams:John</i></li>
  <li><i>kennedy:John</i></li>
</ul>
<p>It is an [almost] unbearable burden to have to create a globally unique 
identifier for everything. As humans, we don’t do it. (In fact, even when an 
identifier exists we will not necessarily use it. When’s the last time you used 
the VIN of your automobile in conversation?) Mostly we identify things by their 
relationship to other things that are easily identified. Fortunately, in the ontology 
language we use, we can do exactly that—identify things solely by their 
relationship to other things. As we’ll see a little later, such an unnamed 
concept is called a <i>blank node</i> or <i>bnode</i>.</p>
<h2><a name="Sets">Sets and Members (AKA Classes and Instances)</a></h2>
<p>People naturally categorize things. This is very beneficial in at least two 
ways. 1) It allows us to compress the enormous quantity of information that 
bombards us every day into higher-level representations. 2) It allows us to 
communicate much more parsimoniously. What people do subconsciously 
mathematicians have been formalizing for millennia as set theory. A set is a 
grouping of things, usually similar in some way we care about. In ontologies we 
often call this grouping or category or type a <i>class</i>. </p>
<h3><a name="Hierarchies">Class Hierarchies</a></h3>
<p>Sets, whether formal or informal, are useful in part because we can order 
them in hierarchies of classes, sub-classes, and super-classes. For example, we 
might define the class <i>LivingThing</i> and put in it all things that are alive. We 
might further define the class <i>Mammal</i> as those instances of <i>LivingThing</i> that are 
warm-blooded, have hair, and give milk to their offspring. We then say that 
<i>Mammal</i> is a sub-class of <i>LivingThing</i>. What we mean by this is that every 
instance of a <i>Mammal</i> is also an instance of a <i>LivingThing</i>. Similarly, 
<i>Dog</i> and 
<i>Cat</i> are sub-classes of <i>Mammal</i>, etc. Viewed as a Venn Diagram, the sub-class is 
entirely within the super-class as shown in Figure 1. It is helpful when 
creating sub-classes of a given class if they are distinct, meaning that no 
member of one sub-class is also a member of a sibling sub-class. The diagram in 
Figure 1 assumes that of <i>Dog</i> and <i>Cat</i>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<img border="0" src="images/Founda1.jpg" width="433" height="338"></p>
<blockquote>
<p><b>Figure 1: Venn Diagram of <i>LivingThing</i>, <i>Mammal</i>, <i>Dog</i>, 
<i>Cat</i>.</b></p>
</blockquote>
<p>Partial ordering in class hierarchies is very powerful both in terms of compressing information and 
in terms of decompressing information to “infer” answers. Thus, if I am 
unfamiliar with the class <i>Civet</i> but you tell me that it is a <i>Mammal</i> about the 
size of a small <i>Dog</i>, you have in one sentence conveyed to me most what there is 
to know about <i>Civets</i>.</p>
<p>Inexperienced modelers often confuse class hierarchy relationships with other 
relationships, especially aggregation—when something is part of something else. 
There is a very simple rule that can be applied to clarify such confusion. 
<i>ClassA</i> is a sub-class of <i>ClassB</i> if and only if every instance of 
<i>ClassA</i> is also 
an instance of <i>ClassB</i>. Try this on, for example, the class <i>Bicycle</i>. 
Suppose that you are tempted to say that <i>Frame</i> is a type of <i>Bicycle</i>. 
Ask the question, is every instance of <i>Frame</i> also an instance of <i>
Bicycle</i>? Obviously not, so the class-subclass relationship is NOT the right 
one.</p>
<h3><a name="ClassVsInstance">When Is Something a Class, When Is It an Instance?</a></h3>
<p>The individual things that we group together in a class are instances or 
members of the class. In creating an ontology the question often arises as to 
when to make a concept a class and when to model it as an instance. A couple of 
considerations apply to this question. First, the principle of keeping things as 
simple as possible favors just creating an instance. This is especially 
attractive if there is really only one instance of the would-be class that is of 
concern. However, 
if there are multiple instances AND these instances differ in some way important 
to the purpose of the model, then the concept must be modeled as a class so that 
individual instances of the class can be given different properties and there by differentiated.</p>
<h2><a name="Properties">Characteristics, Relationships, and Properties</a></h2>
<p>Generalizing over individual things to create classes and class hierarchies 
is not the only way in which people extract models from observations. We also 
create groupings of the characteristics of things and how things are related to 
other things and give these names. For example, we call how long something has 
existed its <i>age</i>.&nbsp; Or how strongly something interacts with the mass of the 
planet its <i>weight</i>. Or the relationship to a being that someone likes to be with 
as <i>friend</i>. Or the relationship of a person to their offspring as <i>child</i>.</p>
<p>There is a somewhat natural tendency to differentiate between the 
characteristics of some thing and how the thing is related to other things. The 
essence of this differentiation seems to be the existence with identity of the 
object of the statement. If the object is an individual, a thing with 
independent existence and identity, then we call it a relationship. However, if not then it 
is a characteristic. By this explanation <i>friend</i> is a relationship but <i>age</i> and 
<i>weight</i> are characteristics. In our ontology modeling languages, we call both 
relationships and characteristics <i>properties</i>. In our modeling languages, 
we call relationships<i> object 
properties</i> and characteristics <i>data type properties.</i></p>
<p>In our ontology modeling languages, properties as well as individuals and 
classes, are first-class citizens. By this we mean that they can be defined 
independent of anything else. This is not true in many programming languages. 
For example, in object-oriented languages like Java, properties are represented 
as fields in a class and cannot exist outside of a class definition. This means 
that the class of things which can have the property is implicit in where the 
property is defined. However, with independent property definitions we can state 
explicitly what class(es) of things can have this property by specifying the 
property’s <i>domain</i>. We can further specify what type of values a property can 
have by specifying the property’s <i>range</i>. In our examples, we might say that the 
domain of <i>age</i> and <i>weight</i> is <i>PhysicalThing</i> while the domain of 
<i>friend</i> is <i>Person</i>. 
The range of <i>age</i> and <i>weight</i> might be specified (ignoring units for the moment) 
as <i>numeric</i>. </p>

<h2><a name="Graphs">Graph Models, Graph Patterns, and Graph Query Languages</a></h2>
<p>Implicit in our discussion of properties in the previous section is the idea 
of a directed graph. An instance of the domain class can have a property with a 
value drawn from the range. For example, If <i>Jonathan</i> and <i>David</i> are 
instances of the class <i>Person</i>, one might say <i>Jonathan friend David</i>. 
Or one might say <i>Jonathan age 23</i>. Each of these statements has a subject, 
a property, and a property value. There is an explicit order to the statement.
<i>Jonathan</i> has an <i>age</i>, <i>23</i> does not have an <i>age</i>. 
Therefore statements of this kind are a set of edges of a directed graph. We say 
that an ontology of this type is a graph model.</p>
<p>Given a graph model, we can express patterns to query the model. Continuing 
our example, one possible pattern would be <i>? age 23</i>, meaning, &quot;<i>who has 
age 23?&quot; </i>The question mark in the subject location indicates that we want to 
find all of the statements in our model that have any subject and the property
<i>age</i> with value <i>23</i>. By giving question marks names to create what 
we call &quot;variables&quot;, we can tie multiple graph patterns together to create a 
more complex pattern. For example, <i>?p1 friend ?p2, ?p2 age 23</i> means find 
all possible instances in the model such that some instance (<i>p1</i>) has a <i>
friend</i> (<i>p2</i>) who has <i>age</i> <i>23</i>. </p>
<p>Graph query languages allow one to express complex queries over a graph model 
by specifying a set of graph patterns. Languages differ in how the variables are 
identified (some use the <i>?&lt;name&gt;</i> syntax as in this example), what 
connective is used between the individual graph patterns (we arbitrarily used a 
comma in this example), etc. Graph query languages are powerful ways to extract 
information from our ontologies.</p>

</body>

</html>