<h1>The SADL Intermediate Form</h1>
<h6>Last revised
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->01/04/2018<!--webbot bot="Timestamp" endspan i-checksum="12559" --> 
by <a href="mailto:crapo@research.ge.com?subject=Requirements Language">A. W. 
Crapo</a>.</h6>
<h2>Table of Contents</h2>
<ul>
  <li><a href="#Introduction">Introduction</a></li>
  <li><a href="#ClassHierarchy">The Class Hierarchy</a></li>
  <li><a href="#IF1">Introducing the Intermediate Form</a></li>
  <li><a href="#IF2">Functions in the Intermediate Form</a></li>
  <li><a href="#IF3">Other Classes in the Intermediate Form</a></li>
  <li><a href="#BI1">BuiltinElements Supporting SADL Grammar Constructs</a></li>
  <li><a href="#BI2">Additional BuiltinElements</a></li>
</ul>
<h2><a name="Introduction">Introduction</a></h2>
<p>The SADL Intermediate Form is an in-memory representation used to capture the 
semantics of graph patterns and functions used in SADL rules, queries, and 
tests. This in-memory representation serves several purposes.</p>
<ol>
  <li>It serves as the input to target reasoner-specific translators that then 
  convert rules and queries into the format required by the reasoner. For 
  example, a Jena-based reasoner requires that rules be expressed in Jena Rule 
  language and that queries be expressed in SPARQL. Hence a compatible 
  Jena-based translator will translate the Intermediate Form into Jena Rules and SPARQL queries.</li>
  <li>It serves as the mechanism for capturing and preserving tests and other 
  SADL &quot;commands&quot; during model processing so that they can be processed during 
  inferencing of a SADL model.</li>
  <li>Expressions in the Intermediate Form can be serialized for examination by 
  users (the Expr command).</li>
</ol>
<h2><a name="ClassHierarchy">The Class Hierarchy</a></h2>
<p>The in-memory Intermediate Form consists of two set of classes related in 
sub-class/super-class hierarchies. These classes' names reflect support for a 
graph model. The &quot;Node&quot; hierarchy represents those concepts that can be nodes 
(and directed edges) in the graph model. The &quot;GraphPatternElement&quot; class 
represents constructs that are built from nodes, e.g., a graph &quot;TripleElement&quot; 
contains a head node, directed edge node, and an object or value node.</p>
<ul>
  <li>Node<ul>
    <li>ConstantNode</li>
    <li>KnownNode</li>
    <li>Literal</li>
    <li>NamedNode<ul>
      <li>RDFTypeNode</li>
      <li>VariableNode</li>
    </ul>
    </li>
    <li>ProxyNode</li>
    <li>ValueTableNode</li>
  </ul>
  </li>
  <li>GraphPatternElement<ul>
    <li>BuiltinElement</li>
    <li>Junction</li>
    <li>TripleElement</li>
  </ul>
  </li>
</ul>
<p>Instances of these these classes have serializations to allow one to &quot;see&quot; 
their contents, but the serializations are not meant for persistence. That is, 
there is no parser to recreate the in-memory structure from the serialization. 
In fact, each of them has multiple serializations generated by methods 
indicative of the serialization.</p>
<ul>
  <li>toString() -- generates the most terse serialization containing the names 
  and relationships; names are in qualified name form</li>
  <li>toFullyQualifiedString() -- generates content similar to toString() except 
  that all names are expanded to complete URIs</li>
  <li>toDescriptiveString() -- the most verbose serialization with additional 
  comments in-line, e.g., the type of a variable is displayed after the 
  variable's name</li>
</ul>
<h2><a name="IF1">Introducing the Intermediate Form</a></h2>
<p>Developers will want to look at the actual Java code for the classes of the 
Intermediate Form, which can be seen in the source code repository for SADL3 at
<a href="https://github.com/crapo/sadlos2/tree/master/sadl3/com.ge.research.sadl.parent/com.ge.research.sadl.reasoner-api/src/main/java/com/ge/research/sadl/model/gp">
this location</a>. This document will use the serializations of these classes 
for discussion. These serializations have a predicate logic flavor. For example, 
the serialization of a TripleElement uses the predicate &quot;rdf&quot; and has three 
arguments, the triple's subject, property, and object or value: </p>
<blockquote>
  <p>rdf(&lt;subjectNode&gt;, &lt;propertyNode&gt;, &lt;objectNode&gt;)</p>
</blockquote>
<p>The Intermediate Form is generated from the SADL parse tree and so, like the 
grammar itself, can have nested expressions. For example, </p>
<blockquote>
  <font SIZE="2" COLOR="#800080">
  <p>the</font><font SIZE="2"> </font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2">
  </font><font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#800080">a</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#008000"><b>friend</b></font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#0000ff">Plato</font> </p>
</blockquote>
<p>would create an Intermediate Form with a nested graph pattern, which may be 
visualized as (prefixes omitted from names): </p>
<blockquote>
  <p ALIGN="LEFT">rdf((rdf(Plato, friend, null)), age, null)</p>
</blockquote>
<p>A &quot;null&quot; argument indicates that there is nothing in the parse tree for that 
graph node. Note also that the inner or nested triple pattern is surrounded by 
an extra set of parentheses. This is because the arguments of the &quot;rdf&quot; 
predicate are nodes, but the subject in this case is not a node but another 
triple. The inner TripleElement is therefore wrapped in a ProxyNode, and the 
serialization of that ProxyNode produces the extra parentheses.</p>
<p>The nested triples shown above constitute the &quot;raw&quot; Intermediate Form. If we 
flatten any nesting that has occurred and replace any &quot;null&quot; nodes with variable 
nodes we arrive at the &quot;cooked&quot; Intermediate Form. For this example, cooking 
produces this serialization:</p>
<blockquote>
  <p ALIGN="LEFT">and(rdf(Plato, friend, v2), rdf(v2, age, v3))</p>
</blockquote>
<p>The &quot;and&quot; predicate is the serialization of the conjunctive Junction 
GraphPatternElement subclass. This cooked form reflects the order that is 
required for binding in rules or queries. Given the subject &quot;Plato&quot; and property 
&quot;friend&quot;, the object variable &quot;v2&quot; will be bound to the possible value(s) for 
the triple pattern. Then for each binding of &quot;v2&quot;, the second triple pattern 
with property &quot;age&quot; will cause the object variable &quot;v3&quot; to be bound to the 
value(s) matching that triple pattern.</p>
<h2><a name="IF2">Functions in the Intermediate Form </a></h2>
<p>Consider as another example SADL statement:</p>
<blockquote>
  <font SIZE="2" COLOR="#0000ff">
  <p>Socrates</font><font SIZE="2"> </font><font SIZE="2" COLOR="#800080">has</font><font SIZE="2">
  </font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2"> (</font><font SIZE="2" COLOR="#008000"><b>age</b></font><font SIZE="2">
  </font><font SIZE="2" COLOR="#800080">of</font><font SIZE="2"> </font>
  <font SIZE="2" COLOR="#0000ff">Plato</font><font SIZE="2"> + 33)</p>
  </font>
</blockquote>
<p>&nbsp;This raw Intermediate Form of this statement is also nested (prefixes 
again removed):</p>
<blockquote>
  <p ALIGN="LEFT">rdf(Socrates, age, (+((rdf(Plato, age, null)),33)))</p>
</blockquote>
<p>In this expression we see that the object of the first triple pattern is a 
BuiltinElement with name &quot;+&quot; and having 2 arguments, the first a nested triple 
and the second the Literal &quot;33&quot;. Note that the nested triple is again surrounded 
with an extra set of parentheses indicating the presence of a ProxyNode wrapping 
that triple so that it can be an argument for the BuiltinElement whose arguments 
must be Nodes. Note that the &quot;+&quot; BuiltinElement is also wrapped in an extra set 
of parentheses indicating that the BuiltinElement is also wrapped in a ProxyNode 
to allow it to be the object of the first triple.</p>
<p>Cooking the raw Intermediate Form yields the following expression:</p>
<blockquote>
  <p ALIGN="LEFT">and(rdf(Socrates, age, v1), and(rdf(Plato, age, v0), 
  +(v0,33,v1)))</p>
</blockquote>
<p>This statements suggests that an assignment is being made and the order of 
the elements of the expression are not in the order in which evaluation would 
need to occur. Rather the variable &quot;v0&quot; would be bound, then the variable &quot;v1&quot; 
would be bound, and then the assignment of values to the triple &quot;rdf(Socrates, 
age, v1)&quot; using the binding(s) of &quot;v1&quot; would be made. Correct ordering of the 
expression is the job of the translator consuming the Intermediate Form since 
the order is context-dependent. Note that the &quot;+&quot; BuiltinElement has 3 arguments 
in the cooked form. The third argument is the variable which is bound to the 
results of performing the addition on the first two arguments.</p>
<h2><a name="IF3">Other Classes in the Intermediate Form</a></h2>
<p>An instance of the Junction class can be conjunctive (&quot;and&quot;) or disjunctive 
(&quot;or&quot;). The KnownNode is a special node corresponding to the &quot;known&quot; keyword in 
the SADL grammar. The exact meaning of &quot;known&quot; is determined by the translator, 
but the general sense is that of &quot;any value&quot; when by itself and &quot;no value 
exists&quot; when negated (&quot;not known&quot;). The ConstantNode captures constants such as 
the mathematical values &quot;PI&quot; and &quot;e&quot;. It is also used for the keyword &quot;None&quot;, 
whose meaning is also determined by the translator although the general sense is 
that of not being and thereby similar to &quot;not known&quot;.</p>
<p>The RDFTypeNode captures the ontology property &quot;rdf:type&quot;, which is the 
relationship between an instance and a class to which that instance belongs. In 
SADL this relationship is represented by &quot;is a&quot;. Note that this is distinctly 
different from the subclass-superclass relationship, &quot;rdfs:subClassOf&quot; and &quot;is a 
type of&quot; in SADL.</p>
<p>We encountered variable nodes in the examples above. A variable node has a 
name, either supplied by the user or created to be unique by the model 
processor. In the examples above, all variable names were created by the model 
processor as variables were implicit in the SADL statements and were only needed 
to flatten the Intermediate Form during cooking, also known as ProxyNode 
expansion.</p>
<h2><a name="BI1">BuiltinElements Supporting SADL Grammar Constructs</a></h2>
<p>There are a number of SADL grammar constructs that generate BuiltinElements 
when parsed and processed by the model processor. These include the following. 
After each is the form of the BuiltinElement in cooked (complete) form.</p>
<ul>
  <li>Junctive Keywords<ul>
    <li>and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>Equality/Inequality/Assignment Keywords<ul>
    <li>is&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is 
    (&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>is not&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not(is(&lt;arg1&gt;, &lt;arg2&gt;))</li>
    <li>==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
    <li>!=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; not(is(&lt;arg1&gt;, 
    &lt;arg2&gt;))</li>
  </ul>
  </li>
  <li>Comparison Keywords<ul>
    <li>&lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    &lt;(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>&lt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;=(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
    <li>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    &gt;(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>&gt;=&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;=(&lt;arg1&gt;, 
    &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>Math Operation Keywords<ul>
    <li>+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    +(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>-&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    -(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    *(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>/&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    /(&lt;arg1&gt;, &lt;arg2&gt;)</li>
    <li>%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    %(&lt;arg1&gt;, &lt;arg2&gt;)</li>
  </ul>
  </li>
  <li>List Operation Keywords<ul>
    <li>element before &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementBefore(&lt;list&gt;,&lt;element&gt;)</li>
    <li>element after &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementAfter(&lt;list&gt;,&lt;element&gt;)</li>
    <li>element &lt;n&gt; of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    elementInList(&lt;list&gt;,&lt;n&gt;)</li>
    <li>first element of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    firstElement(&lt;list&gt;)</li>
    <li>last element of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    lastElement(&lt;list&gt;)</li>
    <li>length of &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    length(&lt;list&gt;)</li>
    <li>count of &lt;element&gt; in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    count(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;list&gt; contains &lt;element&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    contains(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;list&gt; does not contain &lt;element&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    not(contains(&lt;list&gt;, &lt;element&gt;))</li>
    <li>&lt;element&gt; is unique in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    unique(&lt;list&gt;, &lt;element&gt;)</li>
    <li>&lt;element&gt; is not unique in &lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    not(unique(&lt;list&gt;, &lt;element))</li>
    <li>the sublist of &lt;list&gt; matching &lt;conditions&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    sublist(&lt;list&gt;,&lt;condition&gt;)</li>
  </ul>
  </li>
</ul>
<h2><a name="BI2">Additional BuiltinElements</a></h2>
<p>Additional BuiltinElements can come from two sources. The first is directly 
from the modeler via Equation and External statements. These statements add to 
the set of functions that can be used in SADL expressions and properly processed 
into BuiltinElements in the Intermediate Form. The second source is from the 
selected reasoner/translator pair. The definitions of additional built-in 
functions known to the reasoner/translator, e.g., the trig functions like &quot;sin&quot;, 
&quot;cos&quot;, etc., will be supplied to the model processor and will be persisted in 
SADL External statements in the SadlBuiltinFunctions.sadl file in the project's 
ImplicitModel folder. These may or may not come with a complete signature 
indicating the number and type of arguments and the type returned by the 
function, depending upon the reasoner/translator selected.</p>
<p>&nbsp;</p>