/*
 * generated by Xtext
 */
package com.ge.research.sadl.scoping;

import javax.inject.Inject;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.SimpleScope;

import com.ge.research.sadl.resource.SadlDerivedStateComputer;
import com.ge.research.sadl.sadl.Query;
import com.ge.research.sadl.sadl.ResourceByName;
import com.ge.research.sadl.sadl.ResourceName;
import com.ge.research.sadl.sadl.Rule;
import com.ge.research.sadl.sadl.SadlPackage;
import com.ge.research.sadl.sadl.Test;
import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.Iterables;

/**
 * This class contains custom scoping description.
 *
 */
public class SadlScopeProvider extends org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {
	@Inject
	private IQualifiedNameProvider qnProvider;

	@Override
	public IScope getScope(EObject context, EReference reference) {
		if (reference == SadlPackage.Literals.RESOURCE_BY_NAME__NAME) {
			return getResourceNameScope(context,reference);
		}
		return super.getScope(context, reference);
	}
	
	/**
	 * The scope of ResourceByName#name differs from the default when the ResourceByName element is within
	 * the context of a Rule,Query or Test. These elements can use ResourceByName for variables, which do not need
	 * to be declared. For such unbound variables the {@link SadlDerivedStateComputer} installs virtual
	 * ResourceNames into the local resource. If a ResourceByName does not refer to a declared ResourceName, it must
	 * refer to a variable. Since the regular scope (including the global scope) must be searched first before considering
	 * local ResourceNames, the regular scope must be an inner scope, and variables are put to the outer scope.
	 */
	private IScope getResourceNameScope (EObject context, EReference reference) {
		EObject variableContainer = getContextContainerFor((ResourceByName) context);
		if (context.eResource().getContents().size()<=1 || variableContainer==null) {
			return super.getScope(context, reference);
		}

		IScope parent = delegateGetScope(context, reference);
		
		final QualifiedName qn = qnProvider.getFullyQualifiedName(variableContainer);
		Iterable<ResourceName> variableNames = Iterables.filter(context.eResource().getContents(), ResourceName.class);
		variableNames = Iterables.filter(variableNames, new Predicate<ResourceName>() {
			@Override
			public boolean apply(ResourceName input) {
				return input.getName().startsWith(qn.toString()+"_");
			}
		});
		// Virtual ResourceNames have a virtual prefix, which is the name of the container they are used within followed by the '_' separator char.
		// The actual variable names must be computed by stripping of this prefix off.
		Function<ResourceName,QualifiedName> namingFunction = new Function<ResourceName, QualifiedName>() {
			@Override
			public QualifiedName apply(ResourceName input) {
				String name = input.getName().replace(qn.toString()+"_", "");
				return QualifiedName.create(name);
			}
		};
		IScope variablesScope = Scopes.scopeFor(variableNames, namingFunction, IScope.NULLSCOPE);
		
		return new SimpleScope(variablesScope, parent.getAllElements());
	}
	
	private EObject getContextContainerFor (ResourceByName rn) {
		for (EObject ctx = rn.eContainer(); ctx!=null; ctx=ctx.eContainer()) {
			if (ctx instanceof Rule || ctx instanceof Test ||ctx instanceof Query) {
				return ctx;
			}
		}
		return null;
	}
}
