 /************************************************************************
 * Copyright Â© 2007-2010 - General Electric Company, All Rights Reserved
 *
 * Project: SADL
 *
 * Description: The Semantic Application Design Language (SADL) is a
 * language for building semantic models and expressing rules that
 * capture additional domain knowledge. The SADL-IDE (integrated
 * development environment) is a set of Eclipse plug-ins that
 * support the editing and testing of semantic models using the
 * SADL language.
 *
 * This software is distributed "AS-IS" without ANY WARRANTIES
 * and licensed under the Eclipse Public License - v 1.0
 * which is available at http://www.eclipse.org/org/documents/epl-v10.php
 *
 ***********************************************************************/

 package com.ge.research.sadl.builder;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ge.research.sadl.model.ConceptName;
import com.ge.research.sadl.model.gp.BuiltinElement;
import com.ge.research.sadl.model.gp.BuiltinElement.BuiltinType;
import com.ge.research.sadl.model.gp.GraphPatternElement;
import com.ge.research.sadl.model.gp.Junction;
import com.ge.research.sadl.model.gp.Junction.JunctionType;
import com.ge.research.sadl.model.gp.KnownNode;
import com.ge.research.sadl.model.gp.Literal;
import com.ge.research.sadl.model.gp.ProxyNode;
import com.ge.research.sadl.model.gp.Query;
import com.ge.research.sadl.model.gp.Query.Order;
import com.ge.research.sadl.model.gp.Query.OrderingPair;
import com.ge.research.sadl.model.gp.TripleElement.TripleModifierType;
import com.ge.research.sadl.model.gp.NamedNode;
import com.ge.research.sadl.model.gp.Node;
import com.ge.research.sadl.model.gp.RDFTypeNode;
import com.ge.research.sadl.model.gp.Rule;
import com.ge.research.sadl.model.gp.Test;
import com.ge.research.sadl.model.gp.TripleElement;
import com.ge.research.sadl.model.gp.TripleElement.TripleSourceType;
import com.ge.research.sadl.model.gp.ValueTableNode;
import com.ge.research.sadl.model.gp.VariableNode;
import com.ge.research.sadl.model.gp.NamedNode.NodeType;
import com.ge.research.sadl.model.gp.Test.ComparisonType;
import com.ge.research.sadl.reasoner.InvalidNameException;
import com.ge.research.sadl.reasoner.InvalidTypeException;
import com.ge.research.sadl.reasoner.TranslationException;
import com.ge.research.sadl.sadl.BinaryOpExpression;
import com.ge.research.sadl.sadl.ExplicitValue;
import com.ge.research.sadl.sadl.Expression;
import com.ge.research.sadl.sadl.GraphPattern;
import com.ge.research.sadl.sadl.JunctionExpression;
import com.ge.research.sadl.sadl.InstAttrPSV;
import com.ge.research.sadl.sadl.InstAttrSPV;
import com.ge.research.sadl.sadl.InstanceDeclaration;
import com.ge.research.sadl.sadl.IntervalValue;
import com.ge.research.sadl.sadl.MergedTriples;
import com.ge.research.sadl.sadl.OfPhrase;
import com.ge.research.sadl.sadl.OrderElement;
import com.ge.research.sadl.sadl.PropOfSubj;
import com.ge.research.sadl.sadl.PropValPartialTriple;
import com.ge.research.sadl.sadl.ResourceByName;
import com.ge.research.sadl.sadl.ResourceIdentifier;
import com.ge.research.sadl.sadl.ResourceName;
import com.ge.research.sadl.sadl.SelectExpression;
import com.ge.research.sadl.sadl.SubTypeOf;
import com.ge.research.sadl.sadl.SubjProp;
import com.ge.research.sadl.sadl.TypeDeclaration;
import com.ge.research.sadl.sadl.TypedBNode;
import com.ge.research.sadl.sadl.UnaryOpExpression;
import com.ge.research.sadl.sadl.ValueRow;
import com.ge.research.sadl.sadl.ValueTable;
import com.ge.research.sadl.sadl.VariableList;
import com.ge.research.sadl.sadl.WithChain;
import com.ge.research.sadl.sadl.WithPhrase;
import com.ge.research.sadl.utils.SadlUtils.ConceptType;
import com.hp.hpl.jena.graph.GraphEventManager;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.reasoner.rulesys.BuiltinException;
import com.hp.hpl.jena.vocabulary.RDFS;

/**
 * This class translates the output generated by parsing SADL queries, 
 * rules, and tests into what is called the SADL Intermediate Form (IF).  
 * The parser output is in the form of parse trees whose nodes are 
 * instances of the class Expression or of one of its subclasses.
 * The IF uses the Java classes in the Graph Patterns package 
 * (com.ge.research.sadl.model.gp). In the IF, each query or 
 * rule part (given, if, or then) or test phrase consists of 
 * a list of graph pattern elements.  The graph pattern element 
 * can be a triple pattern or it can be a built-in.  This 
 * Intermediate Form is passed to the reasoner-specific translator 
 * to generate rules and queries in an optimized form and format 
 * for the target reasoner.
 * 
 * One of the primary contributions of SADL to the modeling process is
 * its English-like syntax. The translation accomplished by this class
 * goes from this English-like syntax to the IF. Among other things, this
 * involves the generation of "missing" variables to provide the 
 * connectives between the individual graph pattern elements in a list.
 * 
 * The translation process "walks" the Expression parse tree. At the 
 * leaves of this parse tree are ExplicitValues, IntervalValues, 
 * ValueTables, or built-ins. At each node higher in the parse tree, 
 * if returning to the node represents the completion of a graph pattern 
 * element then that element is placed in the list at the appropriate 
 * location and if necessary a variable (Node) is identified to connect 
 * this new graph pattern element to other graph pattern elements 
 * in the list.
 * 
 * 10/2011:
 * The approach of adding variables as the translation proceeds, bottom-up,
 * has issues as looking bottom up one can't always tell the context and
 * therefore make the right decision. Therefore the strategy is changed to 
 * use a ProxyNode to encapsulate the lower-level constructs to replicate
 * the parse tree but in the IF structures. Then the expansion of ProxyNodes
 * can occur with a knowledge of context for proper decisioning. For example,
 * no information is available to know whether a rule built-in has zero, one,
 * or more output variables. However, usage will show that either the built-in
 * is used within a higher-level built-in or triple, in which case it must 
 * generate an output other than boolean so in expand ProxyNodes it will be
 * property handled by adding a generated variable if a specified variable
 * was not given, which variable is also placed in
 * the higher-level construct. In the future built-ins might be allowed to 
 * return multiple values but that would require a construct such as
 * 
 * 	x,y,z is someBuiltin(input1, input2, ..)
 * 
 * This extension of the grammar would provide the necessary information 
 * about the number of output variables to add, but only with the contextual
 * knowledge of the whole statement.
 * 
 * 
 * @author crapo
 *
 */
public class IntermediateFormTranslator {
    private static final Logger logger = LoggerFactory.getLogger(IntermediateFormTranslator.class);
    private int vNum = 0;	// used to create unique variables
    private List<IFTranslationError> errors = null;
    private ModelManager modelManager = null;
    private Object target = null;	// the instance of Rule, Query, or Test into which we are trying to put the translation
    private Object encapsulatingTarget = null;	// when a query is in a test
    private GraphPatternElement firstOfPhrase = null;
    
    private List<ConceptName> namedNodes = null;
    private boolean collectNamedNodes = false;
    private List<String> userDefinedVariables = new ArrayList<String>();
    
    /**
     * The constructor takes a ModelManager argument
     * @param modmgr
     */
    public IntermediateFormTranslator(ModelManager modmgr) {
    	modelManager = modmgr;
    }
    
    // the target can be a Test, a Query, or a Rule instance
    public void setTarget(Object _target) {
    	target = _target;
    }
    
	protected String getNewVar() {
		String proposedName = "v" + vNum;
		while (userDefinedVariables.contains(proposedName) ||
				!modelManager.getConceptType(proposedName).equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)) {
			vNum++;
			proposedName = "v" + vNum;
		}
		vNum++;
		return proposedName;
	}
	
	/**
	 * This method looks in the clauses of a Rule to see if there is already a triple matching the given pattern. If there is
	 * a new variable of the same name is created (to make sure the count is right) and returned. If not a rule or no match
	 * a new variable (new name) is created and returned.
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode getVariableNode(Node subject, Node predicate, Node object) {
		if (target != null) {
			// Note: when we find a match we still create a new VariableNode with the same name in order to have the right reference counts for the new VariableNode
			if (target instanceof Rule) {
				VariableNode var = findVariableInTripleForReuse(((Rule)target).getGivens(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
				var = findVariableInTripleForReuse(((Rule)target).getIfs(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
				var = findVariableInTripleForReuse(((Rule)target).getThens(), subject, predicate, object);
				if (var != null) {
					return new VariableNode(var.getName());
				}
			}
		}
		return new VariableNode(getNewVar());
	}
	
	/**
	 * Supporting method for the method above (getVariableNode(Node, Node, Node))
	 * @param gpes
	 * @param subject
	 * @param predicate
	 * @param object
	 * @return
	 */
	protected VariableNode findVariableInTripleForReuse(List<GraphPatternElement> gpes, Node subject, Node predicate, Node object) {
		if (gpes != null) {
			Iterator<GraphPatternElement> itr = gpes.iterator();
			while (itr.hasNext()) {
				GraphPatternElement gpe = itr.next();
				while (gpe != null) {
					if (gpe instanceof TripleElement) {
						TripleElement tr = (TripleElement)gpe;
						Node tsn = tr.getSubject();
						Node tpn = tr.getPredicate();
						Node ton = tr.getObject();
						if (subject == null && tsn instanceof VariableNode) {
							if (predicate != null && predicate.equals(tpn) && object != null && object.equals(ton)) {
								return (VariableNode) tsn;
							}
						}
						if (predicate == null && tpn instanceof VariableNode) {
							if (subject != null && subject.equals(tsn) && object != null && object.equals(ton)) {
								return (VariableNode) tpn;
							}
						}
						if (object == null && ton instanceof VariableNode) {
							if (subject != null && subject.equals(tsn) && predicate != null && predicate.equals(tpn)) {
								return (VariableNode) ton;
							}
						}
					}
					gpe = gpe.getNext();
				}
			}
		}
		return null;
	}
	
	/**
	 * This method is currently just a placeholder for finding variables for reuse in built-in patterns.
	 * Currently it just creates a new variable with a new name.
	 * @param bltin
	 * @return
	 */
	protected VariableNode getVariableNode(BuiltinElement bltin) {
		if (target != null) {
			
		}
		return new VariableNode(getNewVar());
	}
	
	/**
	 * Reset the translator for a new translation task
	 */
	protected void resetIFTranslator() {
		vNum = 0;
		if (errors != null) {
			errors.clear();
		}
		target = null;
		encapsulatingTarget = null;
		setFirstOfPhrase(null);
	}

	/**
	 * The most general translator method--for any Expression
	 * 
	 * @param expr
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object translate(Expression expr) throws InvalidNameException, InvalidTypeException, TranslationException {
		Object pattern = null; // our return value

		if (expr instanceof BinaryOpExpression) {
			pattern = translate((BinaryOpExpression)expr);
		}
		else if (expr instanceof JunctionExpression) {
			pattern = translate((JunctionExpression)expr);
		}
		else if (expr instanceof UnaryOpExpression) {
			pattern = translate((UnaryOpExpression)expr);
		}
		else if (expr instanceof SelectExpression) {
			Query theQuery = null;
			if (!(target instanceof Rule)) {
				if (target instanceof Query) {
					// there can't be nested queries so if the target is a Query it's the one to use
					theQuery = (Query) target;
				}
				else {
					// other wise we must be inside a Test so create a new Query to hold the parse information
					theQuery = new Query();
				}
				if (((SelectExpression)expr).getDistinct() != null) {
					theQuery.setDistinct(true);
				}
				VariableList varList = ((SelectExpression)expr).getVarList();
				if (varList != null) {
					EList<ResourceName> rnames = varList.getNames();
					List<String> names = new ArrayList<String>();
					for (int i = 0; i < rnames.size(); i++) {
						names.add(rnames.get(i).getName());
					}
					theQuery.setVariables(names);
				}
				if (((SelectExpression)expr).getOrderby() != null) {
					EList<OrderElement> ol = ((SelectExpression)expr).getOrderList().getOrderList();
					List<OrderingPair> orderingPairs = new ArrayList<OrderingPair>();
					for (int i = 0; i < ol.size(); i++) {
						OrderElement oele = ol.get(i);
						String ord = oele.getOrder();
						orderingPairs.add(theQuery.new OrderingPair(oele.getName().getName(), 
								(ord != null && ord.equals("desc") ? Order.DESC : Order.ASC)));
					}
					theQuery.setOrderBy(orderingPairs);
				}
			}
			setEncapsulatingTarget(theQuery);
			pattern = translate(((SelectExpression)expr).getExpr());
			if (pattern instanceof GraphPatternElement) {
				if (target instanceof Query) {
					((Query)target).addPattern((GraphPatternElement) pattern);
				}
				else if (target instanceof Test) {
					theQuery.addPattern((GraphPatternElement) pattern);
					pattern = theQuery;
				}
			}
			else if (pattern != null){
				// don't do this--many incomplete forms will genertate this error while being created.
//				throw new TranslationException("The pattern of a SelectExpression isn't a GraphPatternElement! (" + pattern.toString() + ")");
			}
		}
		else if (expr != null) {
			Expression sexpr = expr.getExpr();
			String func = expr.getFunc();
			GraphPattern gp = expr.getGp();
			IntervalValue ivalue = expr.getIvalue();
			ExplicitValue value = expr.getValue();
			ValueTable valueTable = expr.getValueTable();
			if (sexpr != null) {
				pattern = translate(sexpr);
			}
			if (func != null) {
				pattern = translate(expr, func, expr.getArgs());
			}
			if (gp != null) {
				pattern = translate(gp);
			}
			if (ivalue != null) {
				pattern = translate(ivalue);
			}
			if (value != null) {
				pattern = translate(value);
			}
			if (valueTable != null) {
				pattern = translate(valueTable);
			}
		}

		return pattern;
	}
	
	/**
	 * Translation of a BinaryOpExpression
	 * 
	 * @param expr
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object translate(BinaryOpExpression expr) throws InvalidNameException, InvalidTypeException, TranslationException {
		String op = expr.getOp();
		BuiltinType optype = BuiltinType.getType(op);
		
		Expression lexpr = expr.getLeft();
		Expression rexpr = expr.getRight();
		Object lobj = translate(lexpr);
		Object robj = translate(rexpr);
		
		if (optype == BuiltinType.Equal || optype == BuiltinType.NotEqual) {
			// If we're doing an assignment, we can simplify the pattern.
			Node assignedNode = null;
			Object pattern = null;
			if (lobj instanceof NamedNode && !(lobj instanceof VariableNode) && hasCommonVariableSubject(robj)) {
				TripleElement trel = (TripleElement)robj;
				while (trel != null) {
					trel.setSubject((Node) lobj);
					trel = (TripleElement) trel.getNext();
				}
				return robj;
			}
			if ((lobj instanceof TripleElement || (lobj instanceof Literal && ModelManager.isSparqlQuery(((Literal)lobj).toString())))
					&& robj instanceof BuiltinElement) {
				if (isModifiedTriple(((BuiltinElement)robj).getFuncType())) {
					assignedNode = ((BuiltinElement)robj).getArguments().get(0);
					optype = ((BuiltinElement)robj).getFuncType();
					pattern = lobj;
				}
				else if (isComparisonBuiltin(((BuiltinElement)robj).getFuncName())) {
					if ( ((BuiltinElement)robj).getArguments().get(0) instanceof Literal) {
						((TripleElement)lobj).setObject(nodeCheck(robj));
						return lobj;
					}
					else {
						return createBinaryBuiltin(rexpr, ((BuiltinElement)robj).getFuncName(), lobj, ((BuiltinElement)robj).getArguments().get(0));
					}
				}
			}
			else if (lobj instanceof Node && robj instanceof TripleElement) {
				assignedNode = validateNode((Node) lobj);
				pattern = (TripleElement) robj;
			}
			else if (robj instanceof Node && lobj instanceof TripleElement) {
				assignedNode = validateNode((Node) robj);
				pattern = (TripleElement) lobj;
			}
			if (assignedNode != null && pattern != null) {
				// We're expressing the type of a named thing.
				if (pattern instanceof TripleElement && ((TripleElement)pattern).getSubject() == null) {
					if (isModifiedTripleViaBuitin(robj)) {
						optype = ((BuiltinElement)((TripleElement)pattern).getNext()).getFuncType();	
						((TripleElement)pattern).setNext(null);
					}
					((TripleElement)pattern).setSubject(assignedNode);
					if (optype != BuiltinType.Equal) {
						((TripleElement)pattern).setType(getTripleModifierType(optype));
					}
				}
				else if (pattern instanceof TripleElement && ((TripleElement)pattern).getObject() == null && 
						(((TripleElement)pattern).getSourceType().equals(TripleSourceType.PSnewV) 
								|| ((TripleElement)pattern).getSourceType().equals(TripleSourceType.PSV))) {
					if (isModifiedTripleViaBuitin(robj)) {
						optype = ((BuiltinElement)((TripleElement)pattern).getNext()).getFuncType();	
						((TripleElement)pattern).setNext(null);
					}
					((TripleElement)pattern).setObject(assignedNode);
					if (optype != BuiltinType.Equal) {
						((TripleElement)pattern).setType(getTripleModifierType(optype));
					}
				}
				else if (pattern instanceof TripleElement && ((TripleElement)pattern).getSourceType().equals(TripleSourceType.SPV)
						&& assignedNode instanceof NamedNode && getProxyWithNullSubject(((TripleElement)pattern)) != null) {
					TripleElement proxyFor = getProxyWithNullSubject(((TripleElement)pattern));
					assignNullSubjectInProxies(((TripleElement)pattern), proxyFor, assignedNode);
					if (optype != BuiltinType.Equal) {
						proxyFor.setType(getTripleModifierType(optype));
					}
				}
				else if (isModifiedTriple(optype) || 
						(optype.equals(BuiltinType.Equal) && pattern instanceof TripleElement && 
								(((TripleElement)pattern).getObject() == null || 
										((TripleElement)pattern).getObject() instanceof NamedNode ||
										((TripleElement)pattern).getObject() instanceof Literal))){
					if (pattern instanceof TripleElement && isModifiedTripleViaBuitin(robj)) {
						optype = ((BuiltinElement)((TripleElement)pattern).getNext()).getFuncType();
						((TripleElement)pattern).setObject(assignedNode);
						((TripleElement)pattern).setNext(null);
						((TripleElement)pattern).setType(getTripleModifierType(optype));
					}
					else if (isComparisonViaBuiltin(robj, lobj)) {
						BuiltinElement be = (BuiltinElement)((TripleElement)robj).getNext();
						be.addMissingArgument((Node) lobj);
						return pattern;
					}
					else if (pattern instanceof TripleElement){
						TripleElement lastPattern = (TripleElement)pattern;
						// this while may need additional conditions to narrow application to nested triples?
						while (lastPattern.getNext() != null && lastPattern instanceof TripleElement) {
							lastPattern = (TripleElement) lastPattern.getNext();
						}
						if (encapsulatingTarget instanceof Test) {
							((Test)encapsulatingTarget).setRhs(assignedNode);
							((Test)encapsulatingTarget).setCompName(optype);
						}
						else if (encapsulatingTarget instanceof Query && target instanceof Test) {
							((Test)target).setRhs(encapsulatingTarget);
							((Test)target).setLhs(assignedNode);
							((Test)target).setCompName(optype);
						}
						else if (target instanceof Test && assignedNode != null) {
							((Test)target).setLhs(pattern);
							((Test)target).setRhs(assignedNode);
							((Test)target).setCompName(optype);
							((TripleElement) pattern).setType(TripleModifierType.None);
							optype = BuiltinType.Equal;
						}
						else {
							lastPattern.setObject(assignedNode);
						}
						if (!optype.equals(BuiltinType.Equal)) {
							((TripleElement)pattern).setType(getTripleModifierType(optype));
						}
					}
					else {
						if (target instanceof Test) {
							((Test)target).setLhs(lobj);
							((Test)target).setRhs(assignedNode);
							((Test)target).setCompName(optype);
						}
					}
				}
				else if (encapsulatingTarget instanceof Test) {
					((Test)encapsulatingTarget).setRhs(assignedNode);
					((Test)encapsulatingTarget).setCompName(optype);
				}
				else if (target instanceof Rule && pattern instanceof TripleElement && ((TripleElement)pattern).getSourceType().equals(TripleSourceType.ITC) && 
						((TripleElement)pattern).getSubject() instanceof VariableNode && assignedNode instanceof VariableNode) {
					// in a rule of this type we just want to replace the pivot node variable
					doVariableSubstitution(((TripleElement)pattern), (VariableNode)((TripleElement)pattern).getSubject(), (VariableNode)assignedNode);
				}
				return pattern;
			}
			BuiltinElement bin = null;
			boolean binOnRight = false;
			Object retObj = null;
			if (lobj instanceof Node && robj instanceof BuiltinElement) {
				assignedNode = validateNode((Node)lobj);
				bin = (BuiltinElement)robj;
				retObj = robj;
				binOnRight = true;
			}
			else if (robj instanceof Node && lobj instanceof BuiltinElement) {
				assignedNode = validateNode((Node)robj);
				bin = (BuiltinElement)lobj;
				retObj = lobj;
				binOnRight = false;
			}
			if (bin != null && assignedNode != null) {
				if ((assignedNode instanceof VariableNode ||
					(assignedNode instanceof NamedNode && ((NamedNode)assignedNode).getNodeType().equals(NodeType.VariableNode)))) {
					while (bin.getNext() instanceof BuiltinElement) {
						bin = (BuiltinElement) bin.getNext();
					}
					if (bin.isCreatedFromInterval()) {
						bin.addArgument(0, assignedNode);
					}
					else {
						bin.addArgument(assignedNode);
					}
					return retObj;
				}
				else if (assignedNode instanceof Node && isComparisonBuiltin(bin.getFuncName())) {
					// this is a comparison with an extra "is"
					if (bin.getArguments().size() == 1) {
						if (bin.isCreatedFromInterval() || binOnRight) {
							bin.addArgument(0, assignedNode);
						}
						else {
							bin.addArgument(assignedNode);
						}
						return bin;
					}
				}
			}
			// We're describing a thing with a graph pattern.
			Set<VariableNode> vars = pattern instanceof TripleElement ? getSelectVariables(((TripleElement)pattern)) : null; 
			if (vars != null && vars.size() == 1) {
				// Find where the unbound variable occurred in the pattern
				// and replace each place with the assigned node.
				VariableNode var = vars.iterator().next();
				GraphPatternElement gpe = ((TripleElement)pattern);
				while (gpe instanceof TripleElement) {
					TripleElement triple = (TripleElement) gpe;
					if (var.equals(triple.getSubject())) {
						triple.setSubject(assignedNode);
					}
					if (var.equals(triple.getObject())) {
						triple.setObject(assignedNode);
					}
					gpe = gpe.getNext();
				}
				return pattern;
			}
		}
		// if we get to here we want to actually create a BuiltinElement for the BinaryOpExpression
		// However, if the type is equal ("is", "equal") and the left side is a VariableNode and the right side is a literal
		//	and the VariableNode hasn't already been bound, change from type equal to type assign.
		if (optype == BuiltinType.Equal && target instanceof Rule && lobj instanceof VariableNode && robj instanceof Literal && 
				!variableIsBound((Rule)target, null, (VariableNode)lobj)) {
			return createBinaryBuiltin(expr, "assign", robj, lobj);
		}
		return createBinaryBuiltin(expr, op, lobj, robj);
	}
	
	/**
	 * Returns the bottom triple whose subject was replaced.
	 * @param pattern
	 * @param proxyFor
	 * @param assignedNode
	 * @return
	 */
	private TripleElement assignNullSubjectInProxies(TripleElement pattern,
			TripleElement proxyFor, Node assignedNode) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
//				((ProxyNode)pattern.getSubject()).setReplacementNode(assignedNode);
				if (((TripleElement)proxy).getSubject() == null) {
					// this is the bottom of the recursion
					((TripleElement)proxy).setSubject(assignedNode);
					return (TripleElement) proxy;
				}
				else {
					// recurse down
					TripleElement bottom = assignNullSubjectInProxies(((TripleElement)proxy), proxyFor, assignedNode);
					// make the proxy next and reassign this subject as assignedNode
					((ProxyNode)((TripleElement)proxy).getSubject()).setReplacementNode(assignedNode);
					((TripleElement)proxy).setSubject(assignedNode);
					if (bottom.getNext() == null) {
						bottom.setNext(pattern);
					}
					return bottom;
				}
			}
		}
		return null;
	}

	private TripleElement getProxyWithNullSubject(TripleElement pattern) {
		if (pattern.getSubject() instanceof ProxyNode) {
			Object proxy = ((ProxyNode)pattern.getSubject()).getProxyFor();
			if (proxy instanceof TripleElement) {
				if (((TripleElement)proxy).getSubject() == null) {
					return (TripleElement)proxy;
				}
				else {
					return getProxyWithNullSubject(((TripleElement)proxy));
				}
			}
		}
		return null;
	}

	private boolean isComparisonViaBuiltin(Object robj, Object lobj) {
		if (robj instanceof TripleElement && lobj instanceof Node &&
				((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (isComparisonBuiltin(be.getFuncName()) && be.getArguments().size() == 1) {
				return true;
			}
		}
		return false;
	}

	private boolean isModifiedTripleViaBuitin(Object robj) {
		if (robj instanceof TripleElement && ((TripleElement)robj).getNext() instanceof BuiltinElement) {
			BuiltinElement be = (BuiltinElement) ((TripleElement)robj).getNext();
			if (((TripleElement)robj).getPredicate() instanceof RDFTypeNode) {
				if (isModifiedTriple(be.getFuncType())) {
					Node subj = ((TripleElement)robj).getSubject();
					Node arg = (be.getArguments() != null && be.getArguments().size() > 0) ? be.getArguments().get(0) : null;
					if (subj == null && arg == null) {
						return true;
					}
					if (subj != null && arg != null && subj.equals(arg)) {
						return true;
					}
				}
			}
			else {
				if (isModifiedTriple(be.getFuncType()) && ((TripleElement)robj).getObject().equals(be.getArguments().get(0))) {
					return true;
				}
			}
		}
		return false;
	}

	private boolean hasCommonVariableSubject(Object robj) {
		if (robj instanceof TripleElement && 
				(((TripleElement)robj).getSubject() instanceof VariableNode && 
						(((TripleElement)robj).getSourceType().equals(TripleSourceType.SPV)) ||
						((TripleElement)robj).getSourceType().equals(TripleSourceType.ITC))) {
			VariableNode subjvar = (VariableNode) ((TripleElement)robj).getSubject();
			Object trel = robj;
			while (trel != null && trel instanceof TripleElement) {
				if (!(trel instanceof TripleElement) || 
						(((TripleElement)trel).getSubject() != null &&!(((TripleElement)trel).getSubject().equals(subjvar)))) {
					return false;
				}
				trel = ((TripleElement)trel).getNext();
			}
			if (trel == null) {
				return true;
			}
		}
		return false;
	}

	public static boolean isModifiedTriple(BuiltinType type) {
		if (type.equals(BuiltinType.Not) || type.equals(BuiltinType.NotEqual) || type.equals(BuiltinType.Only)||  type.equals(BuiltinType.NotOnly)) {
			return true;
		}
		return false;
	}
	
	private TripleModifierType getTripleModifierType(BuiltinType btype) {
		if (btype.equals(BuiltinType.Not) || btype.equals(BuiltinType.NotEqual)) {
			return TripleModifierType.Not;
		}
		else if (btype.equals(BuiltinType.Only)) {
			return TripleModifierType.Only;
		}
		else if (btype.equals(BuiltinType.NotOnly)) {
			return TripleModifierType.NotOnly;
		}
		return null;
	}

	/**
	 * Translate a Junction
	 * 
	 * @param expr
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Junction translate(JunctionExpression expr) throws InvalidNameException, InvalidTypeException, TranslationException {
		String op = expr.getOp();
		Expression lexpr = expr.getLeft();
		Expression rexpr = expr.getRight();
		Object lobj = translate(lexpr);
		Object robj = translate(rexpr);
		// If we have a junction with an interval value followed by a value,
		// apply the interval value's op to the right hand value too.
		if (lobj instanceof BuiltinElement && robj instanceof Literal) {
			BuiltinElement lhs = (BuiltinElement) lobj;
			if (lhs.getNext() == null) {
				String intervalOp = lhs.getFuncName();
				robj = createUnaryBuiltin(rexpr, intervalOp, robj);
			}
		}

		return createJunction(expr, op, lobj, robj);
	}
	
	/**
	 * Translate a Unary operator
	 * @param expr
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object translate(UnaryOpExpression expr) throws InvalidNameException, InvalidTypeException, TranslationException {
		String op = expr.getOp();
		Expression sexpr = expr.getExpr();
		Object sobj = translate(sexpr);
		return createUnaryBuiltin(sexpr, op, sobj);
	}
	
	/**
	 * Translate a Function call
	 * @param expr
	 * @param func
	 * @param args
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public GraphPatternElement translate(Expression expr, String func, EList<Expression> args) throws InvalidNameException, InvalidTypeException, TranslationException {
		GraphPatternElement pattern = null;
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(func);
		if (args != null) {
			for (Expression arg : args) {
				Object aobj = translate(arg); 
				builtin.addArgument(nodeCheck(aobj));
				if (aobj instanceof GraphPatternElement) {
					((GraphPatternElement)aobj).setEmbedded(true);
				}
			}
		}
		pattern = addGraphPatternElementAtEnd(pattern, builtin);
		return pattern;
	}
	
	/**
	 * Translate a GraphPatternElement
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public GraphPatternElement translate(GraphPattern gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		GraphPatternElement pattern = null; // our return value

		if (gp instanceof MergedTriples) {
			pattern = translate((MergedTriples)gp);
		}
		else if (gp instanceof PropOfSubj) {
			pattern = translate((PropOfSubj)gp);
		}
		else if (gp instanceof SubjProp) {
			pattern = translate((SubjProp)gp);
		}
		else if (gp instanceof InstAttrPSV) {
			pattern = translate((InstAttrPSV)gp);
		}
		else if (gp instanceof InstAttrSPV) {
			pattern = translate((InstAttrSPV)gp);
		}
		else if (gp instanceof SubTypeOf) {
			pattern = translate((SubTypeOf)gp);
		}

		return pattern;
	}

	/**
	 * Translate a MergedTriples
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public TripleElement translate(MergedTriples gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		TypedBNode pivot = gp.getPivot();
		EList<OfPhrase> ofPhrases = gp.getOps();
		EList<WithChain> withChains = gp.getWcs();

		TripleElement pivotTriple = new TripleElement();
		if (pivot != null) {
			Node pivotNode = conceptIdentifierToNode(pivot.getClassIdentifier());
			if (pivotNode instanceof NamedNode && !(pivotNode instanceof VariableNode) && 
					!((NamedNode)pivotNode).getNodeType().equals(NodeType.ClassNode)) {
				addError(new IFTranslationError("'" + pivotNode.toString() + "' is not a Class.", pivot.getClassIdentifier()));
			}
			pivotTriple.setPredicate(new RDFTypeNode());
			pivotTriple.setObject(pivotNode);
			pivotTriple.setSourceType(TripleSourceType.ITC);
		}
		
		TripleElement returnTriple = translate(ofPhrases, pivotTriple);
		TripleElement withTriples = translate(pivotTriple, withChains);
		// if there are of phrases and/or with phrases, the pivot triple is included in them
		// if there are both append to with to the of
		if (!returnTriple.equals(pivotTriple) && !withTriples.equals(pivotTriple)) {
			addGraphPatternElementAtEnd(returnTriple, withTriples);
		}
		else {
			if (!withTriples.equals(pivotTriple)) {
				returnTriple = withTriples;
			}
		}

		return returnTriple;
	}

	/**
	 * Supporting method--translate the nested triple's of phrases
	 * @param ofPhrases
	 * @param pivotTriple
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected TripleElement translate(EList<OfPhrase> ofPhrases,
			TripleElement pivotTriple) throws InvalidNameException, InvalidTypeException, TranslationException {
		TripleElement returnTriple = pivotTriple;

		int ofPhrasesSize = ofPhrases.size();
		if (ofPhrasesSize > 0) {
			TripleElement ofPhrasesTriple = translate(ofPhrases, ofPhrasesSize -1, nodeCheck(pivotTriple)); 
			return ofPhrasesTriple;
		}

		return returnTriple;
	}

	/**
	 * This method is used recursively to build up the triples with variables starting with the last. The subject passed in
	 * is the subject of this new triple. A new variable will be created for the object, and that new variable will be used,
	 * if needed, by the caller as the subject of the next triple
	 * @param ofPhrases
	 * @param subject
	 * @return
	 * @throws InvalidNameException 
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 */
	protected TripleElement translate(EList<OfPhrase> ofPhrases, int ofPhrasesIndex, Node subject) throws InvalidNameException, InvalidTypeException, TranslationException {
		/* example:
		 *   	age of spouse of friend of x
		 *   -> x friend y, y spouse z, z age ?
		 *   IF:  ((x friend) spouse) age ?
		*/
		OfPhrase phr = ofPhrases.get(ofPhrasesIndex);  // translate only one element of list per call
		Node predNode =  validateNode(new NamedNode(phr.getPropertyName().getName().getName(), NodeType.PropertyNode));
		TripleElement ofPhr = new TripleElement();
		ofPhr.setPredicate(predNode);
		ofPhr.setSubject(nodeCheck(subject));
		ofPhr.setSourceType(TripleSourceType.PSnewV);
		if (getFirstOfPhrase() == null) {		// may need this to determine test variable
			setFirstOfPhrase(ofPhr);
		}
		if (--ofPhrasesIndex >= 0) {
			TripleElement ofPhrasesTriple = translate(ofPhrases, ofPhrasesIndex, new ProxyNode(ofPhr)); 
			return ofPhrasesTriple;
		}
		return ofPhr;
	}

	protected TripleElement translate(TripleElement pivotTriple, EList<WithChain> withChains) throws InvalidNameException, InvalidTypeException, TranslationException {
		TripleElement returnTriple = pivotTriple;

		if (withChains.size() > 0) {
			for (int i = 0; i < withChains.size(); i++) {
				WithChain chain = withChains.get(i);
				EList<WithPhrase> withPhrases = chain.getWps();
				returnTriple = translate(returnTriple, nodeCheck(pivotTriple), withPhrases);
			}
		}

		return returnTriple;
	}

	/**
	 * Translate with phrases of nested triple
	 * @param pivotTriple
	 * @param pivotNodeVariable
	 * @param withPhrases
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	protected TripleElement translate(TripleElement pivotTriple, Node pivotNodeVariable, EList<WithPhrase> withPhrases) throws InvalidNameException, InvalidTypeException, TranslationException {
		TripleElement returnTriple = pivotTriple;

		if (withPhrases.size() > 0) {
			List<WithPhrase> withPhrs = new ArrayList<WithPhrase>(withPhrases); // copy since we might insert phrases
			for (int j = 0; j < withPhrs.size(); j++) {
				WithPhrase phr = withPhrs.get(j);
				TripleElement newTriple = translate(pivotNodeVariable, phr);
				if (newTriple != null) {
					if (returnTriple == pivotTriple) {
						returnTriple = newTriple;
					}
					else {
						addGraphPatternElementAtEnd(returnTriple, newTriple);
					}
				}
			}
		}
		return returnTriple;
	}

	private TripleElement translate(Node pivotTripleNode, WithPhrase phr) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node predNode =  validateNode(new NamedNode(phr.getPropertyName().getName().getName(), NodeType.PropertyNode));
		EObject obj = phr.getValue();
		if (obj == null) {
			return null;
		}
		else {
			TripleElement newTriple = new TripleElement();
			newTriple.setSourceType(TripleSourceType.SPV);
			newTriple.setSubject(nodeCheck(pivotTripleNode));
			newTriple.setPredicate(predNode);
			Object objValue = null;
			if (obj instanceof ExplicitValue) {
				objValue =  translate((ExplicitValue)obj);
			}
			else if (obj instanceof IntervalValue) {
				// We may need several triples to store an interval value.
				objValue = translate((IntervalValue)obj);
			}
			else if (obj instanceof InstanceDeclaration) {
				// We need to translate the embedded instance declaration and use its name as our value.
				objValue = translate((InstanceDeclaration)obj);
			}
			else if (obj instanceof WithPhrase) {
				TripleElement withPhrTriple = translate(nodeCheck(newTriple), (WithPhrase)obj);
				return withPhrTriple;
			}
			else if (obj instanceof Expression) {
				objValue = translate((Expression)obj);
			}
			else if (obj instanceof Node) {
				objValue = obj;
			}
			else if (obj instanceof Junction) {
				objValue = obj;
			}
			else if (obj instanceof GraphPatternElement) {
				objValue = obj;
			}
			else {
				logger.warn("can't translate unexpected with-phrase value: {}", obj);
			}
			if (objValue != null) {
				newTriple.setObject(nodeCheck(objValue));
				return newTriple;
			}
			
		}
		return null;
	}

	/**
	 * Translate an InstanceDeclaration
	 * @param obj
	 * @return
	 * @throws InvalidNameException
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 */
	protected TripleElement translate(InstanceDeclaration obj) throws InvalidNameException, InvalidTypeException, TranslationException {
		ResourceByName className = obj.getClassName();
		ResourceName instanceName = obj.getInstanceName();
		EList<PropValPartialTriple> addlInfoItems = obj.getAddlInfoItems();
		TypeDeclaration typeDecl = obj.getTypeDecl();
		
		TripleElement pivotTriple = new TripleElement();
		pivotTriple.setSourceType(TripleSourceType.ITC);
		Node subjNode = null;
		if (className != null) {
			Node classNode =  conceptIdentifierToNode(className);
			if (classNode instanceof NamedNode && !((NamedNode)classNode).getNodeType().equals(NodeType.ClassNode)) {
				addError(new IFTranslationError("'" + classNode.toString() + "' is not a Class.", className));
			}
			pivotTriple.setPredicate(new RDFTypeNode());
			pivotTriple.setObject(classNode);
		}
		if (instanceName != null) {
			subjNode =  validateNode(new NamedNode(instanceName.getName()));
			pivotTriple.setSubject(subjNode);
		}
		if (typeDecl != null) {
			ResourceName instName =  typeDecl.getInstName();
			TypedBNode type = typeDecl.getType();

			Node classNode =  conceptIdentifierToNode(type.getClassIdentifier());
			subjNode = validateNode(new NamedNode(instName.getName()));
			pivotTriple.setSubject(subjNode);
			pivotTriple.setPredicate(new RDFTypeNode());
			pivotTriple.setObject(classNode);
		}
//		if (subjNode == null) {
//			subjNode = getVariableNode(null, pivotTriple.getPredicate(), pivotTriple.getObject()); 
//			pivotTriple.setSubject(subjNode);
//		}
		if (addlInfoItems != null) {
			Node pivotNode = nodeCheck(pivotTriple);
			for (PropValPartialTriple propVal : addlInfoItems) {
				ResourceByName propertyName = propVal.getPropertyName();
				ExplicitValue objectValue = propVal.getObjectValue();
				InstanceDeclaration instanceDecl = propVal.getObjectValueBNode();
				
				Node predNode =  conceptIdentifierToNode(propertyName);
				if (objectValue != null) {
					Node objNode =  translate(objectValue);
					TripleElement addlTriple = addGraphPatternElementAtEnd(pivotTriple, pivotNode, predNode, objNode, TripleSourceType.SPV);
					pivotTriple = addlTriple;
//					addGraphPatternElementAtEnd(pivotTriple, addlTriple);
				}
				if (instanceDecl != null) {
					TripleElement instanceTriple = translate(instanceDecl);
					Node objNode =  validateNode(instanceTriple.getSubject());
					addGraphPatternElementAtEnd(pivotTriple, instanceTriple);
					TripleElement instTriple = addGraphPatternElementAtEnd(pivotTriple, pivotNode, predNode, objNode, TripleSourceType.SPV);
//					addGraphPatternElementAtEnd(pivotTriple, instanceTriple);
					pivotTriple = instTriple;
				}
			}
		}

		return pivotTriple;
	}

	/**
	 * Translate PropOfSubj pattern
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 */
	public TripleElement translate(PropOfSubj gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		EList<OfPhrase> ofPhrases = gp.getOfPhr();
		ResourceByName subject = gp.getSubj();

		TripleElement returnTriple = null;
		Node subjNode =  conceptIdentifierToNode(subject);
		int ofPhrasesSize = ofPhrases.size();
		if (ofPhrasesSize > 0) {
			returnTriple = translate(ofPhrases, ofPhrasesSize -1, subjNode);
			returnTriple.setSourceType(TripleSourceType.PSV);
		}
		else {
			Node predNode = new RDFTypeNode();
			Node variable = getVariableNode(null, predNode, subjNode);
			returnTriple = new TripleElement();
			returnTriple.setSubject(variable);
			returnTriple.setPredicate(predNode);
			returnTriple.setObject(subjNode);
			if (subjNode instanceof NamedNode && !((NamedNode)subjNode).getNodeType().equals(NodeType.ClassNode)) {
				addError(new IFTranslationError("'" + subjNode.toString() + "' is not a Class.", subject.getName()));
			}
			returnTriple.setSourceType(TripleSourceType.ITC);
		}

		return returnTriple;
	}

	/**
	 * Translate SubjProp pattern
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public TripleElement translate(SubjProp gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		ResourceByName subject = gp.getSubj();
		EList<WithPhrase> withPhrases = gp.getHwPhr();

		Node subjNode =  conceptIdentifierToNode(subject);
		TripleElement returnTriple = new TripleElement();
		returnTriple.setSubject(subjNode);
		returnTriple = translate(returnTriple, subjNode, withPhrases);
		returnTriple.setSourceType(TripleSourceType.SPV);
		return returnTriple;
	}

	/**
	 * Translate InstAttrPSV pattern
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws TranslationException 
	 * @throws InvalidTypeException 
	 */
	public TripleElement translate(InstAttrPSV gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		PropOfSubj prop = gp.getProp();
		ExplicitValue value = gp.getVal();

		TripleElement returnTriple = translate(prop);
		returnTriple.setSourceType(TripleSourceType.PSV);
		if (returnTriple != null) {
			ResourceByName subj = prop.getSubj();
			Node subject =  conceptIdentifierToNode(subj);
			Node predicate = returnTriple.getPredicate();
			Node object =  translate(value); 
			addGraphPatternElementAtEnd(returnTriple, subject, predicate, object, TripleSourceType.PSV);
		}

		return returnTriple;
	}
	
	/**
	 * Translate SubTypeOf pattern
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 */
	public GraphPatternElement translate(SubTypeOf gp) throws InvalidNameException {
		ResourceByName sub = gp.getSubclass();
		ResourceByName sup = gp.getSuperclass();
		Node subNode =  validateNode(new NamedNode(sub.getName().getName()));
		Node supNode =  validateNode(new NamedNode(sup.getName().getName()));
		NamedNode rdfsSubClass = new NamedNode("subClassOf");
		rdfsSubClass.setNamespace(RDFS.getURI());
		rdfsSubClass.setNodeType(NodeType.PropertyNode);
		TripleElement pattern = new TripleElement(subNode, rdfsSubClass, supNode);
		pattern.setSourceType(TripleSourceType.SCofC);
		return pattern;
	}

	/**
	 * Translate InstAttrSPV pattern
	 * 
	 * @param gp
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public GraphPatternElement translate(InstAttrSPV gp) throws InvalidNameException, InvalidTypeException, TranslationException {
		ResourceByName subj = gp.getSubj();
		EList<ResourceByName> props = gp.getProps();
		EList<Expression> vals = gp.getVals();

		GraphPatternElement pattern = null;
		Node subjNode =  validateNode(new NamedNode(subj.getName().getName()));
		if (props.size() != vals.size()) {
			addError(new IFTranslationError("'" + subjNode + "' does not have the same number of properties and values.", subj));
		}
		else {
			for (int i = 0; i < props.size(); i++) {
				ResourceByName prop = props.get(i);
				EObject val = vals.get(i);
				Node propNode =  validateNode(new NamedNode(prop.getName().getName(), NodeType.PropertyNode));
				if (val instanceof Expression && !(val instanceof ExplicitValue) && !(val instanceof InstanceDeclaration) && 
						!(val instanceof UnaryOpExpression)) {
					val = getExpressionPart((Expression) val);
				}
				if (val instanceof ExplicitValue) {
					Node valNode =  translate((ExplicitValue)val);
					pattern = addGraphPatternElementAtEnd(pattern, subjNode, propNode, valNode, TripleSourceType.SPV);
				}
				else if (val instanceof InstanceDeclaration) {
					TripleElement newTriple = translate((InstanceDeclaration)val);
					Node valNode =  validateNode(newTriple.getSubject());
					pattern = addGraphPatternElementAtEnd(pattern, subjNode, propNode, valNode, TripleSourceType.SPV);
					pattern = addGraphPatternElementAtEnd(pattern, newTriple);
				}
				else if (val instanceof UnaryOpExpression) {
					String opstr = ((UnaryOpExpression)val).getOp();
					BuiltinType optype = BuiltinType.getType(opstr);
					Expression expr = ((UnaryOpExpression)val).getExpr();
					if (expr == null) {
						logger.warn("Unary operator doesn't have an expression {} in translate(InstAttrSPV)", val);
						addError(new IFTranslationError("Unary operator doesn't have an expression", val));						
					}
					else {
						Object valObj = translate(expr);
						pattern = addGraphPatternElementAtEnd(pattern, subjNode, propNode, nodeCheck(valObj), TripleSourceType.SPV);
						GraphPatternElement lastgpe = getLastGraphPatternElement(pattern);
						if (lastgpe instanceof TripleElement) {
							((TripleElement) lastgpe).setType(getTripleModifierType(optype));
						}
					}
				}
				else if (val instanceof BinaryOpExpression) {
					Object boptrans = translate((BinaryOpExpression)val);
					if (boptrans instanceof BuiltinElement) {
						Node newVar = nodeCheck(boptrans);
						pattern = addGraphPatternElementAtEnd(pattern, subjNode, propNode, newVar, TripleSourceType.SPV);
					}
				}
				else {
					if (val instanceof Expression) {
						Object valtran = translate((Expression) val);
						logger.warn("Unexpected type of value {} in translate(InstAttrSPV)", valtran);
						addError(new IFTranslationError("Value isn't of expected type", valtran));						
					}
					else {
						logger.warn("Unexpected type of value {} in translate(InstAttrSPV)", val);
						addError(new IFTranslationError("Value isn't of expected type", val));
					}
				}
			}
		}
		return pattern;
	}

	/**
	 * Get the Expression which is a part of the argument Expression
	 * 
	 * @param expr
	 * @return
	 */
	public static EObject getExpressionPart(Expression expr) {
		Expression sexpr = expr.getExpr();
		if (sexpr != null) {
			return getExpressionPart(sexpr);
		}
		GraphPattern gp = expr.getGp();
		if (gp != null) {
			return gp;
		}
		IntervalValue ivalue = expr.getIvalue();
		if (ivalue != null) {
			return ivalue;
		}
		ExplicitValue value = expr.getValue();
		if (value != null) {
			return value;
		}
		ValueTable valueTable = expr.getValueTable();
		if (valueTable != null) {
			return valueTable;
		}
		return expr;
	}

	/**
	 * Translate an ExplicitValue
	 * 
	 * @param value
	 * @return
	 * @throws InvalidNameException
	 */
	public Node translate(ExplicitValue value) throws InvalidNameException {
		if (value.getInstName() != null) {
			ResourceByName namedValue = value.getInstName();
			NamedNode namedNode = new NamedNode();
			namedNode.setName(namedValue.getName().getName());
			return  validateNode(namedNode);
		}
		else if (value.getLitValue() != null) {
			Literal litValue = new Literal();
			litValue.setValue(SadlModelManager.literalValueToObject(value.getLitValue()));
			return litValue;
		}
		else {
			String term = value.getTerm();
			if (term.equals("PI")) {
				Literal litValue = new Literal();
				litValue.setValue(new Double(Math.PI));
				return litValue;
			}
			else if (term.equals("known")) {
				return new KnownNode();
			}
			else {
				logger.error("Value is an unknown term: {}", term);
				addError(new IFTranslationError("Value is an unknown term: {}", term));
				Literal litValue = new Literal();
				litValue.setValue(term);
				return litValue;
			}
		}
	}

	/**
	 * Translate an IntervalValue
	 * 
	 * @param value
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object translate(IntervalValue value) throws InvalidNameException, InvalidTypeException, TranslationException {
		String op = value.getOp();
		Expression sexpr = value.getExpr();
		Object sobj = translate(sexpr);
		Object ubin = createUnaryBuiltin(sexpr, op, sobj);
		if (ubin instanceof BuiltinElement) {
			(( BuiltinElement)ubin).setCreatedFromInterval(true);
		}
		return ubin;
	}

	public ValueTableNode translate(VariableList varList) throws InvalidNameException {
		EList<ResourceName> rnames = varList.getNames();
		List<String> names = new ArrayList<String>();
		for (int i = 0; i < rnames.size(); i++) {
			names.add(rnames.get(i).getName());
		}
		List<List<Node>> rows = new ArrayList<List<Node>>(1);
		List<Node> row = new ArrayList<Node>(names.size());

		for (String name : names) {
			NamedNode namedNode = new NamedNode();
			namedNode.setName(name);
			row.add( validateNode(namedNode));
		}
		rows.add(row);

		ValueTableNode valueTableNode = new ValueTableNode();
		valueTableNode.setRows(rows);
		return valueTableNode;
	}

	public ValueTableNode translate(ValueTable valueTable) throws InvalidNameException {
		ValueRow singleRow = valueTable.getRow();
		EList<ValueRow> valueRows = valueTable.getRows();
		
		List<List<Node>> rows = new ArrayList<List<Node>>(valueRows != null ? valueRows.size() : 1);
		if (singleRow != null) {
			List<Node> row = translate(singleRow);
			rows.add(row);
		}
		if (valueRows != null) {
			for (ValueRow valueRow : valueRows) {
				List<Node> row = translate(valueRow);
				rows.add(row);
			}
		}

		ValueTableNode valueTableNode = new ValueTableNode();
		valueTableNode.setRows(rows);
		return valueTableNode;
	}

	private List<Node> translate(ValueRow valueRow) throws InvalidNameException {
		EList<ExplicitValue> explicitValues = valueRow.getExplicitValues();
		List<Node> row = new ArrayList<Node>(explicitValues.size());
		for (ExplicitValue explicitValue : explicitValues) {
			Node value = translate(explicitValue);
			row.add(value);
		}
		return row;
	}
	
	public Node conceptIdentifierToNode(ResourceIdentifier classId) throws InvalidNameException {
		if (classId instanceof ResourceByName) {
			if (((ResourceByName)classId).getName() != null && ((ResourceByName)classId).getName().getName() != null) {
				NamedNode node = new NamedNode(((ResourceByName)classId).getName().getName());
				return  validateNode(node);
			}
			else {
				throw new InvalidNameException("conceptIdentifierToNode called with a ResourceByName with null name.");
			}
		}
		else if (classId != null) {	// ok if it's null when editing
			throw new InvalidNameException("conceptIdentifierToNode called with unhandled ResourceIdentifierType");
		}
		return null;
	}
	
	/**
	 * This method fills in missing information in a NamedNode: 
	 * the prefix, the namespace, the type
	 * 
	 * @param namedNode
	 * @return
	 * @throws InvalidNameException 
	 */
	protected Node validateNode(Node node) throws InvalidNameException {
		if (node instanceof NamedNode) {
			if (!((NamedNode)node).isValidated()) {
				if (node instanceof VariableNode) {
					((VariableNode) node).setNodeType(NodeType.VariableNode);
					userDefinedVariables.add(((NamedNode) node).getName());
				}
				else if (node instanceof RDFTypeNode) {
					((RDFTypeNode) node).setNodeType(NodeType.PropertyNode);
				}
				else {
					ConceptName cname;
					ConceptType ctype = null;
					String name = ((NamedNode)node).toString(); //getName();
					if (name == null) {
						throw new InvalidNameException("A NamedNode has a null name! Did ResourceByName resolution fail?");
					}
				    int colon = name.indexOf(':');
					if (colon > 0 && colon < name.length() - 1) {
						String pfx = name.substring(0, colon);
				        ((NamedNode)node).setPrefix(pfx);
				        String lname = name.substring(colon + 1);
				        ((NamedNode)node).setName(lname);
				        cname = modelManager.validateConceptName(new ConceptName(pfx, lname));
				    }
				    else {
				    	cname = modelManager.validateConceptName(new ConceptName(name));
				    }
			        ctype = cname.getType();
			        ((NamedNode)node).setNamespace(cname.getNamespace());
			        ((NamedNode)node).setPrefix(cname.getPrefix());
			    	if (ctype.equals(ConceptType.CONCEPT_NOT_FOUND_IN_MODEL)) {
			    		modelManager.addToVariableNamesCache(cname);
			    		node = new VariableNode(((NamedNode)node).getName());
			    		userDefinedVariables.add(((NamedNode) node).getName());
			    	}
			    	else if (ctype.equals(ConceptType.ANNOTATIONPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.DATATYPEPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.OBJECTPROPERTY)){
			    		((NamedNode)node).setNodeType(NodeType.PropertyNode);
			    	}
			    	else if (ctype.equals(ConceptType.ONTCLASS)){
			    		((NamedNode)node).setNodeType(NodeType.ClassNode);
			    	}
			    	else if (ctype.equals(ConceptType.INDIVIDUAL)){
			    		((NamedNode)node).setNodeType(NodeType.InstanceNode);
			    	}
			    	else {
			    		logger.error("Unexpected ConceptType: " + ctype.toString());
				    	addError(new IFTranslationError("Unexpected ConceptType: " + ctype.toString()));
			    	}
			    	if (isCollectNamedNodes()) {
			    		if (namedNodes == null) {
			    			namedNodes = new ArrayList<ConceptName>();
			    		}
			    		if (!namedNodes.contains(cname)) {
			    			namedNodes.add(cname);
			    		}
			    	}
				}
				((NamedNode)node).setValidated(true);
			}
		}
		return node;
	}
	
	private void addError(IFTranslationError error) {
		if (errors == null) {
			errors = new ArrayList<IFTranslationError>();
		}
		errors.add(error);
	}

	public List<IFTranslationError> getErrors() {
		return errors;
	}
	
	private GraphPatternElement createBinaryBuiltin(Expression expr, String name, Object lobj, Object robj) throws InvalidNameException, InvalidTypeException, TranslationException {
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (lobj != null) {
			builtin.addArgument(nodeCheck(lobj));
		}
		if (robj != null) {
			builtin.addArgument(nodeCheck(robj));
		}
		return builtin;
	}
	
	private Junction createJunction(Expression expr, String name, Object lobj, Object robj) {
		Junction junction = new Junction();
		junction.setJunctionName(name);
		junction.setLhs(lobj);
		junction.setRhs(robj);
		return junction;
	}

	private Object createUnaryBuiltin(Expression sexpr, String name, Object sobj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (sobj instanceof Literal && BuiltinType.getType(name).equals(BuiltinType.Minus)) {
			Object theVal = ((Literal)sobj).getValue();
			if (theVal instanceof Integer) {
				theVal = ((Integer)theVal) * -1;
			}
			else if (theVal instanceof Long) {
				theVal = ((Long)theVal) * -1;
			}
			else if (theVal instanceof Float) {
				theVal = ((Float)theVal) * -1;
			}
			else if (theVal instanceof Double) {
				theVal = ((Double)theVal) * -1;
			}
			((Literal)sobj).setValue(theVal);
			return sobj;
		}
		if (sobj instanceof Junction) {
			// If the junction has two literal values, apply the op to both of them.
			Junction junc = (Junction) sobj;
			Object lhs = junc.getLhs();
			Object rhs = junc.getRhs();
			if (lhs instanceof Literal && rhs instanceof Literal) {
				lhs = createUnaryBuiltin(sexpr, name, lhs);
				rhs = createUnaryBuiltin(sexpr, name, rhs);
				junc.setLhs(lhs);
				junc.setRhs(rhs);
			}
			return junc;
		}
		if (BuiltinType.getType(name).equals(BuiltinType.Equal)) {
			if (sobj instanceof BuiltinElement) {
				if (isComparisonBuiltin(((BuiltinElement)sobj).getFuncName())) {
					// this is a "is <comparison>"--translates to <comparsion> (ignore is)
					return sobj;
				}
			}
			else if (sobj instanceof Literal || sobj instanceof NamedNode) {
				// an "=" interval value of a value is just the value
				return sobj;
			}
		}
		BuiltinElement builtin = new BuiltinElement();
		builtin.setFuncName(name);
		if (isModifiedTriple(builtin.getFuncType())) {
			if (sobj instanceof TripleElement) {
				((TripleElement)sobj).setType(getTripleModifierType(builtin.getFuncType()));
				return sobj;
			}
		}
		if (sobj != null) {
			builtin.addArgument(nodeCheck(sobj));
		}
		return builtin;
	}

	private TripleElement addGraphPatternElementAtEnd(GraphPatternElement head, Node subject, Node predicate, Node object, TripleSourceType sourceType) {
		TripleElement newTriple = new TripleElement();
		newTriple.setSubject(subject);
		newTriple.setPredicate(predicate);
		newTriple.setObject(object);
		newTriple.setSourceType(sourceType);
		return newTriple;
	}
	
	private GraphPatternElement addGraphPatternElementAtEnd(GraphPatternElement head, GraphPatternElement newTail) {
		if (head != null) {
			GraphPatternElement lastElement = getLastGraphPatternElement(head);
			lastElement.setNext(newTail);
		}
		else {
			head = newTail;
		}
		return head;
	}
	
	private GraphPatternElement getLastGraphPatternElement(GraphPatternElement pattern) {
		while (pattern.getNext() != null) {
			pattern = pattern.getNext();
		}
		return pattern;
	}
	
	private Node nodeCheck(Object nodeObj) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (nodeObj == null) {
//			throw new InvalidTypeException("nodeCheck called with null argument; this should not happen.");
			return null;
		}
		if (nodeObj instanceof Node) {
			return (Node) nodeObj; 
		}
		else if (nodeObj instanceof TripleElement) {
			if (((TripleElement)nodeObj).getPredicate() == null 
					&& ((TripleElement)nodeObj).getObject() == null
					&& ((TripleElement)nodeObj).getSubject() != null) {
				return ((TripleElement)nodeObj).getSubject();
			}
		}
		return new ProxyNode(nodeObj);
	}

	/**
	 * Method to find all of the variables in a graph pattern that might be the implied select variables of a query
	 * @param pattern
	 * @return
	 */
	public Set<VariableNode> getSelectVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = getUnboundVariables(patterns);

		// If we don't find an unreferenced variable, see if the pattern defines
		// a typed b node and get its variable.
		if (vars.isEmpty()) {
			for (int i = 0; i < patterns.size(); i++) {
				GraphPatternElement pattern = patterns.get(i);
				Set<VariableNode> moreVars = getSelectVariables(pattern);
				if (moreVars != null && moreVars.size() > 0) {
					vars.addAll(moreVars);
				}
			}
		}
		return vars;
	}
	
	public Set<VariableNode> getSelectVariables(GraphPatternElement pattern) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();
		if (pattern instanceof TripleElement) {
			TripleElement triple = (TripleElement) pattern;
			if (triple.getSubject() instanceof VariableNode &&
					triple.getPredicate() instanceof RDFTypeNode) {
				VariableNode var = (VariableNode) triple.getSubject();
				vars.add(var);
			}
			else if (triple.getSubject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getSubject()));
			}
			else if (triple.getObject() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getObject()));
			}
			else if (triple.getPredicate() instanceof VariableNode) {
				vars.add(((VariableNode)triple.getPredicate()));
			}
		}
		else if (pattern instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)pattern).getArguments();
			if (args != null) {
				// right now we have no mechanism to know which variables are unbound so
				//	assume the last one is
				// TODO
				Node arg = args.get(args.size() - 1);
				if (arg instanceof VariableNode) {
					vars.add((VariableNode) arg);
				}
			}
		}
		else if (pattern instanceof Junction) {
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			if (lhs instanceof GraphPatternElement) {
				Set<VariableNode> lhsvars = getSelectVariables((GraphPatternElement) lhs);
				if (lhsvars != null) {
					vars.addAll(lhsvars);
				}
			}
			if (rhs instanceof GraphPatternElement) {
				Set<VariableNode> rhsvars = getSelectVariables((GraphPatternElement) rhs);
				if (rhsvars != null) {
					vars.addAll(rhsvars);
				}
			}
		}
		return vars;
	}

	private Set<VariableNode> getUnboundVariables(List<GraphPatternElement> patterns) {
		Set<VariableNode> vars = new LinkedHashSet<VariableNode>();

		// We need to find any unreferenced variables in the pattern.
		for (int i = 0; i < patterns.size(); i++) {
			GraphPatternElement gpe = patterns.get(i);
			if (gpe instanceof TripleElement) {
				// Check the object of each triple to see if it has a variable
				// node with zero references.
				TripleElement triple = (TripleElement) gpe;
				Node subjNode = triple.getSubject();
				if (subjNode instanceof VariableNode) {
					VariableNode var = (VariableNode) subjNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (subjNode instanceof NamedNode && ((NamedNode)subjNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)subjNode).getName()));
				}
				Node objNode = triple.getObject();
				if (objNode instanceof VariableNode) {
					VariableNode var = (VariableNode) objNode;
					if (var.getNumReferences() == 0) {
						vars.add(var);
					}
				}
				else if (objNode instanceof NamedNode && ((NamedNode)objNode).getNodeType().equals(NodeType.VariableNode)) {
					vars.add(new VariableNode(((NamedNode)objNode).getName()));
				}
			}
			else if (gpe instanceof BuiltinElement) {
				// Check the arguments of each builtin to see if it has a 
				// variable node with zero references.
				BuiltinElement builtin = (BuiltinElement) gpe;
				for (Node argument : builtin.getArguments()) {
					if (argument instanceof VariableNode) {
						VariableNode var = (VariableNode) argument;
						if (var.getNumReferences() == 0) {
							vars.add(var);
						}
					}
				}
			}
		}

		return vars; 
	}

	/**
	 * This method flattens out GraphPatternElement linked lists into a regular List
	 * @param test
	 * @param object 
	 */
	public void postProcessTest(Test test, com.ge.research.sadl.sadl.Test object) {
		Object lhs = test.getLhs();
		if (lhs instanceof List<?> && ((List<?>)lhs).size() > 0) {
			if (((List<?>)lhs).get(0) instanceof GraphPatternElement) {
				flattenLinkedList((List<GraphPatternElement>)lhs);
			}
			if (lhs instanceof List<?>) {
				if (((List<?>)lhs).size() == 1) {
					lhs = ((List<?>)lhs).get(0);
					test.setLhs(lhs);
				}
				else if (((List<?>)lhs).size() == 2 && ((List<?>)lhs).get(1) instanceof BuiltinElement &&
						((BuiltinElement)((List<?>)lhs).get(1)).isCreatedFromInterval()) {
					test.setLhs(((List<?>)lhs).get(0));
					test.setCompName(((BuiltinElement)((List<?>)lhs).get(1)).getFuncType());
					test.setRhs(((BuiltinElement)((List<?>)lhs).get(1)).getArguments().get(1));
				}
			}
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			boolean done = false;
			if ((((GraphPatternElement)lhs).getNext() instanceof  BuiltinElement)) {
				// there is a builtin next
				BuiltinElement be = (BuiltinElement) ((GraphPatternElement)lhs).getNext();
				if (isComparisonBuiltin(be.getFuncName())) {
					((GraphPatternElement)lhs).setNext(null);
					if (be.getArguments().size() > 1) {
						if (be.getArguments().get(0) instanceof VariableNode) {
							test.setRhs(be.getArguments().get(1));
						}
						else {
							// this is of the form V is P of S so comparison must be reversed
							reverseBuiltinComparisonDirection(be);
							test.setRhs(be.getArguments().get(0));
						}
					}
					else {
						addError(new IFTranslationError("A BuiltinElement in a Test is a comparison (" + be.getFuncName() + ") but has less than two arguemnts (" + be.toString() + ")"));
					}
					test.setCompName(be.getFuncName());
					done = true;
				}
			}
			if (!done) {
				List<GraphPatternElement> newLhs = new ArrayList<GraphPatternElement>();
				newLhs.add((GraphPatternElement) lhs);
				test.setLhs(flattenLinkedList(newLhs));
			}
		}
		else if (lhs instanceof BuiltinElement && isModifiedTriple(((BuiltinElement)lhs).getFuncType())) {
			List<Node> args = ((BuiltinElement)lhs).getArguments();
			if (args != null && args.size() == 2) {
				test.setLhs(args.get(1));
				test.setRhs(args.get(0));
				test.setCompName(((BuiltinElement)lhs).getFuncName());
			}
		}
		if (test.getRhs() instanceof ProxyNode) {
			test.setRhs(((ProxyNode)test.getRhs()).getProxyFor());
		}
		Object rhs = test.getRhs();
		if (rhs instanceof List<?> && ((List<?>)rhs).size() > 0) {
			if (((List<?>)rhs).get(0) instanceof GraphPatternElement) {
				flattenLinkedList((List<GraphPatternElement>)rhs);
			}
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			boolean done = false;
			if ((((GraphPatternElement)rhs).getNext() instanceof BuiltinElement)) {
				BuiltinElement be = (BuiltinElement) ((GraphPatternElement)rhs).getNext();
				if (isComparisonBuiltin(be.getFuncName())) {
					((GraphPatternElement)rhs).setNext(null);
					test.setLhs(be.getArguments().get(1));
					test.setCompName(be.getFuncName());
					done = true;
				}
			}
			if (!done) {
				List<GraphPatternElement> newRhs = new ArrayList<GraphPatternElement>();
				newRhs.add((GraphPatternElement) rhs);
				test.setRhs(flattenLinkedList(newRhs));
			}
		}

		if (test.getLhs() instanceof ProxyNode) {
			test.setLhs(((ProxyNode)test.getLhs()).getProxyFor());
		}
		if (test.getCompType() != null && test.getCompType().equals(ComparisonType.Eq) 
				&& test.getLhs() != null && test.getRhs() != null 
				&& test.getLhs() instanceof NamedNode && test.getRhs() instanceof List<?>) {
			if (test.getRhsVariables() != null && test.getRhsVariables().size() == 1) {
				String rhsvar = test.getRhsVariables().get(0);
				List<?> rhslist = (List<?>) test.getRhs();
				boolean allPass = true;
				for (int i = 0; i < rhslist.size(); i++) {
					Object anrhs = rhslist.get(i);
					if (!(anrhs instanceof TripleElement)) {
						allPass = false;
						break;
					}
					else {
						Node subj = ((TripleElement)anrhs).getSubject();
						if (!(subj instanceof VariableNode) || !(((VariableNode)subj).getName().equals(rhsvar))) {
							allPass = false;
							break;
						}
					}
				}
				if (allPass) {
					for (int i = 0; i < rhslist.size(); i++) {
						TripleElement triple = (TripleElement) rhslist.get(i);
						triple.setSubject((Node) test.getLhs());
					}
					test.setLhs(test.getRhs());
					test.setRhs(null);
					test.setRhsVariables(null);
					test.setCompName((String)null);
				}
			}
		}
		
		// this is a validity checking section
		TripleElement singleTriple = null;
		if (test.getLhs() instanceof TripleElement && test.getRhs() == null && ((TripleElement)test.getLhs()).getNext() == null) {
			singleTriple = (TripleElement) test.getLhs();
		}
		else if (test.getRhs() instanceof TripleElement && test.getLhs() == null && ((TripleElement)test.getRhs()).getNext() == null) {
			singleTriple = (TripleElement) test.getRhs();
		}
		if (singleTriple != null) {
			// a single triple test should not have any variables in it
			if (singleTriple.getSubject() instanceof VariableNode || 
					singleTriple.getPredicate() instanceof VariableNode ||
					singleTriple.getObject() instanceof VariableNode) {
				addError(new IFTranslationError("Test is a single triple to be matched; should not contain variables.", object));
			}
			else {
				try {
					modelManager.validateStatement(singleTriple.getSubject(), singleTriple.getPredicate(), singleTriple.getObject());
				}
				catch (Throwable t) {
					// try to validate but don't do anything on Exception
				}
			}
		}
	}

	public static void reverseBuiltinComparisonDirection(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<=");
		}
	}

	public static void builtinComparisonComplement(BuiltinElement be) {
		if (be.getFuncType().equals(BuiltinType.LT)) {
			be.setFuncName(">=");
		}
		else if (be.getFuncType().equals(BuiltinType.LTE)) {
			be.setFuncName(">");
		}
		else if (be.getFuncType().equals(BuiltinType.GT)){
			be.setFuncName("<=");
		}
		else if (be.getFuncType().equals(BuiltinType.GTE)) {
			be.setFuncName("<");
		}
	}

	public static boolean isComparisonBuiltin(String builtinName) {
		ComparisonType[] types = ComparisonType.values();
		for (ComparisonType type : types) {
			if (type.matches(builtinName)) {
				return true;
			}
		}
		return false;
	}

	public Rule postProcessRule(Rule rule, EObject object) {
		// convert givens linked list to array; expand conjunctions
		List<GraphPatternElement> givens = rule.getGivens();
		if (givens != null) {
			Object results;
			try {
				results = expandProxyNodes(givens, false, true);
				if (results instanceof List<?>) {
					rule.setGivens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		// convert ifs linked list to array; expand conjunctions
		List<GraphPatternElement> ifs = rule.getIfs();
		if (ifs != null) {
			Object results;
			try {
				results = expandProxyNodes(ifs, false, false);
				if (results instanceof List<?>) {
					rule.setIfs((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
		// now process conclusions
		List<GraphPatternElement> thens = rule.getThens();
		if (thens != null) {
			Object results;
			try {
				results = expandProxyNodes(thens, true, false);
				if (results instanceof List<?>) {
					for (int i = 0; i < ((List<?>)results).size(); i++) {
						GraphPatternElement tgpe = (GraphPatternElement) ((List<?>)results).get(i);
						results = moveEmbeddedGPEsToIfs(rule, (List<?>) results, tgpe);
					}
					rule.setThens((List<GraphPatternElement>) results);
				}
			} catch (InvalidNameException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InvalidTypeException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (TranslationException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 		
		}
		removeDuplicateElements(rule);
		return rule;
	}

	/**
	 * Method to remove GPE's with isEmbedded true from thens to ifs
	 * 
	 * @param rule
	 * @param results
	 * @param tgpe
	 * @return
	 */
	private List<?> moveEmbeddedGPEsToIfs(Rule rule, List<?> results,
			GraphPatternElement tgpe) {
		if (tgpe.isEmbedded()) {
			results.remove(tgpe);
			rule.getIfs().add(tgpe);			
		}
		else {
			if (tgpe instanceof Junction) {
				int idx = results.indexOf(tgpe);
				GraphPatternElement newtgpe = moveEmbeddedFromJunction(rule, (Junction)tgpe);
				if (newtgpe == null) {
					results.remove(idx);
				}
				else if (newtgpe != tgpe) {
					((List<GraphPatternElement>)results).set(idx, newtgpe);
				}
			}
		}
		return results;
	}

	/**
	 * Method to move all embedded GPEs in a Junction to the rule ifs and return whatever should be put in 
	 * the Junction's place or null if nothing.
	 * 
	 * @param rule
	 * @param tgpe
	 * @return
	 */
	private GraphPatternElement moveEmbeddedFromJunction(Rule rule,
			Junction tgpe) {
		boolean lhsRemoved = false;
		boolean rhsRemoved = false;
		Object lhs = ((Junction)tgpe).getLhs();
		Object rhs = ((Junction)tgpe).getRhs();
		if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) lhs);
			lhsRemoved = true;
		}
		else if (lhs instanceof Junction) {
			lhs = moveEmbeddedFromJunction(rule, (Junction) lhs);
		}
		if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).isEmbedded()) {
			rule.getIfs().add((GraphPatternElement) rhs);
			rhsRemoved = true;
		}
		else if (rhs instanceof Junction) {
			rhs = moveEmbeddedFromJunction(rule, (Junction) rhs);
		}
		if (lhsRemoved && rhsRemoved) {
			return null;
		}
		if (lhsRemoved) {
			return (GraphPatternElement) rhs;
		}
		if (rhsRemoved) {
			return (GraphPatternElement) lhs;
		}
		tgpe.setLhs(lhs);
		tgpe.setRhs(rhs);
		return tgpe;
	}

	/**
	 * This Map keeps track of the ProxyNodes that have been retired by GraphPatternElements, allowing the retired
	 * ProxyNode and its associated variable to be reused when that GraphPatternElement is revisited in another ProxyNode.
	 */
	private Map<GraphPatternElement, ProxyNode> retiredProxyNodes = new HashMap<GraphPatternElement, ProxyNode>();
	
	/**
	 * Top-level method for expanding ProxyNodes
	 * 
	 * @param pattern
	 * @param clearPreviousRetired TODO
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	public Object expandProxyNodes(Object pattern, boolean isRuleThen, boolean clearPreviousRetired) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (clearPreviousRetired) {
			retiredProxyNodes.clear();
		}
		List<GraphPatternElement> patterns = new ArrayList<GraphPatternElement>();
		if (pattern instanceof List<?>) {
			for (int i = 0; i < ((List<?>)pattern).size(); i++) {
				expandProxyNodes(patterns, ((List<?>)pattern).get(i), isRuleThen);
			}
		}
		else {
			Object result = expandProxyNodes(patterns, pattern, isRuleThen);
			if (patterns.size() == 0) {
				return result;
			}
		}
		if (patterns.size() > 1 && !(target instanceof Test)) {
			patterns = listToAnd(patterns);
		}
		return patterns;
	}
	
	private List<GraphPatternElement> listToAnd(
			List<GraphPatternElement> patterns) {
		GraphPatternElement lhs = patterns.remove(0);
		if (lhs instanceof List<?>) {
			lhs = listToAnd((List<GraphPatternElement>) lhs).get(0);
		}
		Junction jand = new Junction();
		jand.setJunctionName("and");
		jand.setLhs(lhs);
		if (patterns.size() > 1) {
			patterns = listToAnd(patterns);
		}
		GraphPatternElement rhs = patterns.get(0);
		if (rhs instanceof List<?>) {
			rhs = listToAnd((List<GraphPatternElement>) rhs).get(0);
		}
		jand.setRhs(rhs);
		patterns.set(0, jand);
		return patterns;
	}

	/**
	 * Second-level method for expanding ProxyNodes--this one has a list of the results passed in as an argument
	 * @param patterns
	 * @param pattern
	 * @param isRuleThen 
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, Object pattern, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		if (pattern instanceof ProxyNode) {
			return expandProxyNodes(patterns, ((ProxyNode)pattern).getProxyFor(), isRuleThen);
		}
		if (pattern instanceof TripleElement) {
			return expandProxyNodes(patterns,(TripleElement)pattern, isRuleThen);
		}
		else if (pattern instanceof BuiltinElement) {
			return expandProxyNodes(patterns, (BuiltinElement)pattern, isRuleThen);
		}
		else if (pattern instanceof Literal) {
			return pattern;
		}
		else if (pattern instanceof Junction) {
			// remember what we have so far and create a new pattern list for each side of the Junction
			List<GraphPatternElement> existingPatterns = patterns;
			List<GraphPatternElement> lhsPatterns = new ArrayList<GraphPatternElement>();
			List<GraphPatternElement> rhsPatterns = new ArrayList<GraphPatternElement>();
			
			// get the two sides
			Object lhs = ((Junction)pattern).getLhs();
			Object rhs = ((Junction)pattern).getRhs();
			
			// at least handle the interesting special case where they  are literals
			
			if (lhs instanceof Literal) {
				BuiltinElement lhsbe = new BuiltinElement();
				lhsbe.setFuncName("==");
				lhsbe.setCreatedFromInterval(true);
				lhsbe.addArgument(nodeCheck(lhs));
				((Junction)pattern).setLhs(lhsbe);
			}
			else {
				expandProxyNodes(lhsPatterns, lhs, isRuleThen);
				if (lhsPatterns.size() == 1) {
					((Junction)pattern).setLhs(lhsPatterns.get(0));
				}
				else if (lhsPatterns.size() < 1) {
					((Junction)pattern).setLhs(lhs);
				}
				else {
					((Junction)pattern).setLhs(listToAnd(lhsPatterns).get(0));
	//				throw new TranslationException("LHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			
			if (rhs instanceof Literal) {
				BuiltinElement rhsbe = new BuiltinElement();
				rhsbe.setFuncName("==");
				rhsbe.setCreatedFromInterval(true);
				rhsbe.addArgument(nodeCheck(rhs));
				((Junction)pattern).setRhs(rhsbe);
			}
			else {
				expandProxyNodes(rhsPatterns, rhs, isRuleThen);
				if (rhsPatterns.size() == 1) {
					((Junction)pattern).setRhs(rhsPatterns.get(0));
				}
				else if (rhsPatterns.size() < 1) {
					((Junction)pattern).setRhs(rhs);
				}
				else {
					((Junction)pattern).setRhs(listToAnd(rhsPatterns).get(0));
	//				throw new TranslationException("RHS of a Junction should be a single GraphPatternElement: " + jctPatterns.toString());
				}
			}
			patterns = existingPatterns;
			patterns.add((Junction)pattern);
			return null;
		}
		return patterns;
	}
	
	/**
	 * If a triple has a null, fill it with a variable (search the patterns list first to avoid duplicates), 
	 *  add the triple to the patterns list, and return the variable. The variable also replaces the proxy node 
	 *  that contained this triple.
	 * @param patterns
	 * @param te
	 * @param expType
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, TripleElement te, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(te);
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		Node subj = te.getSubject();
		if (subj instanceof ProxyNode) {
			if (retiredNode != null) {
				subj = returnNode = retiredNode;
			}
			else if (((ProxyNode)subj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)subj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)subj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)subj).getProxyFor(), (ProxyNode) subj);
				}
				subj = returnNode = ((ProxyNode)subj).getReplacementNode();
			}
			else {
				Object realSubj = ((ProxyNode)subj).getProxyFor();
				Object subjNode = expandProxyNodes(patterns, realSubj, isRuleThen);
				((ProxyNode)subj).setReplacementNode(nodeCheck(subjNode));
				retiredProxyNodes.put((GraphPatternElement) realSubj, (ProxyNode)subj);
				subj = nodeCheck(subjNode);
				if (realSubj instanceof TripleElement && ((TripleElement)realSubj).getSourceType().equals(TripleSourceType.ITC)) {
					returnNode = subj;
				}
			}
			te.setSubject(subj);
			patterns.add(te);
		}
		else if (subj == null) {
			// this is a triple with a need for a variable for subject
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), te.getObject());
			te.setSubject(returnNode);
			// TODO when this is nested the triple (te) needs to be inserted before the returnNode is used
			patterns.add(te);
		}
		Node obj = te.getObject();
		if (obj instanceof ProxyNode) {
			int initialPatternLength = patterns == null ? 0 : patterns.size();
			if (retiredNode != null) {
				obj = returnNode = retiredNode;
			}
			else if (((ProxyNode)obj).getReplacementNode() != null) {
				if (!patterns.contains(((ProxyNode)obj).getProxyFor())) {
					patterns.add((GraphPatternElement) ((ProxyNode)obj).getProxyFor());
					retiredProxyNodes.put((GraphPatternElement)((ProxyNode)obj).getProxyFor(), (ProxyNode) obj);
				}
				obj = returnNode = ((ProxyNode)obj).getReplacementNode();
			}
			else {
				Object realObj = ((ProxyNode)obj).getProxyFor();
				List<GraphPatternElement> rememberedPatterns = null;
				if (realObj instanceof BuiltinElement && isRuleThen) {
					rememberedPatterns = patterns;
					patterns = new ArrayList<GraphPatternElement>();
				}
				Object objNode = expandProxyNodes(patterns, realObj, isRuleThen);
				if (objNode == null && ((ProxyNode)obj).getReplacementNode() != null) {
					// This can happen because the proxy node gets processed but not returned
					objNode = ((ProxyNode)obj).getReplacementNode();
				}
				if (objNode == null && (realObj instanceof BuiltinElement 
						|| (realObj instanceof Junction && ((Junction)realObj).getLhs() instanceof BuiltinElement 
								&& ((Junction)realObj).getRhs() instanceof BuiltinElement))) {
					List<BuiltinElement> builtins = new ArrayList<BuiltinElement>();
					Node newNode = null;
					if (realObj instanceof BuiltinElement) {
						builtins.add((BuiltinElement)realObj);
						newNode = getVariableNode((BuiltinElement)realObj);
					}
					else {
						builtins.add((BuiltinElement)((Junction)realObj).getLhs());
						newNode = getVariableNode(builtins.get(0));
						builtins.add((BuiltinElement)((Junction)realObj).getRhs());
					}
					for (int i = 0; i < builtins.size(); i++) {
						BuiltinElement bi = builtins.get(i);
						if (bi.isCreatedFromInterval()) {
							bi.addArgument(0, newNode);
						}
						else {
							bi.addArgument(newNode);
						}
					}
					objNode = newNode;
					if (isRuleThen) {
						addToIfts(patterns);
						patterns = rememberedPatterns;
					}
				}
				if (objNode == null) {
					addError(new IFTranslationError("Translation to Intermediate Form failed: " + te.toString()));
				}
				((ProxyNode)obj).setReplacementNode(nodeCheck(objNode));
				retiredProxyNodes.put((GraphPatternElement) ((ProxyNode)obj).getProxyFor(), (ProxyNode)obj);
				obj = nodeCheck(objNode);
			}
			te.setObject(obj);
			if (!patterns.contains(te)) {
				if (target instanceof Rule) {
					patterns.add(te);
				}
				else {
					patterns.add(Math.max(0, initialPatternLength - 1), te);
				}
			}
		}
		else if (obj == null) {
			returnNode = retiredNode != null ? retiredNode : getVariableNode(subj, te.getPredicate(), obj);
			te.setObject(returnNode);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
		}

		if (te.getNext() != null) {
			GraphPatternElement nextGpe = te.getNext();
			te.setNext(null);
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			Object nextResult = expandProxyNodes(patterns, nextGpe, isRuleThen);
			// TODO we don't need to do anything with this, right?
		}
	
		// Special case: a pivot triple ( something type something): return the subject
		if (te instanceof TripleElement && (((TripleElement)te).getPredicate()) instanceof RDFTypeNode) {
			// this is an embedded type triple; only the subject can be a subject of the higher-level pattern
			if (!patterns.contains(te)) {
				patterns.add(te);
			}
			return ((TripleElement)te).getSubject();
		}

		// This is to make sure that complete, self-contained triple elements are still added to the output
		if (!patterns.contains(te)) {
			patterns.add(te);
		}
		if (retiredNode != null) {
			return retiredNode;
		}
		return returnNode;
	}
	
	private Node findMatchingElementInRetiredProxyNodes(GraphPatternElement ge) {
		if (retiredProxyNodes != null) {
			if (retiredProxyNodes.get(ge) != null) {
				return retiredProxyNodes.get(ge);
			}
			else {
				if (ge instanceof TripleElement && !(((TripleElement)ge).getPredicate() instanceof RDFTypeNode)) {
					TripleElement te = (TripleElement) ge;
					Iterator<GraphPatternElement> itr = retiredProxyNodes.keySet().iterator();
					while (itr.hasNext()) {
						GraphPatternElement gpe = itr.next();
						if (gpe instanceof TripleElement && !(((TripleElement)gpe).getPredicate() instanceof RDFTypeNode)) {
							if ((te.getSubject() == null || te.getSubject().equals(((TripleElement)gpe).getSubject()))
									&& (te.getPredicate() == null || te.getPredicate().equals(((TripleElement)gpe).getPredicate()))
									&& (te.getObject() == null || te.getObject().equals(((TripleElement)gpe).getObject()))) {
								ProxyNode pn = retiredProxyNodes.get(gpe);
								return pn.getReplacementNode();
							}
						}
					}
				}
			}
		}
		return null;
	}

	/**
	 * Method to handle BuiltinElements--if the 
	 * @param patterns
	 * @param be
	 * @return
	 * @throws InvalidNameException
	 * @throws InvalidTypeException
	 * @throws TranslationException
	 */
	private Object expandProxyNodes(List<GraphPatternElement> patterns, BuiltinElement be, boolean isRuleThen) throws InvalidNameException, InvalidTypeException, TranslationException {
		Node returnNode = null;
		Node retiredNode = findMatchingElementInRetiredProxyNodes(be);
		if (isRuleThen && target instanceof Rule && be.getFuncType().equals(BuiltinType.Equal)
				&& be.getArguments() != null && be.getArguments().size() == 2
				&& be.getArguments().get(0) instanceof ProxyNode && be.getArguments().get(1) instanceof ProxyNode) {
			ProxyNode arg1PN = (ProxyNode) be.getArguments().get(0);
			ProxyNode arg2PN = (ProxyNode) be.getArguments().get(1);
			Object realArgForThen = arg1PN.getProxyFor();
			Object realArgForIfs = arg2PN.getProxyFor();
			int tripleWithObjectNullCount = 0;
			if (realArgForThen instanceof TripleElement && realArgForIfs instanceof TripleElement) {
//				// args can be TripleElement only if both are and objects are both null
				if (((TripleElement)realArgForThen).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (((TripleElement)realArgForIfs).getObject() == null) {
					tripleWithObjectNullCount++;
				}
				if (tripleWithObjectNullCount == 1) {
					addError(new IFTranslationError("Translation to Intermediate Form encountered error (" + be.toString() + "); try separating rule elements with commas."));

				}
			}
			List<GraphPatternElement> moveToIfts = new ArrayList<GraphPatternElement>();
			Object finalIfsVar = expandProxyNodes(moveToIfts, realArgForIfs, false);
			if (finalIfsVar == null && realArgForIfs instanceof BuiltinElement) {
				Node newNode = getVariableNode((BuiltinElement)realArgForIfs);
				((BuiltinElement)realArgForIfs).addArgument(newNode);
				finalIfsVar = newNode;
				((ProxyNode)arg1PN).setReplacementNode(nodeCheck(finalIfsVar));
				retiredProxyNodes.put((GraphPatternElement) realArgForIfs, arg1PN);
			}
			addToIfts(moveToIfts);
			if (realArgForThen instanceof TripleElement && ((TripleElement)realArgForThen).getObject() == null) {
				((TripleElement)realArgForThen).setObject(nodeCheck(finalIfsVar));
				patterns.add((TripleElement)realArgForThen);
			}
			else {
				throw new TranslationException("Unhandled condition, LHS of Equal in Then isn't a TripleElement: " + realArgForThen.toString());
			}
			return null;
		}
		
		if (retiredNode != null && retiredNode instanceof ProxyNode) {
			retiredNode = ((ProxyNode)retiredNode).getReplacementNode();
		}
		List<Node> args = be.getArguments();
		for (int i = 0; args != null && i < args.size(); i++) {
			Node arg = args.get(i);
			if (arg instanceof ProxyNode) {
				if (retiredNode != null) {
					args.set(i, retiredNode);
				}
				else {
					Object realArg = ((ProxyNode)arg).getProxyFor();
					Object argNode = expandProxyNodes(patterns, realArg, isRuleThen);
					if (argNode == null && realArg instanceof BuiltinElement) {
						Node newNode = getVariableNode((BuiltinElement)realArg);
						((BuiltinElement)realArg).addArgument(newNode);
						argNode = newNode;
					}
					((ProxyNode)arg).setReplacementNode(nodeCheck(argNode));
					retiredProxyNodes.put((GraphPatternElement) realArg, (ProxyNode)arg);
					args.set(i, nodeCheck(argNode));
				}
			}
		}
		patterns.add(be);
		return returnNode;
	}
	
	/**
	 * Combine the argument elements with the existing Rule Ifs elements
	 * @param moveToIfts
	 */
	private void addToIfts(List<GraphPatternElement> moveToIfts) {
		if (target instanceof Rule) {
			List<GraphPatternElement> ifts = ((Rule)target).getIfs();
			if (ifts == null) {
				((Rule)target).setIfs(moveToIfts);
			}
			else {
				ifts.addAll(moveToIfts);
			}
		}
	}

	/**
	 * This method flattens out the GraphPatternElement List so that there are no
	 * next pointers within the list.
	 * 
	 * @param list - input GraphPatternElement List that may have chained elements inside it
	 * @return - the transformed list
	 */
	public List<GraphPatternElement> flattenLinkedList(List<GraphPatternElement> list) {
		// go backwards through list so that the i index will remain valid
		for (int i = list.size() -1; i >= 0; i--) {
			GraphPatternElement element = list.get(i);
			if (element instanceof Junction) {
				flattenJunction((Junction)element);
			}
			GraphPatternElement nextElement = element.getNext();  // an internal chain
			int j = 0;
			while (nextElement != null) {
				element.setNext(null);
				list.add((1+i+(j++)),nextElement);
				element = nextElement;
				nextElement = element.getNext();
			}
		}
		return list;
	}
	
	private void flattenJunction(Junction element) {
		Object lhs = element.getLhs();
		if (lhs instanceof Junction) {
			flattenJunction((Junction)lhs);
		}
		else if (lhs instanceof GraphPatternElement && ((GraphPatternElement)lhs).getNext() != null) {
			element.setLhs(flattenJunctionSide((GraphPatternElement) lhs));
		}
		Object rhs = element.getRhs();
		if (rhs instanceof Junction) {
			flattenJunction((Junction)rhs);
		}
		else if (rhs instanceof GraphPatternElement && ((GraphPatternElement)rhs).getNext() != null) {
			element.setRhs(flattenJunctionSide((GraphPatternElement) rhs));
		}
	}
	
	private Object flattenJunctionSide(GraphPatternElement gpe) {
		if (gpe.getNext() != null) {
			List<GraphPatternElement> lst = new ArrayList<GraphPatternElement>();
			lst.add(gpe);
			lst = flattenLinkedList(lst);
			return lst;
		}
		return gpe;
	}
	
	private void removeDuplicateElements(Rule rule) {
		List<GraphPatternElement> givens = rule.getGivens();
		List<GraphPatternElement> ifs = rule.getIfs();
		List<GraphPatternElement> thens = rule.getThens();
		removeDuplicates(thens, thens, true);		// remove anything duplicated in thens
//		removeDuplicates(thens, ifs, false);			// remove anything in ifs from thens
//		removeDuplicates(thens, givens, false);		// remove anything in givens from thens
		removeDuplicates(ifs, ifs, true);			// remove anything duplicated in ifs
		removeDuplicates(ifs, givens, false);		// remove anything in givens from ifs
		removeDuplicates(givens, givens, true);		// remove anything duplicated in givens
	}
	
	/**
	 * If an element in list1 is also in list2, remove the element from list1
	 * 
	 * @param list1
	 * @param list2
	 * @param bRetainFirst -- true if same lists; if same lists leave first occurance
	 */
	private int removeDuplicates(List<GraphPatternElement> list1, List<GraphPatternElement> list2, boolean bRetainFirst) {
		if (list1 == null || list2 == null || list1.size() < 1 || list2.size() < 1) {
			return 0;
		}
		List<GraphPatternElement> flatList2 = getAllGPEs(list2);
		int removalCnt = 0;
		List<Integer> toBeRemoved = null;
		for (int idx2 = 0; idx2 < flatList2.size(); idx2++) {
			GraphPatternElement gpeToMatch = flatList2.get(idx2);	// this is the element we are considering for duplicate removals
			boolean foundFirst = false;
			for (int idx1 = 0; idx1 < list1.size(); idx1++) {
				GraphPatternElement gpe = list1.get(idx1);
				if (gpe.equals(gpeToMatch)) {
					if (!bRetainFirst || foundFirst) {
						if (toBeRemoved == null) {
							toBeRemoved = new ArrayList<Integer>();
						}
						if (!toBeRemoved.contains(idx1)) {
							toBeRemoved.add(idx1);
							removalCnt++;
						}
					}
					foundFirst = true;
				}
				else if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
					Object[] results = removeJunctionDuplicates((Junction)gpe, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
					GraphPatternElement processedGpe = (GraphPatternElement) results[0];
					foundFirst = ((Boolean)results[1]).booleanValue();
					removalCnt = ((Integer)results[2]).intValue();
					if (!processedGpe.equals(gpe)) {
						list1.set(idx1, processedGpe);
					}
				}
			}
		}
		if (toBeRemoved != null) {
			Collections.sort(toBeRemoved);
			for (int i = (toBeRemoved.size() - 1); i >= 0; i--) {
				list1.remove(toBeRemoved.get(i).intValue());
			}
		}
		return removalCnt;
	}
	
	private Object[] removeJunctionDuplicates(Junction gpe, GraphPatternElement gpeToMatch, boolean bRetainFirst, boolean foundFirst, int removalCnt) {
		boolean lhsDuplicate = false;
		boolean rhsDuplicate = false;
		Object lhs = gpe.getLhs();
		if (lhs.equals(gpeToMatch)) {
			if(!bRetainFirst || foundFirst){
				lhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] lhsResults = removeJunctionDuplicates((Junction)lhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newLhs = (GraphPatternElement) lhsResults[0];
			foundFirst = ((Boolean)lhsResults[1]).booleanValue();
			removalCnt = ((Integer)lhsResults[2]).intValue();
			if (!newLhs.equals(lhs)) {
				gpe.setLhs(newLhs);
			}
		}
		Object rhs = gpe.getRhs();
		if (rhs != null && rhs.equals(gpeToMatch)) {
			if (!bRetainFirst || foundFirst) {
				rhsDuplicate = true;
			}
			foundFirst = true;
		}
		else if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			Object[] rhsResults = removeJunctionDuplicates((Junction)rhs, gpeToMatch, bRetainFirst, foundFirst, removalCnt);
			GraphPatternElement newrhs = (GraphPatternElement) rhsResults[0];
			foundFirst = ((Boolean)rhsResults[1]).booleanValue();
			removalCnt = ((Integer)rhsResults[2]).intValue();
			if (!newrhs.equals(rhs)) {
				gpe.setRhs(newrhs);
			}
		}
		Object[] results = new Object[3];
		if (lhsDuplicate) {
			results[0] = gpe.getRhs();
		}
		else if (rhsDuplicate) {
			results[0] = gpe.getLhs();
		}
		else {
			results[0] = gpe;
		}
		results[1] = new Boolean(foundFirst);
		results[2] = new Integer(removalCnt);
		return results;
	}

	private List<GraphPatternElement> getAllGPEs(List<GraphPatternElement> list) {
		List<GraphPatternElement> results = null;
		for (int i = 0; list != null && i < list.size(); i++) {
			GraphPatternElement gpe = list.get(i);
			if (gpe instanceof Junction && ((Junction)gpe).getJunctionType().equals(JunctionType.Conj)) {
				if (results != null) {
					results.addAll(junctionToList((Junction) gpe));
				}
				else {
					results = junctionToList((Junction) gpe);
				}
			}
			else {
				if (results == null) {
					results = new ArrayList<GraphPatternElement>();
				}
				results.add(gpe);
			}
		}
		if (results != null) {
			return results;
		}
		return list;
	}
	
	private List<GraphPatternElement> junctionToList(Junction gpe) {
		List<GraphPatternElement> results = null;
		Object lhs = gpe.getLhs();
		if (lhs instanceof Junction && ((Junction)lhs).getJunctionType().equals(JunctionType.Conj)) {
			results = junctionToList((Junction)lhs);
		}
		else {
			results = new ArrayList<GraphPatternElement>();
			results.add((GraphPatternElement) lhs);
		}
		Object rhs = gpe.getRhs();
		if (rhs instanceof Junction && ((Junction)rhs).getJunctionType().equals(JunctionType.Conj)) {
			if (results != null) {
				results.addAll(junctionToList((Junction)rhs));
			}
			else {
				results = junctionToList((Junction)rhs);
			}
		}
		else if (rhs instanceof GraphPatternElement){
			results.add((GraphPatternElement) rhs);
		}
		return results;
	}
	

	/**
	 * This method returns true only if all variables in the element are bound in other rule elements
	 * 
	 * @param rule
	 * @param gpe
	 * @return
	 */
	private boolean allElementVariablesBound(Rule rule,
			GraphPatternElement gpe) {
		if (gpe instanceof TripleElement) {
			Node subject = ((TripleElement)gpe).getSubject();
			if ((subject instanceof VariableNode || subject instanceof NamedNode)
					&& !variableIsBound(rule, gpe, subject)) {
				return false;
			}
			Node object = ((TripleElement)gpe).getObject();
			if ((object instanceof VariableNode || object instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, object)) {
				return false;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			for (int i = 0; args != null && i < args.size(); i++) {
				Node arg = args.get(i);
				if ((arg instanceof VariableNode || arg instanceof NamedNode) 
					&& !variableIsBound(rule, gpe, arg)) {
						return false;
					}
			}
		}
		return true;
	}

	/**
	 * This method returns true if the argument node is bound in some other element of the rule
	 * 
	 * @param rule
	 * @param gpe
	 * @param v
	 * @return
	 */
	public static boolean variableIsBound(Rule rule, GraphPatternElement gpe,
			Node v) {
		if (v instanceof NamedNode) {
			if (((NamedNode)v).getNodeType() != null && !(((NamedNode)v).getNodeType().equals(NodeType.VariableNode))) {
				return true;
			}
		}
		// Variable is bound if it appears in a triple or as the return argument of a built-in
		List<GraphPatternElement> givens = rule.getGivens();
		if (variableIsBoundInOtherElement(givens, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> ifs = rule.getIfs();
		if (variableIsBoundInOtherElement(ifs, 0, gpe, true, false, v)) {
			return true;
		}
		List<GraphPatternElement> thens = rule.getThens();
		if (variableIsBoundInOtherElement(thens, 0, gpe, false, true, v)) {
			return true;
		}
		return false;
	}

	/**
	 * This method checks the list of GraphPatternElements to see if the specified variable is bound in these elements
	 * 
	 * @param gpes - list of GraphPatternElements to check
	 * @param startingIndex - where to start in the list
	 * @param gp - the element in which this variable appears 
	 * @param boundIfEqual - use the current element for test?
	 * @param matchMustBeAfter - must the binding be after the current element
	 * @param v - the variable Node being checked
	 * @return - true if the variable is bound else false
	 */
	public static boolean variableIsBoundInOtherElement(List<GraphPatternElement> gpes, int startingIndex, GraphPatternElement gp, 
			boolean boundIfEqual, boolean matchMustBeAfter, Node v) {
		boolean reachedSame = false;
		for (int i = startingIndex; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			while (gpe != null) {
				boolean same = gp == null ? false : gp.equals(gpe);
				if (same) {
					reachedSame = true;
				}
				boolean okToTest = false;
				if (matchMustBeAfter && reachedSame && !same) {
					okToTest = true;
				}
				if (!matchMustBeAfter && (!same || (same && boundIfEqual))) {
					okToTest = true;
				}
				if (okToTest && variableIsBound(gpe, v)) {
					return true;
				}
				gpe = gpe.getNext();
			}
		}
		return false;
	}
	
	private static boolean variableIsBound(GraphPatternElement gpe, Node v) {
		if (gpe instanceof TripleElement) {
			if ((((TripleElement)gpe).getSubject() != null &&((TripleElement)gpe).getSubject().equals(v)) || 
					(((TripleElement)gpe).getObject() != null && ((TripleElement)gpe).getObject().equals(v))) {
				return true;
			}
		}
		else if (gpe instanceof BuiltinElement) {
			List<Node> args = ((BuiltinElement)gpe).getArguments();
			// TODO built-ins can actually have more than the last argument as output, but we can only tell this
			//	if we have special knowledge of the builtin. Current SADL grammar doesn't allow this to occur.
			if (args != null && args.get(args.size() - 1) != null && args.get(args.size() - 1).equals(v)) {
				return true;
			}
		}
		else if (gpe instanceof Junction) {
			Object lhsobj = ((Junction)gpe).getLhs();
			if (lhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)lhsobj, v)) {
				return true;
			}
			else if (lhsobj instanceof VariableNode && ((VariableNode)lhsobj).equals(v)) {
				return true;
			}
			Object rhsobj = ((Junction)gpe).getRhs();
			if (rhsobj instanceof GraphPatternElement && variableIsBound((GraphPatternElement)rhsobj, v)) {
				return true;
			}
			else if (rhsobj instanceof VariableNode && ((VariableNode)rhsobj).equals(v)) {
				return true;
			}
		}
		return false;
	}

	private boolean doVariableSubstitution(List<GraphPatternElement> gpes,
			VariableNode v1, VariableNode v2) {
		boolean retval = false;
		for (int i = 0; gpes != null && i < gpes.size(); i++) {
			GraphPatternElement gpe = gpes.get(i);
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
		}
		return retval;
	}

	private boolean doVariableSubstitution(GraphPatternElement gpe, VariableNode v1, VariableNode v2) {
		boolean retval = false;
		do {
			if (gpe instanceof TripleElement) {
				if (((TripleElement)gpe).getSubject().equals(v1)) {
					((TripleElement)gpe).setSubject(v2);
					retval = true;
				}
				else if (((TripleElement)gpe).getObject().equals(v1)) {
					((TripleElement)gpe).setObject(v2);
					retval = true;
				}
			}
			else if (gpe instanceof BuiltinElement) {
				List<Node> args = ((BuiltinElement)gpe).getArguments();
				for (int j = 0; j < args.size(); j++) {
					if (args.get(j).equals(v1)) {
						args.set(j, v2);
						retval = true;
					}
				}
			}
			else if (gpe instanceof Junction) {
				logger.error("Not yet handled");
			}
			gpe = gpe.getNext();
		} while (gpe != null);
		return retval;
	}

	private void setFirstOfPhrase(GraphPatternElement firstOfPhrase) {
		this.firstOfPhrase = firstOfPhrase;
	}

	protected GraphPatternElement getFirstOfPhrase() {
		return firstOfPhrase;
	}

	public void setEncapsulatingTarget(Object _encapsulatingTarget) {
		encapsulatingTarget = _encapsulatingTarget;
	}

	public boolean isCollectNamedNodes() {
		return collectNamedNodes;
	}

	public void setCollectNamedNodes(boolean collectNamedNodes) {
		this.collectNamedNodes = collectNamedNodes;
	}

	/**
	 * This method can be called only once for a given set of translations; calling it clears the list of ConceptNames
	 * @return
	 */
	public List<ConceptName> getNamedNodes() {
		if (namedNodes != null) {
			List<ConceptName> x = new ArrayList<ConceptName>(namedNodes);
			namedNodes.clear();
			return x;
		}
		return null;
	}

	private void setNamedNodes(List<ConceptName> namedNodes) {
		this.namedNodes = namedNodes;
	}

}
