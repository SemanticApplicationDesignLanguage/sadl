<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Xtext Scopes in the SADL IDE</title>
  </head>
  <body>
    <h1>Xtext Scopes in the SADL IDE</h1>
    <h5>Last revised
      <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->1/6/2022<!--webbot bot="Timestamp" endspan i-checksum="12511" -->.
      <a href="contact.html">Contact us</a>.</h5>
    <h2>Introduction</h2>
    <p>Scoping defines the visibility rules inside of a SADL file and across
      SADL file boundaries. For example, if a class <i>C1</i> is defined in a
      SADL file with namespace (URI) <i>http://sadl.org/ns1</i>, the class <i>C1</i>
      is visible anywhere in that SADL file and in any model that imports <i>http://sadl.org/ns1</i>.
      On the other hand, if a variable <i>X</i> is defined in a rule, query, or
      test in h<i>ttp://sadl.org/ns1</i>, <i>X</i> is visible only within that
      rule, query, or test. If there is a variable <i>X</i> in another rule,
      query, or test in h<i>ttp://sadl.org/ns1</i>, that <i>X</i> is entirely
      independent and in its turn visible only within its rule, query, or test.</p>
    <p>Furthermore, scoping must differentiate the location of the definition of
      a class, property, instance, or variable from references to it. Consider
      this small model.</p>
    <div style="margin-left: 40px;"><img src="images/scoping1.png" alt=""></div>
    <p>The instance <i>i2</i> appears in the statements on lines 5 and 6. Even
      though the statement on line 5 appears first, it is the statement on line
      6 that defines <i>i2</i>. Line 5 contains only a reference to <i>i2</i>.
      In order for the hyperlinking to definition and to references to work
      properly, scoping must correctly identify which occurrence is the
      definition and which occurrences are references. </p>
    <p>Xtext scoping is a complex topic. Some references that may prove useful
      include the following.</p>
    <ul>
      <li><a href="https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping">https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping</a></li>
      <li><span style="color: #0000ee;">https://www.eclipsecon.org/france2017/session/deep-dive-xtext-scoping-local-and-global-scopes-explained</span></li>
    </ul>
    <h2>Into the Caldron</h2>
    <p>A scope describes the visible names, which depends on the context, and
      maps names to the parse tree's EMF EObjects in a chain of scopes. Local
      scopes have to do with references within a Resource (SADL file). Global
      scopes have to do with those names that are visible from outside a
      Resource (SADL or OWL file), assuming that the Resource is imported. </p>
    <p>The IScope class represents an element of a linked list of scopes. A
      scope can be nested within an outer scope. Each scope is like a symbol
      table or map where the keys are strings and the values are
      IEObjectDescription instances, abstract descriptions of real EObject
      instances. </p>
    In the SADL IDE, the following classes deal with scoping.
    <ul>
      <li>ErrorAndLinkingService</li>
      <li>GlobalScopeProviderFilterProvider</li>
      <li>SADLScopeProvider </li>
      <ul>
        <li>(extends AbstractGlobalScopeDelegatingScope:Provider)</li>
        <li>public method getScope</li>
      </ul>
      <li>SilencedImportedNamesAdapter</li>
      <li>TestScopeProvider</li>
      <li>ExternalEmfResource</li>
      <li>LazyResolvedSadlImport</li>
      <li>SadlQueryHelper</li>
      <li>SadlIdeContentProposalProvider</li>
      <li>SadlIdeRenameService</li>
      <li>SadlIdeGlobalScopeProviderFilterProvider</li>
      <li>SadServerModule</li>
    </ul>
    <p>Of particular interest to this discussion is the class SADLScopeProvider.
      this class contains a set of methods named localScope_01, localScope_02,
      ..., localScope06. These are the scope providers referred to below.</p>
    <p>Scope processing in SADL has a nested iterative structure. The outer
      iteration is over the local scope providers, methods in SADLScopeProvider
      named localScope_01, localScope_02, ..., localScope06. The inner iteration
      is over the contents of the parse tree. Written as pseudo code, the
      overall outline of the scope processing looks something like this.</p>
    <p style="margin-left: 40px;">&nbsp;for (scopeProvider : scopeProviders) {</p>
    <p style="margin-left: 80px;">&nbsp;for (eObj : resource.allContents) {</p>
    <p style="margin-left: 120px;">//&nbsp; Check if this eObj's characteristics
      are matched by the conditions of the current scopeProvider and if so
      create a scope for the eObj if it is a SadlResource.<br>
      //&nbsp; This occurrence of eObj will be the definition of the identified
      SadlResource. All other SadlResources with the same URI will be
      references.<br>
      //&nbsp; Note that the conditions of the scope providers can only match
      (return true) for an EObject which is a SadlResource.</p>
    <p style="margin-left: 80px;">}</p>
    <p style="margin-left: 40px;">}</p>
    <p>In other words, each local scope provider checks for definitions. The
      scope providers are processed from highest priority statements that are
      definitions to lowest priority statements that might be definitions. For
      each local scope provider, go through the parse tree's EObjects and
      identify the definitions, then create scoping information for each one
      that qualifies.</p>
    <p>Note: within the JenaBasedSadlModelProcessor, the method getNewVar uses
      an IScopeProvider to help determine whether to use an existing variable in
      the local scope or create a new one. </p>
    <ul>
    </ul>
    <h2>Logic of Local Scope Providers by Level</h2>
    <p>The logic for each of the six levels is described below. (The code in
      SADLScopeProvider is the ultimate truth; this is a snapshot for
      documentation purposes.)</p>
    <ol>
      <li>returns true for a SadlResource AND </li>
      <ol>
        <li>(eContainer instanceOf SadlClassOrPropertyDeclaration AND
          eContainingFeature ==
          SADL_CLASS_OR_PROPERTY_DECLARATION__CLASS_OR_PROPERTY AND
          eContainer.eContainer NOT instanceof SadlDifferentFrom)</li>
        <li>OR</li>
        <li>(eContainer instanceof SadProperty AND
          eContainer.isPrimaryDeclaration() AND eContainingFeature ==
          SADL_ROPERTY__NAME_OR_REF)</li>
      </ol>
      <li>returns true for a SadlResource AND</li>
      <ol>
        <li>(eContainer instanceof SadlProperty AND eContainingFeature ==
          SADL_PROPERTY__NAME_OR_REF)</li>
        <li>OR</li>
        <li>(eContainer instanceof SadlProperty AND eContainingFeature ==
          SADL_PROPERTY__NAME_DECLARATION)</li>
      </ol>
      <li>returns true for a SadlResource AND</li>
      <ol>
        <li>(eContainer instanceof EquationStatement &amp;&amp;(eContainer as
          EquationStatement).name.equals(the SadlResource))</li>
        <li>OR</li>
        <li>(eContainer instanceof ExternalEquationStatement
          &amp;&amp;(eContainer as ExternalEquationStatement).name.equals(the
          SadlResource))</li>
        <li>OR</li>
        <li>eContainer instanceof SadlNecessaryAndSufficient AND&nbsp;
          eContainingFeature == SADL_NECESSARY_AND_SUFFICIENT__OBJECT)</li>
      </ol>
      <li>returns true for a SadlResource&nbsp; AND</li>
      <ol>
        <li>eContainer instanceof SadlNestedInstance AND&nbsp;
          eContainingFeature == SADL_INSTANCE__INSTANCE</li>
      </ol>
      <li>returns true for a SadlResource AND</li>
      <ol>
        <li>eContainer instanceof SadlInstance AND&nbsp; eContainingFeature ==
          SADL_INSTANCE__NAME_OR_REF AND eC.type != null // last condition is
          GH-511 addition</li>
      </ol>
      <li>returns true for a SadlResource AND </li>
      <ol>
        <li>(eContainer instanceof SadlMustBeOneOf&nbsp; AND&nbsp;
          eContainingFeature == SADL_MUST_BE_ONE_OF__VALUES)</li>
        <li>OR</li>
        <li>(eContainer instanceof SadlCanOnlyBeOneOf and&nbsp;
          eContainingFeature == SADL_CAN_ONLY_BE_ONE_OF__VALUES)</li>
      </ol>
    </ol>
    <h2>Examples</h2>
    <p>All of the scoping providers only apply to SadlResource as that is the
      only EObject that is linked. The matches to scoping providers by
      SadlResource are:</p>
    <ol>
      <li>Cls in the first statement matches for localScope_01</li>
      <li>objProp in the first statement matches for localScope_02</li>
      <li>i1 in the second statement matches for localScope_05</li>
      <li>i2 in the fourth statement matches for localScope_05 </li>
    </ol>
    <br>
    <p><br>
    </p>
    <p><br>
    </p>
  </body>
</html>
