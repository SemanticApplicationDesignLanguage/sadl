<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=windows-1252">
    <title>Rule Builtins</title>
  </head>
  <body>
    <h1>Rule Builtins</h1>
    <h5>Last revised
      <!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%m/%d/%Y" startspan -->7/8/2021<!--webbot bot="Timestamp" endspan i-checksum="12511" -->.
      <a href="contact.html">Contact us</a>.</h5>
    <h2>Introduction</h2>
    <p>Rules are a convenient way to capture domain knowledge in the familiar
      format of "if this then that". Many of a rule's conditions and conclusions
      will contain graph patterns, but sometimes built-in functions will be
      used. Consider the following SADL rule.</p>
    <p style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;"
      align="left"> <font size="2" color="#800080">&nbsp;&nbsp;&nbsp; Rule<span
          class="Apple-converted-space">&nbsp;</span></font><font size="2">AreaOfRectangle<span
          class="Apple-converted-space">&nbsp;</span><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Apple-converted-space">&nbsp;</span></font><font
        size="2" color="#800080">given&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><font
        size="2" color="#ff00ff"><b>x</b></font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#800080">is</font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#800080">any</font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#000080"><b>Rectangle</b></font><font size="2" color="#800080"><br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        then&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</font><span
        class="Apple-converted-space">&nbsp;</span><font size="2" color="#008000"><b>area</b></font><span
        class="Apple-converted-space">&nbsp;</span><font size="2" color="#800080">of</font><span
        class="Apple-converted-space">&nbsp;</span><font size="2" color="#ff00ff"><b>x</b></font><font
        size="2">=<span class="Apple-converted-space">&nbsp;</span></font><font
        size="2" color="#008000"><b>height</b></font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#800080">of</font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#ff00ff"><b>x</b></font><font size="2">*<span class="Apple-converted-space">&nbsp;</span></font><font
        size="2" color="#008000"><b>width</b></font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#800080">of</font><span class="Apple-converted-space">&nbsp;</span><font
        size="2" color="#ff00ff"><b>x</b></font><font size="2">.</font></p>
    <p>This rule expands into a number of conditions and a single conclusion.
      There is one explicit variable in the rule, <font size="2" color="#ff00ff"><b>x</b></font>,
      but the expansion will create additional implicit variables. This rule
      will translate into something like the following for most reasoners, where
      a "?" is placed in front of variable names to identify them as variables.
    </p>
    <p style="margin-left: 40px;">if<br>
      &nbsp; ?x rdf:type Rectangle<br>
      &nbsp; ?x height ?v1<br>
      &nbsp; ?x width ?v2<br>
      &nbsp; product(?v1,?v2,?v3)<br>
      then<br>
      &nbsp; ?x area ?v3 </p>
    <p>When variables are used in multiple graph patterns, as they are in this
      example, the first occurrence in the rule conditions "binds" the variable
      and those bindings are then be used in subsequent conditions and in the
      conclusions. In this example, <font size="2" color="#ff00ff"><b>x</b></font>
      is bound to instances of the class <font size="2" color="#000080"><b>Rectangle</b></font>.
      Each possible binding will result in the rule being evaluated by the
      reasoner. </p>
    <p>All of the conditions and the conclusion are graph patterns <i><b>except</b></i>
      "<em>product(?v1,?v2,?v3)</em>". This condition is a built-in function.
      Functions in a rule's conditions return true (meaning the condition is
      satisfied) or false (meaning the condition is not satisfied so the rule
      should not "fire" (cause the conclusions to be processed). In this case,
      the function also binds the result of the procedural computation
      (multiplication) to a new variable, <em>?v3</em>. </p>
    <h2>Jena Reasoner Built-ins</h2>
    <p>The default reasoner for SADL Version 3 is the <a href="https://jena.apache.org/documentation/inference/#rules">Jena
        general purpose rule engine</a>. This reasoner comes with a number of
      built-in functions, referred to in the Jena documentation as "<a href="https://jena.apache.org/documentation/inference/#RULEbuiltins">Builtin
        primitives</a>". These built-in functions are all programmed in the Java
      language.</p>
    <p>When using Jena-provided built-ins, it is important to understand the
      difference between the Jena syntax (see "Builtin Primitives" at<a href="http://jena.apache.org/documentation/inference/#RULEbuiltins">
        http://jena.apache.org/documentation/inference/#RULEbuiltins</a> ) and
      the SADL syntax. In the actual Jena rule created from the SADL rule, which
      is what is shown in the Jena documentation at the link above, if an
      assignment of the result is made to a variable, that variable will be the
      last argument to the actual built-in. This is illustrated in the expanded
      rule in the example above. In SADL syntax, the assignment is shown
      explicitly to be the variable on the left of the "=" or "is" assignment or
      implicitly as a nesting of terms. This is illustrated below for the <i>sum</i>
      built-in: </p>
    <ul>
      <li>Actual Jena syntax: <i>sum(?b, ?c, ?d) </i>means add ?b and ?c and
        assign the value to ?d </li>
      <li>SADL explicit assignment: either of examples below means the same:
        add&nbsp; b and c and assign to d</li>
      <ul>
        <li><i><font color="#ff00ff"><b>d</b></font> = sum(<font color="#ff00ff"><b>b</b></font>,
            <font color="#ff00ff"><b>c</b></font>)</i> </li>
        <li>or <i><font color="#ff00ff"><b>d</b></font> is sum(<font color="#ff00ff"><b>b</b></font>,
            <font color="#ff00ff"><b>c</b></font>)&nbsp;</i></li>
      </ul>
      <li>SADL implicit assignment: example below means add b and c and assign
        as the value of the cost property of z (additional variables are created
        in the translation from SADL to Jena Rules)</li>
      <ul>
        <li><i><font color="#008000"><b>cost</b></font> <font color="#800080">of</font>
            <font color="#ff00ff"><b>z</b></font> <font color="#800080">is</font>
            sum(<font color="#ff00ff"><b>b</b></font>, <font color="#ff00ff"><b>c</b></font>)</i>&nbsp;
          </li>
      </ul>
    </ul>
    <p>Note that if built-ins combine operations they can hide important
      dependencies from the Jena Rule Engine. For example, if one built-in
      creates a structure (a set of triples) and another uses the structure, the
      Rule Engine may not detect that the structure must be built by one rule or
      set of rules before it can be used by another. The solution to this
      problem is to always work with the individual elements, not with larger
      structures. </p>
    <p>Tables of Jena Built-Ins Available in SADL Version 3 are shown below. To
      make the table more readable, only the class name is shown. However, in
      registration references the entire fully-qualified class name must be
      specified.</p>
    <h3>Built-in Functions in the package <em>com.ge.research.sadl.jena.reasoner.builtin</em>.</h3>
    <p>The package name for all of these is <em>com.ge.research.sadl.jena.reasoner.builtin</em>.
    </p>
    <table style="BORDER-COLLAPSE: collapse" width="100%" cellspacing="0" cellpadding="0"
      bordercolor="#111111" border="1">
      <tbody>
        <tr>
          <td width="21%"><b>Built-in, SADL Rule Syntax</b></td>
          <td width="24%"><b>Java Implementation Class</b></td>
          <td width="38%"><b>Purpose</b></td>
        </tr>
        <tr>
          <td width="21%">y is abs(x)</td>
          <td width="24%">Abs</td>
          <td width="38%">Return the absolute value of the numerical value x</td>
        </tr>
        <tr>
          <td width="21%">y is acos(x)</td>
          <td width="24%">Acos</td>
          <td width="38%">Return the inverse cosine of the numerical value x
            (return value in radians)</td>
        </tr>
        <tr>
          <td width="21%">y is asin(x)</td>
          <td width="24%">Asin</td>
          <td width="38%">Return the inverse sine of the numerical value x
            (return value in radians)</td>
        </tr>
        <tr>
          <td width="21%">y is 3.4</td>
          <td width="24%">Assign</td>
          <td width="38%">Used in translation&nbsp; of assignment of a literal
            to a variable in a rule body</td>
        </tr>
        <tr>
          <td width="21%">y is atan(x)</td>
          <td width="24%">Atan</td>
          <td width="38%">Return the inverse tangent of the numerical value x
            (return value in radians)</td>
        </tr>
        <tr>
          <td width="21%">z is average(x,y, ...)</td>
          <td width="24%">Average</td>
          <td width="38%">Return the average of any number of numerical values</td>
        </tr>
        <tr>
          <td width="21%">y is ceiling(x)</td>
          <td width="24%">Ceiling</td>
          <td width="38%">Return the smallest integer larger than x</td>
        </tr>
        <tr>
          <td width="21%">y is cos(x)</td>
          <td width="24%">Cos</td>
          <td width="38%">Return the cosine of the numerical value x
            representing an angle in radians</td>
        </tr>
        <tr>
          <td width="21%">(1): n is countMatches(s, p)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; or<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n is countMatches(s, p, x)<br>
            (2): n is countMatches(s1, p1, o1, s2, p2, o2, ..., sn, pn)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n is countMatches(s1, p1, o1, s2, p2,
            o2, ..., sn, pn, x)</td>
          <td width="24%">CountMatches</td>
          <td width="38%">This built-in returns the same value as
            "listLength(list(...))" for the same arguments; it counts the number
            of&nbsp; matches to the graph pattern specified in the arguments.
            This built-in does not create an rdf:List so there are no additions
            to the inferred model as a side-effect. See the "list" built-in
            below for a detailed discussion of the arguments. See also
            "countUniqueMatches".</td>
        </tr>
        <tr>
          <td width="21%">n is countUniqueMatches(....)</td>
          <td width="24%">CountUniqueMatches</td>
          <td width="38%">Counts the number of unique matches (duplicates
            removed); same argument pattern as CountMatches</td>
        </tr>
        <tr>
          <td width="21%">y is floor(x)</td>
          <td width="24%">Floor</td>
          <td width="38%">Return the largest integer smaller than x</td>
        </tr>
        <tr>
          <td width="21%"><font size="2" color="#800080"> </font>
            <p align="LEFT"><font face="Times New Roman">y is getInstance(cls)<br>
              </font>y is getInstance(cls, c1a, c1b, c2a, c2b, ..., cna, cnb)<br>
              y is getInstance(cls, c1a, c1b, c2a, c2b, ..., cna, cnb, true)</p>
          </td>
          <td width="24%">GetInstance</td>
          <td width="38%">Return the instance of the class cls which also
            matches the set of constraints specified by {c1a, c1b, c2a, c2b,
            ..., cna, cnb}. Each pair of constraints represents either a triple
            pattern for which the matching instance is the subject, e.g., (?,
            c1a, c1b) and hence c1a is a property, or a triple pattern for which
            the matching instance is the object value, e.g., (c1a, c1b, ?) and
            hence c1a is an instance and c1b is a property. If no match exists
            create an instance of type cls and instantiate triples for all of
            the constraints. (A subsequent call with the same arguments will
            then return the new instance.) If there is a last boolean argument
            whose value is true, the new instance will always be created,
            matching the constraints, even if a match already exists.<br>
            <strong>Note</strong>: <em>getInstance</em> is deprecated and
            should not be used. The intended purpose is much better achieved by
            <em>thereExists</em>,&nbsp; see <em>ThereExists</em> below.</td>
        </tr>
        <tr>
          <td width="21%">greaterThan(x,y) <br>
            &nbsp; or <br>
            x &gt; y</td>
          <td width="24%">GreaterThan</td>
          <td width="38%">This extends the Jena GreaterThan built-in by a)
            adding string comparison so that ordering of URI's can be acheived,
            and b) allowing a returned boolean value to be bound to a variable
            ("bval is greaterThan(x,y)"). Note that the latter only works with
            the explicit form of the built-in, not with the "x &gt; y"
            representation.</td>
        </tr>
        <tr>
          <td width="21%">lessThan(x,y)<br>
            &nbsp; or <br>
            x &lt; y</td>
          <td width="24%">LessThan</td>
          <td width="38%">This extends the Jena LessThan built-in by a) adding
            string comparison so that ordering of URI's can be acheived, and b)
            allowing a returned boolean value to be bound to a variable ("bval
            is lessThan(x,y)"). Note that the latter only works with the
            explicit form of the built-in, not with the "x &lt; y"
            representation.</td>
        </tr>
        <tr>
          <td width="27%">(1): lst is list(s, p)
            <p style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size="3">or</font></p>
            <p style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font size="3">lst is list(s, p,
                x)</font></p>
            <p style="color: rgb(0, 0, 0); font-family: Times New Roman; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial">
              (2): lst is list(s1, p1, o1, s2, p2, o2, ..., sn, pn)</p>
            <p style="color: rgb(0, 0, 0); font-family: Times New Roman; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial">
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or</p>
            <p style="color: rgb(0, 0, 0); font-family: Times New Roman; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial">
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lst is list(s1, p1, o1, s2,
              p2, o2, ..., sn, pn, x)</p>
            <p style="color: rgb(0, 0, 0); font-family: Times New Roman; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial">
              (3): lst is list(lit1, lit2, lit3, ....)</p>
          </td>
          <td width="24%">List</td>
          <td width="37%">This built-in returns an rdf:List instance whose
            contents is determined by the arguments. There are three forms as
            shown in the first column. The first two forms specify graph
            patterns with one unbound variable node (implicit or explicit) that
            are to be matched to create the list. Form (1) identifies a graph
            node anchor or subject as the first argument and a graph edge or
            property as the second argument. A free (unbound) variable may be
            specified as the 3rd argument but is implied if not explicit--the
            list is the possible bindings of this variable. Form (2) is an
            extension of form (1) and has a series of subject-predicate-object
            specifications in triple patterns. The subject of a subsequent
            triple pattern can be the object of a previous pattern, or any other
            combination as long as the triple patterns are related in some way.
            The unbound variable, whose bindings will constitute the list, is
            the last argument, either implicit or explicit. Form (3) creates a
            list of all of the arguments when they are all literal values or
            individuals. (Note that the actual test is not property and not
            class.)
            <p> Note that this built-in will return duplicate list items if the
              occur. To remove duplicate items from a list use the "unique"
              built-in.</p>
          </td>
        </tr>
        <tr>
          <td width="27%">list3 is listConcat(list1, list2)</td>
          <td width="24%">ListConcat</td>
          <td width="37%">This built-in is for use in a rule premise and
            concatenates two lists together to form a new list.</td>
        </tr>
        <tr>
          <td width="27%">lst is listSubtract(list1, list2)</td>
          <td width="24%">ListSubtract</td>
          <td width="37%">Remove all members of list2 from list1, if they are in
            list1, and return what remains.</td>
        </tr>
        <tr>
          <td width="27%">str is listToString(lst)</td>
          <td width="24%">ListToString</td>
          <td width="37%">Converts a list to a string representation of the list</td>
        </tr>
        <tr>
          <td width="27%">ln is localname(concept)</td>
          <td width="24%">Localname</td>
          <td width="37%">Where concept is an rdf:Resource with a URI, return
            the local name</td>
        </tr>
        <tr>
          <td width="27%">y is max(x1, x2, ...)<br>
            y is max(lst)<br>
            y is max(s1,p1,o1,s2,p2,o2,...)</td>
          <td width="24%">Max</td>
          <td width="37%">Return the minimum of any number of arguments, each of
            which must be a numerical value.&nbsp; Can take a single argument of
            type rdf:List. Can also take a graph pattern (3rd example) as input,
            see notes after this table.</td>
        </tr>
        <tr>
          <td width="27%">y is min(x1, x2, ...)<br>
            y is min(lst)<br>
            y is min(s1,p1,o1,s2,p2,o2,...)</td>
          <td width="24%">Min</td>
          <td width="37%">Return the minimum of any number of arguments, each of
            which must be a numerical value. Can take a single argument of type
            rdf:List. Can also take a graph pattern (3rd example) as input, see
            notes after this table.</td>
        </tr>
        <tr>
          <td width="27%">z is mod(x,y)</td>
          <td width="24%">Mod</td>
          <td width="37%">Return the value of x mod y</td>
        </tr>
        <tr>
          <td width="27%">noSubjectsOtherThan(s, p, o)</td>
          <td width="24%">NoSubjectsOtherThan</td>
          <td width="37%">Given three arguments, s, p, and o, which identify a
            triple pattern, return true (premise matches) if and only if the
            model contains the specified triple but does not contain any other
            triples with the same predicate and object</td>
        </tr>
        <tr>
          <td width="27%">notOnlyValue(s, p, o)</td>
          <td width="24%">NotOnlyValue</td>
          <td width="37%">Returns true if there is at least one triple with
            subject s, property p, and value o but there is also at least one
            triple with subject s, property p, and a value other than o.</td>
        </tr>
        <tr>
          <td width="27%">noUnknownValues(s, op, p2)</td>
          <td width="24%">NoUnknownValues</td>
          <td width="37%">For the given subject s, if all values of the object
            property op have at least one value of the property p2, return true.
            Otherwise return false.</td>
        </tr>
        <tr>
          <td width="27%">noValue(s, p)<br style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
            noValue(s, p, o)<br style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
            noValue(s, p1, p2, p3, ..., pn)<br style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">
            noValue(s, p1, p2, p3, ..., pn, o)<br>
            noValue(s1,p1,o1,s2,p2,o2,...)</td>
          <td width="24%">NoValue</td>
          <td width="37%"> <span style="color: rgb(0, 0, 0); font-family: &quot;Times New Roman&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">
              1</span>) Subject s has no property p. 2) Subject s does not have
            property p with value o. 3) Starting at node s, there is no set of
            triples with edges p1, p2, .. , pn that leads to one or more values.
            4) Starting at node s, there is no set of triples with edges p1, p2,
            ...,pn that lead to a value o. 5) The triple pattern expressed by
            the arguments (see notes below table) does not exist in the graph.</td>
        </tr>
        <tr>
          <td width="27%">noValuesOtherThan(s, p, o)</td>
          <td width="24%">NoValuesOtherThan</td>
          <td width="37%">Given three arguments, s, p, and o, which identify a
            triple pattern, return true (premise matches) if and only if the
            model contains the specified triple but does not contain any other
            triples with the same subject and predicate</td>
        </tr>
        <tr>
          <td>oneOf(x, val1, val2, ...)<br>
          </td>
          <td>OneOf</td>
          <td>In the Jena a rule cannot have a disjunction. The <em>oneOf</em>
            built-in enables one kind of disjunction by returning true if the
            first argument matches any of the subsequent arguments, either by
            URI for instances and classes, or by string matching for literals.
            Otherwise it returns false. The first argument is normally a bound
            variable, which could be a class to which something belongs or the
            value of a property, and the subsequent arguments are the values for
            which the rule should fire. Note that <em>oneOf</em> only returns
            true or false to allow or disallow rule firing. It does not bind a
            value to an output variable. Without <em>oneOf</em>, a rule would
            have to be written for each matching argument.<br>
          </td>
        </tr>
        <tr>
          <td width="27%">y is pow(x1, x2)</td>
          <td width="24%">Pow</td>
          <td width="37%">Return the result of raising the first argument, which
            must be a numerical value to the second, which must also be a
            numerical value</td>
        </tr>
        <tr>
          <td width="27%">print("hi there ", x)</td>
          <td width="24%">Print</td>
          <td width="37%">Like the Jena print builtin, but overrides it to
            output to stdout. For the IDE, this will be the console window.</td>
        </tr>
        <tr>
          <td width="27%">y is product(x1, x2, ...) <br>
            y is product(lst)<br>
            y is product(s1,p1,o1,s2,p2,o2,...)</td>
          <td width="24%">Product</td>
          <td width="37%">For 2 or more arguments, return the product of the
            arguments, all of which must be numerical values. Alternatively, a
            single argument is an rdf:List of numerical values which are
            multiplied together to determine the return value. Can also take a
            graph pattern (3rd example) as input, see notes after this table.</td>
        </tr>
        <tr>
          <td width="21%">y is sin(x)</td>
          <td width="24%">Sin</td>
          <td width="38%">Return the sine of the numerical value x representing
            an angle in radians</td>
        </tr>
        <tr>
          <td width="27%">y is sqrt(x)</td>
          <td width="24%">Sqrt</td>
          <td width="37%">Return the square root of a number x</td>
        </tr>
        <tr>
          <td>x is strafter(str, delim)<br>
          </td>
          <td>StrAfter</td>
          <td>The string <em>str</em> is split using the Java String split
            method on the delimiter <em>delim</em> and portion of <em>str</em>
            that is found after <em>delim</em> is returned.<br>
          </td>
        </tr>
        <tr>
          <td>x is strbefore(str, delim) </td>
          <td>StrBefore</td>
          <td>The string <em>str</em> is split using the Java String split
            method on the delimiter <em>delim</em> and portion of <em>str</em>
            that is found before <em>delim</em> is returned. </td>
        </tr>
        <tr>
          <td width="27%">y is subtractDates(x1, x2, x3)</td>
          <td width="24%">SubtractDates</td>
          <td width="37%">The first argument must be an xsd DateTime. The second
            argument may be (a) an xsd DateTime, in which case the difference
            between the first and second arguments is computed, or it may be (b)
            a number, in which case its value is subtracted from the first
            argument. The third argument is a string which must begin with one
            of "y" (year), "mo" (month), "d" (day), "mi" (minute), "h" (hour),
            or "s (second). If the second argument is an xsd DateTime (a), the
            difference is converted to a number with the units specified by the
            third argument. If the second argument is a number (b), then the
            third argument is taken to be the units of this number. The
            calculated value, which will be (a) a number, or (b) an xsd
            DateTime, is returned.</td>
        </tr>
        <tr>
          <td width="27%">y is sum(x1, x2, ...) <br>
            y is sum(lst)<br>
            y is sum(s1,p1,o1,s2,p2,o2,...)</td>
          <td width="24%">Sum</td>
          <td width="37%">For 2 or more arguments, return the sum of the
            arguments, all of which must be numerical values. Alternatively, a
            single argument is an rdf:List of numerical values which are summed
            to determine the return value. Can also take a graph pattern (3rd
            example) as input, see notes after this table.</td>
        </tr>
        <tr>
          <td width="21%">y is tan(x)</td>
          <td width="24%">Tan</td>
          <td width="38%">Return the tangent of the numerical value x
            representing an angle in radians</td>
        </tr>
        <tr>
          <td><font size="2" color="#800080">then</font><font size="2"> </font>
            <font size="2" color="#800080">there</font><font size="2"> </font>
            <font size="2" color="#800080">exists</font><font size="2"> </font>
            <font size="2" color="#800080">a</font><font size="2"> </font> <font
              size="2" color="#000080"><b>Velocity</b></font><font size="2"> </font>
            <font size="2" color="#800080">and the </font><font size="2" color="#800080"><font
                size="2" color="#000080"><b>Velocity</b></font> has</font><font
              size="2"> </font> <font size="2" color="#008000"><b>^value</b></font><font
              size="2"> </font> <font size="2" color="#ff00ff"><b>sosair</b></font><font
              size="2"> </font> <font size="2" color="#800080">and</font><font
              size="2"> </font> <font size="2" color="#800080">the</font><font
              size="2"> </font> <font size="2" color="#000080"><b>Velocity</b></font><font
              size="2"> </font> <font size="2" color="#800080">has</font><font
              size="2"> </font> <font size="2" color="#008000"><b>unit</b></font><font
              size="2"> </font> <font size="2" color="#ff00ff"><b>vunit</b></font><font
              size="2"> </font> <font size="2" color="#800080">plus </font><font
              size="2" color="#008000"><b> speedOfSound</b></font><font size="2">
            </font> <font size="2" color="#800080">of</font><font size="2"> </font>
            <font size="2" color="#ff00ff"><b>air</b></font><font size="2"> </font>
            <font size="2" color="#800080">is</font><font size="2"> </font> <font
              size="2" color="#800080">the</font><font size="2"> </font> <font
              size="2" color="#000080"><b>Velocity<br>
              </b></font>&nbsp;&nbsp;&nbsp; or<br>
            ...<font size="2" color="#800080">then</font><font size="2"> </font>
            <font size="2" color="#800080"> <b style="color: rgb(128, 20, 128); font-family: &quot;Times New Roman&quot;; font-size: small; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: -webkit-left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;">thereExists</b></font><font
              size="2">(</font><font size="2" color="#000080"><b>Velocity</b></font><font
              size="2">, </font><font size="2" color="#008000"><b>^value</b></font><font
              size="2"><font size="2">,</font> </font> <font size="2" color="#ff00ff"><b>sosair</b></font><font
              size="2">,</font><font size="2"> </font> <font size="2" color="#008000"><b>unit</b></font><font
              size="2"><font size="2">,</font> "m/sec"</font><font size="2"><font
                size="2">, </font></font><font size="2"><font size="2"> <span
                  style="color: rgb(0, 0, 255); font-family: &quot;Times New Roman&quot;; font-size: small; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: -webkit-left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">Plus</span></font></font><font
              size="2"><font size="2"><font size="2">, </font></font></font><font
              size="2" color="#ff00ff"><b>air</b></font><font size="2"><font size="2"><font
                  size="2"><font size="2"><font size="2">,</font></font></font></font>
            </font><font size="2"><font size="2" color="#008000"><b>speedOfSound</b></font>)</font><font
              size="2" color="#800080">&nbsp;</font><font size="2">&nbsp;</font><font
              size="2">&nbsp;</font><font size="2">&nbsp;</font><font size="2">&nbsp;</font></td>
          <td>ThereExists</td>
          <td>Only a rule conclusion can contain <em>thereExists</em> so the
            built-in is never executed unless the rule fires. The first argument
            identifies the class of the instance to be found. Subsequent
            argument pairs identify the necessary triples that must contain an
            instance for it to match. After the Plus argument, additional
            triples patterns may be specified to create additional (non-key)
            triples. For a more thorough discussion with examples, see <a href="ThereExists.html">There
              Exists</a>.<br>
          </td>
        </tr>
        <tr>
          <td width="27%">lst2 is unique(lst1)</td>
          <td width="24%">Unique</td>
          <td width="37%">Takes an rdf:List instance as input and removes any
            duplicate list items, returning the resulting list. If there are no
            duplicates the original list is returned.</td>
        </tr>
      </tbody>
    </table>
    <p>Several of these built-ins have special syntax in SADL. These include the
      following.</p>
    <ol>
      <li>NoValue (Jena built-in): p of x is unknown, p of x is not v</li>
      <li>NoValuesOtherThan: p of x is only y</li>
      <li>NotOnlyValue: p of x is not only y</li>
    </ol>
    <h3>Built-in Functions in the package <em>com.naturalsemantics.sadl.jena.reasoner.builtin</em>.</h3>
    <p>There are several built-in functions supporting SADL typed lists. The
      package name for these is <em>com.naturalsemantics.sadl.jena.reasoner.builtin</em>.
    </p>
    <p> </p>
    <table style="BORDER-COLLAPSE: collapse" width="100%" cellspacing="0" cellpadding="0"
      bordercolor="#111111" border="1">
      <tbody>
        <tr>
          <td width="21%"><b>Built-in, SADL Rule Syntax</b></td>
          <td width="24%"><b>Java Implementation Class</b></td>
          <td width="38%"><b>Purpose</b></td>
        </tr>
        <tr>
          <td width="21%">newList is deleteElementFromList(existingList, idx)</td>
          <td width="24%">DeleteElementFromList</td>
          <td width="38%">Create and return a new list which is a duplicate of
            the original list minus the idx<sup>th</sup> element. Returns false
            (rule will not fire) if the element is not found.</td>
        </tr>
        <tr>
          <td width="21%">element2 is elementAfter(existingList, element1)</td>
          <td width="24%">ElementAfter</td>
          <td width="38%">Find and return the element in the existing list after
            the specified element. Return false (rule will not fire) if the
            element is not found.</td>
        </tr>
        <tr>
          <td width="21%">element1 is elementBefore(existingList, element2)</td>
          <td width="24%">ElementBefore</td>
          <td width="38%">Find and return the element in the existing list
            before the specified element. Return false (rule will not fire) if
            the element is not found.</td>
        </tr>
        <tr>
          <td width="21%">element is elementInList(existingList, idx)</td>
          <td width="24%">ElementInList</td>
          <td width="38%">Find and return the idx<sup>th</sup> element in the
            existing list. Return false (rule will not fire) if there is index
            is not in the range of the length of the list.</td>
        </tr>
        <tr>
          <td width="21%">element is firstElement(existingList)</td>
          <td width="24%">FirstElement</td>
          <td width="38%">Return the first element of the existing list. Return
            false (rule will not fire) if the existing list is empty.</td>
        </tr>
        <tr>
          <td width="21%">idx is index(existingList, element)</td>
          <td width="24%">Index</td>
          <td width="38%">Return the index of the specified element in the
            existing list. Return false (rule will not fire) if the element is
            not found in the list.</td>
        </tr>
        <tr>
          <td width="21%">newList is insertElementInList(existingList, element,
            idx)</td>
          <td width="24%">InsertElementInList</td>
          <td width="38%">Create and return a new list which is a duplicate of
            the original list plus the specified element inserted in the idx<sup>th</sup>
            location in the list.</td>
        </tr>
        <tr>
          <td width="21%">isListHead(existingList)</td>
          <td width="24%">isListHead</td>
          <td width="38%">Check if the existing list is the head of a list, that
            is it is not the value of the <em>rest</em> property of another
            list.</td>
        </tr>
        <tr>
          <td width="21%">element is lastElement(existingList)</td>
          <td width="24%">LastElement</td>
          <td width="38%">Return the last element of the existing list. Return
            false (rule will not fire) if the existing list is empty.</td>
        </tr>
        <tr>
          <td width="21%">length is listLength(existingList)</td>
          <td width="24%">ListLength</td>
          <td width="38%">Return the length of the existing list. Return false
            (rule will not fire) only if the list does not exist.</td>
        </tr>
        <tr>
          <td width="21%">str is sadlListToString(existingList)</td>
          <td width="24%">SadlListToString</td>
          <td width="38%">Translate the existing list into a string
            representation of the list in SADL syntax.</td>
        </tr>
      </tbody>
    </table>
    <p>For additional documentation on these list built-in functions, and to see
      the SADL grammar syntax available for many of them, see <a href="ListsInSADL.html">Lists
        in SADL</a>.</p>
  </body>
</html>
